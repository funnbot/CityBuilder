<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Unity.InputSystem</name>
    </assembly>
    <members>
        <member name="T:UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            A union holding a primitive value.
            </summary>
            <remarks>
            This structure is used for storing things such as default states for controls
            (see <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.defaultState"/>). It can
            store one value of any primitive, non-reference C# type (bool, char, int, float, etc).
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.PrimitiveValue.type">
            <summary>
            Type of value stored in the struct. <see cref="F:System.TypeCode.Empty"/>
            if the struct does not hold a value (i.e. has been default-initialized).
            </summary>
            <value>Type of value stored in the struct.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.PrimitiveValue.isEmpty">
            <summary>
            If true, the struct does not contain a primitive value (i.e. has <see cref="P:UnityEngine.InputSystem.Utilities.PrimitiveValue.type"/>
            <see cref="F:System.TypeCode.Empty"/>).
            </summary>
            <value>Whether the struct is holding a value or not.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Boolean)">
            <summary>
            Create a PrimitiveValue holding a bool.
            </summary>
            <param name="value">A boolean value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Char)">
            <summary>
            Create a PrimitiveValue holding a character.
            </summary>
            <param name="value">A character.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Byte)">
            <summary>
            Create a PrimitiveValue holding a byte.
            </summary>
            <param name="value">A byte value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.SByte)">
            <summary>
            Create a PrimitiveValue holding a signed byte.
            </summary>
            <param name="value">A signed byte value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Int16)">
            <summary>
            Create a PrimitiveValue holding a short.
            </summary>
            <param name="value">A short value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.UInt16)">
            <summary>
            Create a PrimitiveValue holding an unsigned short.
            </summary>
            <param name="value">An unsigned short value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Int32)">
            <summary>
            Create a PrimitiveValue holding an int.
            </summary>
            <param name="value">An int value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.UInt32)">
            <summary>
            Create a PrimitiveValue holding an unsigned int.
            </summary>
            <param name="value">An unsigned int value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Int64)">
            <summary>
            Create a PrimitiveValue holding a long.
            </summary>
            <param name="value">A long value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.UInt64)">
            <summary>
            Create a PrimitiveValue holding a ulong.
            </summary>
            <param name="value">An unsigned long value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Single)">
            <summary>
            Create a PrimitiveValue holding a float.
            </summary>
            <param name="value">A float value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.#ctor(System.Double)">
            <summary>
            Create a PrimitiveValue holding a double.
            </summary>
            <param name="value">A double value.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ConvertTo(System.TypeCode)">
             <summary>
             Convert to another type of value.
             </summary>
             <param name="type">Type of value to convert to.</param>
             <returns>The converted value.</returns>
             <exception cref="T:System.ArgumentException">There is no conversion from the
             PrimitiveValue's current <see cref="P:UnityEngine.InputSystem.Utilities.PrimitiveValue.type"/> to
             <paramref name="type"/>.</exception>
             <remarks>
             This method simply calls the other conversion methods (<see cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToBoolean(System.IFormatProvider)"/>,
             <see cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToChar(System.IFormatProvider)"/>, etc) based on the current type of value. <c>ArgumentException</c>
             is thrown if there is no conversion from the current to the requested type.
            
             Every value can be converted to <c>TypeCode.Empty</c>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToBoolean(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToChar(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToByte(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToSByte(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt16(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt32(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt64(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt16(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt32(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt64(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToSingle(System.IFormatProvider)"/>
             <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToDouble(System.IFormatProvider)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.Equals(UnityEngine.InputSystem.Utilities.PrimitiveValue)">
            <summary>
            Compare this value to <paramref name="other"/>.
            </summary>
            <param name="other">Another value.</param>
            <returns>True if the two values are equal.</returns>
            <remarks>
            Equality is based on type and contents. The types of both values
            must be identical and the memory contents of each value must be
            bit-wise identical (i.e. things such as floating-point epsilons
            are not taken into account).
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.Equals(System.Object)">
            <summary>
            Compare this value to the value of <paramref name="obj"/>.
            </summary>
            <param name="obj">Either another PrimitiveValue or a boxed primitive
            value such as a byte, bool, etc.</param>
            <returns>True if the two values are equal.</returns>
            <remarks>
            If <paramref name="obj"/> is a boxed primitive value, it is automatically
            converted to a PrimitiveValue.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Equality(UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.Utilities.PrimitiveValue)">
            <summary>
            Compare two PrimitiveValues for equality.
            </summary>
            <param name="left">First value.</param>
            <param name="right">Second value.</param>
            <returns>True if the two values are equal.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.Equals(UnityEngine.InputSystem.Utilities.PrimitiveValue)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Inequality(UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.Utilities.PrimitiveValue)">
            <summary>
            Compare two PrimitiveValues for inequality.
            </summary>
            <param name="left">First value.</param>
            <param name="right">Second value.</param>
            <returns>True if the two values are not equal.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.Equals(UnityEngine.InputSystem.Utilities.PrimitiveValue)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.GetHashCode">
            <summary>
            Compute a hash code for the value.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToString">
            <summary>
            Return a string representation of the value.
            </summary>
            <returns>A string representation of the value.</returns>
            <remarks>
            String versions of PrimitiveValues are always culture invariant. This means that
            floating-point values, for example, will <em>not</em> the decimal separator of
            the current culture.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromString(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromString(System.String)">
            <summary>
            Parse the given string into a PrimitiveValue.
            </summary>
            <param name="value">A string containing a value.</param>
            <returns>The PrimitiveValue parsed from the string.</returns>
            <remarks>
            Integers are parsed as longs. Floating-point numbers are parsed as doubles.
            Hexadecimal notation is supported for integers.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToString"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.GetTypeCode">
            <summary>
            Equivalent to <see cref="P:UnityEngine.InputSystem.Utilities.PrimitiveValue.type"/>.
            </summary>
            <returns>Type code for value stored in struct.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert the value to a boolean.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted boolean value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToByte(System.IFormatProvider)">
            <summary>
            Convert the value to a byte.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted byte value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToChar(System.IFormatProvider)">
            <summary>
            Convert the value to a char.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted char value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToDateTime(System.IFormatProvider)">
            <summary>
            Not supported. Throws <c>NotSupportedException</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Does not return.</returns>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert the value to a decimal.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Value converted to decimal format.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToDouble(System.IFormatProvider)">
            <summary>
            Convert the value to a double.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted double value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt16(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>short</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>short</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt32(System.IFormatProvider)">
            <summary>
            Convert the value to an <c>int</c>
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>int</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToInt64(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>long</c>
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>long</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToSByte(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>sbyte</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>sbyte</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToSingle(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>float</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>float</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToString(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>string</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>string</c> value.</returns>
            <remarks>
            Same as calling <see cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToString"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Not supported.
            </summary>
            <param name="conversionType">Ignored.</param>
            <param name="provider">Ignored.</param>
            <returns>Does not return.</returns>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>ushort</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>ushort</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>uint</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>uint</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert the value to a <c>ulong</c>.
            </summary>
            <param name="provider">Ignored.</param>
            <returns>Converted <c>ulong</c> value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.ToObject">
            <summary>
            Return a boxed version of the value.
            </summary>
            <returns>A boxed GC heap object.</returns>
            <remarks>
            This method always allocates GC heap memory.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.From``1(``0)">
            <summary>
            Create a PrimitiveValue from the given "blittable"/struct value.
            </summary>
            <param name="value">A value.</param>
            <typeparam name="TValue">Type of value to convert. Must be either an <c>enum</c>
            or one of the C# primitive value types (<c>bool</c>, <c>int</c>, <c>float</c>, etc.).</typeparam>
            <returns>The PrimitiveValue converted from <paramref name="value"/>. If it is an
            <c>enum</c> type, the PrimitiveValue will hold a value of the enum's underlying
            type (i.e. <c>Type.GetEnumUnderlyingType</c>).</returns>
            <exception cref="T:System.ArgumentException">No conversion exists from the given <typeparamref name="TValue"/>
            type.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromObject(System.Object)">
            <summary>
            Create a PrimitiveValue from a boxed value.
            </summary>
            <param name="value">A value. If <c>null</c>, the result will be <c>default(PrimitiveValue)</c>.
            If it is a <c>string</c>, <see cref="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromString(System.String)"/> is used. Otherwise must be either an <c>enum</c>
            or one of the C# primitive value types (<c>bool</c>, <c>int</c>, <c>float</c>, etc.). If it is an
            <c>enum</c> type, the PrimitiveValue will hold a value of the enum's underlying
            type (i.e. <c>Type.GetEnumUnderlyingType</c>).</param>
            <exception cref="T:System.ArgumentException">No conversion exists from the type of <paramref name="value"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Boolean)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a bool.
            </summary>
            <param name="value">A boolean value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Char)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a character.
            </summary>
            <param name="value">A character.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Byte)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a byte.
            </summary>
            <param name="value">A byte value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.SByte)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a signed byte.
            </summary>
            <param name="value">A signed byte value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Int16)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a short.
            </summary>
            <param name="value">A short value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.UInt16)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding an unsigned short.
            </summary>
            <param name="value">An unsigned short value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Int32)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding an int.
            </summary>
            <param name="value">An int value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.UInt32)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding an unsigned int.
            </summary>
            <param name="value">An unsigned int value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Int64)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a long.
            </summary>
            <param name="value">A long value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.UInt64)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a ulong.
            </summary>
            <param name="value">An unsigned long value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Single)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a float.
            </summary>
            <param name="value">A float value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.op_Implicit(System.Double)~UnityEngine.InputSystem.Utilities.PrimitiveValue">
            <summary>
            Create a PrimitiveValue holding a double.
            </summary>
            <param name="value">A double value.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromBoolean(System.Boolean)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromChar(System.Char)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromByte(System.Byte)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromSByte(System.SByte)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromInt16(System.Int16)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromUInt16(System.UInt16)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromInt32(System.Int32)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromUInt32(System.UInt32)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromInt64(System.Int64)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromUInt64(System.UInt64)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromSingle(System.Single)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.PrimitiveValue.FromDouble(System.Double)">
            <summary>
            Constructs a <c>PrimitiveValue</c> from <paramref name="value"/>.
            </summary>
            <param name="value">The value to be stored in the returned <c>PrimitiveValue</c>.</param>
            <returns>A <c>PrimitiveValue</c> set to <paramref name="value"/></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.Vector2MagnitudeComparer">
             <summary>
             Compare two <see cref="T:UnityEngine.Vector2"/> by magnitude.
             </summary>
             <example>
             <code>
             </code>
             public class CompositeWithVector2Part : InputBindingComposite&lt;Vector2&gt;
             {
                 [InputControl(layout = "Vector2")]
                 public int part;
            
                 public override Vector2 ReadValue(ref InputBindingCompositeContext context)
                 {
                     // Return the Vector3 with the greatest magnitude.
                     return context.ReadValue&lt;Vector2, Vector2MagnitudeComparer&gt;(part);
                 }
             }
             </example>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.Vector3MagnitudeComparer">
             <summary>
             Compare two <see cref="T:UnityEngine.Vector3"/> by magnitude.
             </summary>
             <example>
             <code>
             </code>
             public class CompositeWithVector3Part : InputBindingComposite&lt;Vector3&gt;
             {
                 [InputControl(layout = "Vector3")]
                 public int part;
            
                 public override Vector3 ReadValue(ref InputBindingCompositeContext context)
                 {
                     // Return the Vector3 with the greatest magnitude.
                     return context.ReadValue&lt;Vector3, Vector2MagnitudeComparer&gt;(part);
                 }
             }
             </example>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.DisplayStringFormatAttribute">
            <summary>
            Provide a format string to use when creating display strings for instances of the class.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.DisplayStringFormatAttribute.formatString">
            <summary>
            Format template string in the form of "{namedPart} verbatimText". All named parts enclosed in
            curly braces are replaced from context whereas other text is included as is.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.FourCC">
            <summary>
            A four-character code.
            </summary>
            <remarks>
            A four-character code is a struct containing four byte characters totalling a single <c>int</c>.
            FourCCs are frequently used in the input system to identify the format of data sent to or from
            the native backend representing events, input device state or commands sent to input devices.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.#ctor(System.Int32)">
            <summary>
            Create a FourCC from the given integer.
            </summary>
            <param name="code">FourCC code represented as an <c>int</c>. Character order is
            little endian. "ABCD" is stored with A in the highest order 8 bits and D in the
            lowest order 8 bits.</param>
            <remarks>
            This method does not actually verify whether the four characters in the code
            are printable.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.#ctor(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Create a FourCC from the given four characters.
            </summary>
            <param name="a">First character.</param>
            <param name="b">Second character.</param>
            <param name="c">Third character.</param>
            <param name="d">Fourth character.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.#ctor(System.String)">
            <summary>
            Create a FourCC from the given string.
            </summary>
            <param name="str">A string with four characters or less but with at least one character.</param>
            <exception cref="T:System.ArgumentException"><paramref name="str"/> is empty or has more than four characters.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.op_Implicit(UnityEngine.InputSystem.Utilities.FourCC)~System.Int32">
            <summary>
            Convert the given FourCC into an <c>int</c>.
            </summary>
            <param name="fourCC">A FourCC.</param>
            <returns>The four characters of the code packed into one <c>int</c>. Character order is
            little endian. "ABCD" is stored with A in the highest order 8 bits and D in the
            lowest order 8 bits.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.op_Implicit(System.Int32)~UnityEngine.InputSystem.Utilities.FourCC">
            <summary>
            Convert the given <c>int</c> into a FourCC.
            </summary>
            <param name="i">FourCC code represented as an <c>int</c>. Character order is
            little endian. "ABCD" is stored with A in the highest order 8 bits and D in the
            lowest order 8 bits.</param>
            <returns>The FourCC converted from <paramref name="i"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.ToString">
            <summary>
            Convert the FourCC into a string in the form of "ABCD".
            </summary>
            <returns>String representation of the FourCC.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.Equals(UnityEngine.InputSystem.Utilities.FourCC)">
            <summary>
            Compare two FourCCs for equality.
            </summary>
            <param name="other">Another FourCC.</param>
            <returns>True if the two FourCCs are equal, i.e. have the same exact
            character codes.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.Equals(System.Object)">
            <summary>
            Compare the FourCC to the given object.
            </summary>
            <param name="obj">An object. Can be null.</param>
            <returns>True if <paramref name="obj"/> is a FourCC that has the same
            character code sequence.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.GetHashCode">
            <summary>
            Compute a hash code for the FourCC.
            </summary>
            <returns>Simply returns the FourCC converted to an <c>int</c>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.op_Equality(UnityEngine.InputSystem.Utilities.FourCC,UnityEngine.InputSystem.Utilities.FourCC)">
            <summary>
            Compare two FourCCs for equality.
            </summary>
            <param name="left">First FourCC.</param>
            <param name="right">Second FourCC.</param>
            <returns>True if the two FourCCs are equal, i.e. have the same exact
            character codes.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.FourCC.op_Inequality(UnityEngine.InputSystem.Utilities.FourCC,UnityEngine.InputSystem.Utilities.FourCC)">
            <summary>
            Compare two FourCCs for inequality.
            </summary>
            <param name="left">First FourCC.</param>
            <param name="right">Second FourCC.</param>
            <returns>True if the two FourCCs are not equal, i.e. do not have the same exact
            character codes.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.NameAndParameters">
            <summary>
            A combination of a name and an optional list of named parameter values. For example, "Clamp(min=1,max=2)".
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.InternedString">
             <summary>
             Wraps around a string to allow for faster case-insensitive string comparisons while
             preserving original casing.
             </summary>
             <remarks>
             Unlike <c>string</c>, InternedStrings can be compared with a quick <c>Object.ReferenceEquals</c>
             comparison and without actually comparing string contents.
            
             Also, unlike <c>string</c>, the representation of an empty and a <c>null</c> string is identical.
            
             Note that all string comparisons using InternedStrings are both case-insensitive and culture-insensitive.
            
             There is a non-zero cost to creating an InternedString. The first time a new unique InternedString
             is encountered, there may also be a GC heap allocation.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InternedString.length">
            <summary>
            Length of the string in characters. Equivalent to <c>string.Length</c>.
            </summary>
            <value>Length of the string.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.#ctor(System.String)">
             <summary>
             Initialize the InternedString with the given string. Except if the string is <c>null</c>
             or empty, this requires an internal lookup (this is the reason the conversion from <c>string</c>
             to InternedString is not implicit).
             </summary>
             <param name="text">A string. Can be null.</param>
             <remarks>
             The InternedString preserves the original casing. Meaning that <see cref="M:UnityEngine.InputSystem.Utilities.InternedString.ToString"/> will
             return the string as it was supplied through <paramref name="text"/>. However, comparison
             between two InternedStrings is still always just a reference comparisons regardless of case
             and culture.
            
             <example>
             <code>
             var lowerCase = new InternedString("text");
             var upperCase = new InternedString("TEXT");
            
             // This is still just a quick reference comparison:
             if (lowerCase == upperCase)
                 Debug.Log("True");
            
             // But this prints the strings in their original casing.
             Debug.Log(lowerCase);
             Debug.Log(upperCase);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.IsEmpty">
            <summary>
            Whether the string is empty, i.e. has a <see cref="P:UnityEngine.InputSystem.Utilities.InternedString.length"/> of zero. If so, the
            InternedString corresponds to <c>default(InternedString)</c>.
            </summary>
            <returns>True if the string is empty.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.ToLower">
            <summary>
            Return a lower-case version of the string.
            </summary>
            <returns>A lower-case version of the string.</returns>
            <remarks>
            InternedStrings internally always store a lower-case version which means that this
            method does not incur a GC heap allocation cost.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.Equals(System.Object)">
            <summary>
            Compare the InternedString to given object.
            </summary>
            <param name="obj">An object. If it is a <c>string</c>, performs a string comparison. If
            it is an InternedString, performs an InternedString-comparison. Otherwise returns false.</param>
            <returns>True if the InternedString is equal to <paramref name="obj"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.Equals(UnityEngine.InputSystem.Utilities.InternedString)">
            <summary>
            Compare two InternedStrings for equality. They are equal if, ignoring case and culture,
            their text is equal.
            </summary>
            <param name="other">Another InternedString.</param>
            <returns>True if the two InternedStrings are equal.</returns>
            <remarks>
            This operation is cheap and does not involve an actual string comparison. Instead,
            a simple <c>Object.ReferenceEquals</c> comparison is performed.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.GetHashCode">
            <summary>
            Compute a hash code for the string. Equivalent to <c>string.GetHashCode</c>.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InternedString.op_Implicit(UnityEngine.InputSystem.Utilities.InternedString)~System.String">
            <summary>
            Convert the given InternedString back to a <c>string</c>. Equivalent to <see cref="M:UnityEngine.InputSystem.Utilities.InternedString.ToString"/>.
            </summary>
            <param name="str">An InternedString.</param>
            <returns>A string.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1">
             <summary>
             Read-only access to an array or to a slice of an array.
             </summary>
             <typeparam name="TValue">Type of values stored in the array.</typeparam>
             <remarks>
             The purpose of this struct is to allow exposing internal arrays directly such that no
             boxing and no going through interfaces is required but at the same time not allowing
             the internal arrays to be modified.
            
             It differs from <c>ReadOnlySpan&lt;T&gt;</c> in that it can be stored on the heap and differs
             from <c>ReadOnlyCollection&lt;T&gt;</c> in that it supports slices directly without needing
             an intermediate object representing the slice.
            
             Note that in most cases, the ReadOnlyArray instance should be treated as a <em>temporary</em>.
             The actual array referred to by a ReadOnlyArray instance is usually owned and probably mutated
             by another piece of code. When that code makes changes to the array, the ReadOnlyArray
             instance will not get updated.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.#ctor(`0[])">
            <summary>
            Construct a read-only array covering all of the given array.
            </summary>
            <param name="array">Array to index.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Construct a read-only array that covers only the given slice of <paramref name="array"/>.
            </summary>
            <param name="array">Array to index.</param>
            <param name="index">Index at which to start indexing <paramref name="array"/>. The given element
            becomes index #0 for the read-only array.</param>
            <param name="length">Length of the slice to index from <paramref name="array"/>.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.ToArray">
            <summary>
            Convert to array.
            </summary>
            <returns>A new array containing a copy of the contents of the read-only array.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.IndexOf(System.Predicate{`0})">
            <summary>
            Searches for the first element in the array for which the given <paramref name="predicate"/> is <c>true</c> and returns the index of that element.
            </summary>
            <param name="predicate">The predicate to be evaluated for each element which defines the condition for the search.</param>
            <returns>Index of the first element for which <paramref name="predicate"/> is <c>true</c>x or -1 if no such element exists.</returns>
            <exception cref="T:System.ArgumentNullException">If predicate is <c>null</c>.</exception>
            <example>
            <code>
            // Searches for the first element in an integer array that is greater or equal to 5.
            var haystack = new ReadOnlyArray&lt;int&gt;(new[] { 1, 2, 3, 4, 5, 6, 7 });
            var index = haystack.IndexOf((value) => value >= 5); // index == 4
            </code>
            </example>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the read-only array.
            <returns>
            <see cref="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator"/>
            An enumerator for the read-only array.
            </returns>
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.op_Implicit(`0[])~UnityEngine.InputSystem.Utilities.ReadOnlyArray{`0}">
            <summary>
            Constructs a read-only array containing elements <paramref name="array"/>.
            </summary>
            <param name="array">An existing array containing elements to be wrapped as a read-only array.</param>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Count">
            <summary>
            Number of elements in the array.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Item(System.Int32)">
            <summary>
            Return the element at the given index.
            </summary>
            <param name="index">Index into the array.</param>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is less than 0 or greater than <see cref="P:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Count"/>.</exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator">
            <summary>
            <see cref="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1"/>
            Enumerates the elements of a read-only array.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions">
            <summary>
            Extension methods to help with <see cref="T:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions"/> contents.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions.Contains``1(UnityEngine.InputSystem.Utilities.ReadOnlyArray{``0},``0)">
            <summary>
            Evaluates whether <paramref name="array"/> contains an element that compares equal to <paramref name="value"/>.
            </summary>
            <typeparam name="TValue">The array element type.</typeparam>
            <param name="array">Reference to the read-only array to be searched.</param>
            <param name="value">The value to be searched for in <paramref name="array"/>.</param>
            <returns><c>true</c> if <paramref name="array"/> contains <paramref name="value"/>, else <c>false</c>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions.ContainsReference``1(UnityEngine.InputSystem.Utilities.ReadOnlyArray{``0},``0)">
            <summary>
            Evaluates whether <paramref name="array"/> contains a reference to <paramref name="value"/>.
            </summary>
            <typeparam name="TValue">The array element type.</typeparam>
            <param name="array">Reference to the read-only array to be searched.</param>
            <param name="value">The reference to be searched for in <paramref name="array"/>.</param>
            <returns><c>true</c> if <paramref name="array"/> contains a reference to <paramref name="value"/>, else <c>false</c>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions.IndexOfReference``1(UnityEngine.InputSystem.Utilities.ReadOnlyArray{``0},``0)">
            <summary>
            Retrieves the index of <paramref name="value"/> in <paramref name="array"/>.
            </summary>
            <typeparam name="TValue">The array element type.</typeparam>
            <param name="array">Reference to the read-only array to be searched.</param>
            <param name="value">The reference to be searched for in <paramref name="array"/>.</param>
            <returns>The zero-based index of element <paramref name="value"/> in <paramref name="array"/> if such a reference could be found and -1 if it do not exist.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ReadOnlyArrayExtensions.HaveEqualReferences``1(UnityEngine.InputSystem.Utilities.ReadOnlyArray{``0},System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
            Evaluates whether whether <paramref name="array1"/> and <paramref name="array2"/> contain the same sequence of references.
            </summary>
            <typeparam name="TValue">The array element type.</typeparam>
            <param name="array1">The first array to be evaluated.</param>
            <param name="array2">The second array to be evaluated.</param>
            <param name="count">The maximum number of elements to be compared.</param>
            <returns><c>true</c> if the <paramref name="count"/> first elements of <paramref name="array1"/> and <paramref name="array2"/> contain the same references, else false.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.MemCmpBitRegion(System.Void*,System.Void*,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            Compare two memory regions that may be offset by a bit count and have a length expressed
            in bits.
            </summary>
            <param name="ptr1">Pointer to start of first memory region.</param>
            <param name="ptr2">Pointer to start of second memory region.</param>
            <param name="bitOffset">Offset in bits from each of the pointers to the start of the memory region to compare.</param>
            <param name="bitCount">Number of bits to compare in the memory region.</param>
            <param name="mask">If not null, only compare bits set in the mask. This allows comparing two memory regions while
            ignoring specific bits.</param>
            <returns>True if the two memory regions are identical, false otherwise.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.MemCpyMasked(System.Void*,System.Void*,System.Int32,System.Void*)">
            <summary>
            Copy from <paramref name="source"/> to <paramref name="destination"/> all the bits that
            ARE set in <paramref name="mask"/>.
            </summary>
            <param name="destination">Memory to copy to.</param>
            <param name="source">Memory to copy from.</param>
            <param name="numBytes">Number of bytes to copy.</param>
            <param name="mask">Bitmask that determines which bits to copy. Bits that are set WILL be copied.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.ReadMultipleBitsAsUInt(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Reads bits memory region as unsigned int, up to and including 32 bits, least-significant bit first (LSB).
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the unsigned integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <returns>Read unsigned integer.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.WriteUIntAsMultipleBits(System.Void*,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Writes unsigned int as bits to memory region, up to and including 32 bits, least-significant bit first (LSB).
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the unsigned integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.ReadTwosComplementMultipleBitsAsInt(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Reads bits memory region as two's complement integer, up to and including 32 bits, least-significant bit first (LSB).
            For example reading 0xff as 8 bits will result in -1.
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <returns>Read integer.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.WriteIntAsTwosComplementMultipleBits(System.Void*,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Writes bits memory region as two's complement integer, up to and including 32 bits, least-significant bit first (LSB).
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.ReadExcessKMultipleBitsAsInt(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Reads bits memory region as excess-K integer where K is set to (2^bitCount)/2, up to and including 32 bits, least-significant bit first (LSB).
            For example reading 0 as 8 bits will result in -128. Reading 0xff as 8 bits will result in 127.
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <returns>Read integer.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.WriteIntAsExcessKMultipleBits(System.Void*,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Writes bits memory region as excess-K integer where K is set to (2^bitCount)/2, up to and including 32 bits, least-significant bit first (LSB).
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.ReadMultipleBitsAsNormalizedUInt(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Reads bits memory region as normalized unsigned integer, up to and including 32 bits, least-significant bit first (LSB).
            For example reading 0 as 8 bits will result in 0.0f. Reading 0xff as 8 bits will result in 1.0f.
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the unsigned integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <returns>Normalized unsigned integer.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.MemoryHelpers.WriteNormalizedUIntAsMultipleBits(System.Void*,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Writes bits memory region as normalized unsigned integer, up to and including 32 bits, least-significant bit first (LSB).
            </summary>
            <param name="ptr">Pointer to memory region.</param>
            <param name="bitOffset">Offset in bits from the pointer to the start of the unsigned integer.</param>
            <param name="bitCount">Number of bits to read.</param>
            <param name="value">Normalized value to write.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.InlinedArray`1">
            <summary>
            Helper to avoid array allocations if there's only a single value in the array.
            </summary>
            <remarks>
            Also, once more than one entry is necessary, allows treating the extra array as having capacity.
            This means that, for example, 5 or 10 entries can be allocated in batch rather than growing an
            array one by one.
            </remarks>
            <typeparam name="TValue">Element type for the array.</typeparam>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.JsonParser">
            <summary>
            A JSON parser that instead of turning a string in JSON format into a
            C# object graph, allows navigating the source text directly.
            </summary>
            <remarks>
            This helper is most useful for avoiding a great many string and general object allocations
            that would happen when turning a JSON object into a C# object graph.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.JsonParser.NavigateToProperty(System.String)">
            <summary>
            Navigate to the given property.
            </summary>
            <param name="path"></param>
            <remarks>
            This navigates from the current property.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.JsonParser.CurrentPropertyHasValueEqualTo(UnityEngine.InputSystem.Utilities.JsonParser.JsonValue)">
            <summary>
            Return true if the current property has a value matching <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedValue"></param>
            <returns></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.Observable">
            <summary>
            Extension methods for working with <a ref="https://docs.microsoft.com/en-us/dotnet/api/system.iobservable-1">IObservable</a>
            in the context of the Input System.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filter a stream of observable values by a predicate.
            </summary>
            <param name="source">The stream of observable values.</param>
            <param name="predicate">Filter to apply to the stream. Only values for which the predicate returns true
            are passed on to <c>OnNext</c> of the observer.</param>
            <typeparam name="TValue">Value type for the observable stream.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c> -or- <paramref name="predicate"/> is <c>null</c>.</exception>
            <returns>A new observable that is filtered by the given predicate.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .Where(e => e.HasButtonPress())
                .Call(e => Debug.Log("Press"));
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>
            Transform each value in an observable stream of values into a value of a different type.
            </summary>
            <param name="source">The stream of observable values.</param>
            <param name="filter">Function to transform values in the stream.</param>
            <typeparam name="TSource">Type of source values to transform from.</typeparam>
            <typeparam name="TResult">Type of target values to transform to.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c> -or- <paramref name="filter"/> is <c>null</c>.</exception>
            <returns>A new observable of values of the new result type.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .Select(eventPtr => eventPtr.GetFirstButtonPressOrNull())
                .Call(ctrl =>
                {
                    if (ctrl != null)
                        Debug.Log(ctrl);
                });
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform each value in an observable stream of values such that one value is translated to zero or more values
            of a new type.
            </summary>
            <param name="source">The stream of observable values.</param>
            <param name="filter">Function to transform each value in the stream into zero or more new values.</param>
            <typeparam name="TSource">Type of source values to transform from.</typeparam>
            <typeparam name="TResult">Type of target values to transform to.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c> -or- <paramref name="filter"/> is <c>null</c>.</exception>
            <returns>A new observable of values of the new result type.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .SelectMany(eventPtr => eventPtr.GetAllButtonPresses())
                .Call(ctrl =>
                    Debug.Log($"Button {ctrl} pressed"));
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.Take``1(System.IObservable{``0},System.Int32)">
            <summary>
            Take up to the first N values from the given observable stream of values.
            </summary>
            <param name="source">An observable source of values.</param>
            <param name="count">The maximum number of values to take from the source.</param>
            <typeparam name="TValue">Types of values to read from the stream.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative.</exception>
            <returns>A stream of up to <paramref name="count"/> values.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.ForDevice(System.IObservable{UnityEngine.InputSystem.LowLevel.InputEventPtr},UnityEngine.InputSystem.InputDevice)">
             <summary>
             From an observable stream of events, take only those that are for the given <paramref name="device"/>.
             </summary>
             <param name="source">An observable stream of events.</param>
             <param name="device">Device to filter events for.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c>.</exception>
             <returns>An observable stream of events for the given device.</returns>
             <remarks>
             Each event has an <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> associated with it. This is used to match
             against the <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> of <paramref name="device"/>.
            
             <example>
             <code>
             InputSystem.onEvent
                 .ForDevice(Mouse.current)
                 .Call(e => Debug.Log($"Mouse event: {e}");
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.ForDevice``1(System.IObservable{UnityEngine.InputSystem.LowLevel.InputEventPtr})">
            <summary>
            From an observable stream of events, take only those that are for a device of the given type.
            </summary>
            <param name="source">An observable stream of events.</param>
            <typeparam name="TDevice">Type of device (such as <see cref="T:UnityEngine.InputSystem.Gamepad"/>) to filter for.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c>.</exception>
            <returns>An observable stream of events for devices of type <typeparamref name="TDevice"/>.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .ForDevice&lt;Gamepad&gt;()
                .Where(e => e.HasButtonPress())
                .CallOnce(e => PlayerInput.Instantiate(myPrefab,
                    pairWithDevice: InputSystem.GetDeviceById(e.deviceId)));
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.CallOnce``1(System.IObservable{``0},System.Action{``0})">
            <summary>
            Call an action for the first value in the given stream of values and then automatically dispose
            the observer.
            </summary>
            <param name="source">An observable source of values.</param>
            <param name="action">Action to call for the first value that arrives from the source.</param>
            <typeparam name="TValue">Type of values delivered by the source.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c> -or- <paramref name="action"/> is <c>null</c>.</exception>
            <returns>A handle to the subscription. Call <c>Dispose</c> to unsubscribe at any time.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .Where(e => e.type == DeviceConfigurationEvent.typeStatic)
                .CallOnce(_ => Debug.Log("Device configuration changed"));
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.Observable.Call``1(System.IObservable{``0},System.Action{``0})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.Observable.Call``1(System.IObservable{``0},System.Action{``0})">
            <summary>
            Call the given callback for every value generated by the given observable stream of values.
            </summary>
            <param name="source">An observable stream of values.</param>
            <param name="action">A callback to invoke for each value.</param>
            <typeparam name="TValue"></typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <c>null</c> -or- <paramref name="action"/> is <c>null</c>.</exception>
            <returns>A handle to the subscription. Call <c>Dispose</c> to unsubscribe at any time.</returns>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent
                .Where(e => e.type == DeviceConfigurationEvent.typeStatic)
                .Call(_ => Debug.Log("Device configuration changed"));
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.Observable.CallOnce``1(System.IObservable{``0},System.Action{``0})"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.ArrayHelpers">
            <summary>
            A collection of utility functions for working with arrays.
            </summary>
            <remarks>
            The goal of this collection is to make it easy to use arrays directly rather than resorting to
            <see cref="T:System.Collections.Generic.List`1"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ArrayHelpers.EraseAtByMovingTail``1(``0[],System.Int32@,System.Int32)">
            <summary>
            Erase an element from the array by moving the tail element into its place.
            </summary>
            <param name="array">Array to modify. May be not <c>null</c>.</param>
            <param name="count">Current number of elements inside of array. May be less than <c>array.Length</c>.</param>
            <param name="index">Index of element to remove. Tail element will get moved into its place.</param>
            <typeparam name="TValue"></typeparam>
            <remarks>
            This method does not re-allocate the array. Instead <paramref name="count"/> is used
            to keep track of how many elements there actually are in the array.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ArrayHelpers.MoveSlice``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Move a slice in the array to a different place without allocating a temporary array.
            </summary>
            <param name="array"></param>
            <param name="sourceIndex"></param>
            <param name="destinationIndex"></param>
            <param name="count"></param>
            <typeparam name="TValue"></typeparam>
            <remarks>
            The slice is moved by repeatedly swapping slices until all the slices are where they
            are supposed to go. This is not super efficient but avoids having to allocate a temporary
            array on the heap.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.InputActionTrace">
             <summary>
             Records the triggering of actions into a sequence of events that can be replayed at will.
             </summary>
             <remarks>
             This is an alternate way to the callback-based responses (such as <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>)
             of <see cref="T:UnityEngine.InputSystem.InputAction">input actions</see>. Instead of executing response code right away whenever
             an action triggers, an <see cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.RecordAction(UnityEngine.InputSystem.InputAction.CallbackContext)">event is recorded</see> which can then be queried on demand.
            
             The recorded data will stay valid even if the bindings on the actions are changed (e.g. by enabling a different
             set of bindings through altering <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/> or <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/> or
             when modifying the paths of bindings altogether). Note, however, that when this happens, a trace will have
             to make a private copy of the data that stores the binding resolution state. This means that there can be
             GC allocation spike when reconfiguring actions that have recorded data in traces.
            
             <example>
             <code>
             var trace = new InputActionTrace();
            
             // Subscribe trace to single action.
             // (Use UnsubscribeFrom to unsubscribe)
             trace.SubscribeTo(myAction);
            
             // Subscribe trace to entire action map.
             // (Use UnsubscribeFrom to unsubscribe)
             trace.SubscribeTo(myActionMap);
            
             // Subscribe trace to all actions in the system.
             trace.SubscribeToAll();
            
             // Record a single triggering of an action.
             myAction.performed +=
                 ctx =>
                 {
                     if (ctx.ReadValue&lt;float&gt;() &gt; 0.5f)
                         trace.RecordAction(ctx);
                 };
            
             // Output trace to console.
             Debug.Log(string.Join(",\n", trace));
            
             // Walk through all recorded actions and then clear trace.
             foreach (var record in trace)
             {
                 Debug.Log($"{record.action} was {record.phase} by control {record.control} at {record.time}");
            
                 // To read out the value, you either have to know the value type or read the
                 // value out as a generic byte buffer. Here we assume that the value type is
                 // float.
            
                 Debug.Log("Value: " + record.ReadValue&lt;float&gt;());
            
                 // An alternative is read the value as an object. In this case, you don't have
                 // to know the value type but there will be a boxed object allocation.
                 Debug.Log("Value: " + record.ReadValueAsObject());
             }
             trace.Clear();
            
             // Unsubscribe trace from everything.
             trace.UnsubscribeFromAll();
            
             // Release memory held by trace.
             trace.Dispose();
             </code>
             </example>
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onActionChange"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.buffer">
            <summary>
            Directly access the underlying raw memory queue.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.count">
            <summary>
            Returns the number of events in the associated event buffer.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.#ctor">
            <summary>
            Constructs a new default initialized <c>InputActionTrace</c>.
            </summary>
            <remarks>
            When you use this constructor, the new InputActionTrace object does not start recording any actions.
            To record actions, you must explicitly set them up after creating the object.
            Alternatively, you can use one of the other constructor overloads which begin recording actions immediately.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputAction)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputActionMap)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeToAll"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.#ctor(UnityEngine.InputSystem.InputAction)">
            <summary>
            Constructs a new <c>InputActionTrace</c> that records <paramref name="action"/>.
            </summary>
            <param name="action">The action to be recorded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.#ctor(UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Constructs a new <c>InputActionTrace</c> that records all actions in <paramref name="actionMap"/>.
            </summary>
            <param name="actionMap">The action-map containing actions to be recorded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeToAll">
            <summary>
            Record any action getting triggered anywhere.
            </summary>
            <remarks>
            This does not require the trace to actually hook into every single action or action map in the system.
            Instead, the trace will listen to <see cref="E:UnityEngine.InputSystem.InputSystem.onActionChange"/> and automatically record
            every triggered action.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputAction)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputActionMap)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFromAll">
            <summary>
            Unsubscribes from all actions currently being recorded.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputAction)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputActionMap)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputAction)">
            <summary>
            Subscribes to <paramref name="action"/>.
            </summary>
            <param name="action">The action to be recorded.</param>
            <remarks>
            **Note:** This method does not prevent you from subscribing to the same action multiple times.
            If you subscribe to the same action multiple times, your event buffer will contain duplicate entries.
            </remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputActionMap)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeToAll"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Subscribes to all actions contained within <paramref name="actionMap"/>.
            </summary>
            <param name="actionMap">The action-map containing all actions to be recorded.</param>
            <remarks>
            **Note:** This method does not prevent you from subscribing to the same action multiple times.
            If you subscribe to the same action multiple times, your event buffer will contain duplicate entries.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="actionMap"/> is null.</exception>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeTo(UnityEngine.InputSystem.InputAction)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.SubscribeToAll"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputAction)">
            <summary>
            Unsubscribes from an action, if that action was previously subscribed to.
            </summary>
            <param name="action">The action to unsubscribe from.</param>
            <remarks>
            **Note:** This method has no side effects if you attempt to unsubscribe from an action that you have not previously subscribed to.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="action"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputActionMap)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFromAll"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Unsubscribes from all actions included in <paramref name="actionMap"/>.
            </summary>
            <param name="actionMap">The action-map containing actions to unsubscribe from.</param>
            <remarks>
            **Note:** This method has no side effects if you attempt to unsubscribe from an action-map that you have not previously subscribed to.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="actionMap"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFrom(UnityEngine.InputSystem.InputAction)"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.UnsubscribeFromAll"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.RecordAction(UnityEngine.InputSystem.InputAction.CallbackContext)">
            <summary>
            Record the triggering of an action as an <see cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr">action event</see>.
            </summary>
            <param name="context"></param>
            <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>
            <see cref="E:UnityEngine.InputSystem.InputAction.started"/>
            <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
            <see cref="E:UnityEngine.InputSystem.InputActionMap.actionTriggered"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.Clear">
            <summary>
            Clears all recorded data.
            </summary>
            <remarks>
            **Note:** This method does not unsubscribe any actions that the instance is listening to, so after clearing the recorded data, new input on those subscribed actions will continue to be recorded.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ToString">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all action events recorded for this instance.
            </summary>
            <returns>Enumerator instance, never <c>null</c>.</returns>
            <seealso cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr">
            <summary>
            A wrapper around <see cref="T:UnityEngine.InputSystem.LowLevel.ActionEvent"/> that automatically translates all the
            information in events into their high-level representations.
            </summary>
            <remarks>
            For example, instead of returning <see cref="P:UnityEngine.InputSystem.LowLevel.ActionEvent.controlIndex">control indices</see>,
            it automatically resolves and returns the respective <see cref="T:UnityEngine.InputSystem.InputControl">controls</see>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.action">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputAction"/> associated with this action event.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.phase">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputActionPhase"/> associated with this action event.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.control">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputControl"/> instance associated with this action event.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.interaction">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.IInputInteraction"/> instance associated with this action event if applicable, or <c>null</c> if the action event is not associated with an input interaction.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.time">
            <summary>
            The time, in seconds since your game or app started, that the event occurred.
            </summary>
            <remarks>
            Times are in seconds and progress linearly in real-time. The timeline is the same as for <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.startTime">
            <summary>
            The time, in seconds since your game or app started, that the <see cref="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.phase"/> transitioned into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.duration">
            <summary>
            The duration, in seconds, that has elapsed between when this event was generated and when the
            action <see cref="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.phase"/> transitioned to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> and has remained active.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.valueSizeInBytes">
            <summary>
            The size, in bytes, of the value associated with this action event.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValueAsObject">
            <summary>
            Reads the value associated with this event as an <c>object</c>.
            </summary>
            <returns><c>object</c> representing the value of this action event.</returns>
            <seealso cref="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValue(System.Void*,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValue(System.Void*,System.Int32)">
            <summary>
            Reads the value associated with this event into the contiguous memory buffer defined by <c>[buffer, buffer + bufferSize)</c>.
            </summary>
            <param name="buffer">Pointer to the contiguous memory buffer to write value data to.</param>
            <param name="bufferSize">The size, in bytes, of the contiguous buffer pointed to by <paramref name="buffer"/>.</param>
            <exception cref="T:System.NullReferenceException">If <paramref name="buffer"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If the given <paramref name="bufferSize"/> is less than the number of bytes required to write the event value to <paramref name="buffer"/>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValueAsObject"/>
            <seealso cref="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValue``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ReadValue``1">
            <summary>
            Reads the value associated with this event as an object of type <typeparamref name="TValue"/>.
            </summary>
            <typeparam name="TValue">The event value type to be used.</typeparam>
            <returns>Object of type <typeparamref name="TValue"/>.</returns>
            <exception cref="T:System.InvalidOperationException">In case the size of <typeparamref name="TValue"/> does not match the size of the value associated with this event.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.ISavedState">
            <summary>
            Provides type erasure and an abstraction of a saved state that
            will (must) be restored at a later point.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ISavedState.StaticDisposeCurrentState">
            <summary>
            Dispose current state, should be invoked before RestoreSavedState()
            to dispose the current state before restoring a saved state.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.ISavedState.RestoreSavedState">
            <summary>
            Restore previous state, should be invoked after StaticDisposeCurrentState().
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.SavedStructState`1">
            <summary>
            Provides functionality to store and support later restoration of a saved
            state. The state is expected to be a value-type. If the state is not restored
            it must be disposed to not leak resources.
            </summary>
            <typeparam name="T">The value-type representing the state to be stored.</typeparam>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.SavedStructState`1.#ctor(`0@,UnityEngine.InputSystem.Utilities.SavedStructState{`0}.TypedRestore,System.Action)">
            <summary>
            Constructs a SavedStructState.
            </summary>
            <param name="state">The value-type state to be saved.</param>
            <param name="restoreAction">The action to be carried out to restore state.</param>
            <param name="staticDisposeCurrentState">The action to be carried out to dispose current state. May be null.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.OneOrMore`2">
            <summary>
            Helper when having either a single element or a list of elements. Avoids
            having to allocate GC heap garbage or having to alternatively split code paths.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.TypeTable">
            <summary>
            A table mapping names to types in a case-insensitive mapping.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Utilities.StringHelpers.Escape(System.String,System.String,System.String)">
            <summary>
            For every character in <paramref name="str"/> that is contained in <paramref name="chars"/>, replace it
            by the corresponding character in <paramref name="replacements"/> preceded by a backslash.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Utilities.NamedValue">
            <summary>
            A combination of a name and a value assignment for it.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.NamedValue.name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Utilities.NamedValue.value">
            <summary>
            Value of the parameter.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.PlayerInputEditor">
            <summary>
            A custom inspector for the <see cref="T:UnityEngine.InputSystem.PlayerInput"/> component.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.PlayerInputManagerEditor">
            <summary>
            Custom inspector for <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionMapDrawer">
            <summary>
            Property drawer for <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionAssetManager">
            <summary>
            Keeps a reference to the asset being edited and maintains a copy of the asset object
            around for editing.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputSettingsProvider.InitializeWithCurrentSettings">
            <summary>
            Grab <see cref="P:UnityEngine.InputSystem.InputSystem.settings"/> and set it up for editing.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputSettingsProvider.FindInputSettingsInProject">
            <summary>
            Find all <see cref="T:UnityEngine.InputSystem.InputSettings"/> stored in assets in the current project.
            </summary>
            <returns>List of input settings in project.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionPropertiesView">
            <summary>
            UI that edits the properties of an <see cref="T:UnityEngine.InputSystem.InputAction"/>.
            </summary>
            <remarks>
            Right-most pane in <see cref="T:UnityEngine.InputSystem.Editor.InputActionEditorWindow"/> when an action is selected.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionEditorToolbar">
             <summary>
             Toolbar in input action asset editor.
             </summary>
             <remarks>
             Allows editing and selecting from the set of control schemes as well as selecting from the
             set of device requirements within the currently selected control scheme.
            
             Also controls saving and has the global search text field.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Editor.InputActionEditorWindow"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputActionEditorToolbar.selectedControlScheme">
            <summary>
            The control scheme currently selected in the toolbar or null if none is selected.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputActionEditorToolbar.selectedDeviceRequirement">
            <summary>
            The device requirement of the currently selected control scheme which is currently selected
            in the toolbar or null if none is selected.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputActionEditorToolbar.searchText">
            <summary>
            The search text currently entered in the toolbar or null.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionEditorToolbar.ControlSchemePropertiesPopup">
            <summary>
            Popup window content for editing control schemes.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputActionEditorToolbar.ControlSchemePropertiesPopup.controlScheme">
            <summary>
            The control scheme edited by the popup.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionSerializationHelpers.GetCompositeStartIndex(UnityEditor.SerializedProperty,System.Int32)">
            <summary>
            Starting with the given binding, find the composite that the binding belongs to. The given binding
            must either be the composite or be part of a composite.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionImporterEditor">
            <summary>
            Custom editor that allows modifying importer settings for an <see cref="T:UnityEngine.InputSystem.Editor.InputActionImporter"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionCodeGenerator">
            <summary>
            Utility to generate code that makes it easier to work with action sets.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.LinkFileGenerator">
             <summary>
             Input system uses runtime reflection to instantiate and discover some capabilities like layouts, processors, interactions, etc.
             Managed linker on high stripping modes is very keen on removing parts of classes or whole classes.
             One way to preserve the classes is to put [Preserve] on class itself and every field/property we're interested in,
             this was proven to be error prone as it's easy to forget an attribute and tedious as everything needs an attribute now.
            
             Instead this LinkFileGenerator inspects all types in the domain, and if they could be used via reflection,
             we preserve them in all entirety.
            
             In a long run we would like to remove usage of reflection all together, and then this mechanism will be gone too.
            
             Beware, this uses "AppDomain.CurrentDomain.GetAssemblies" which returns editor assemblies,
             but not all classes are available on all platforms, most of platform specific code is wrapped into defines like
             "#if UNITY_EDITOR || UNITY_IOS || PACKAGE_DOCS_GENERATION", and when compiling for Android,
             that particular class wouldn't be available in the final executable, though our link.xml here would still specify it,
             potentially creating linker warnings that we need to later ignore.
             </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.EditorPlayerSettingHelpers.newSystemBackendsEnabled">
            <summary>
            Whether the backends for the new input system are enabled in the
            player settings for the Unity runtime.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.EditorPlayerSettingHelpers.oldSystemBackendsEnabled">
            <summary>
            Whether the backends for the old input system are enabled in the
            player settings for the Unity runtime.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionTreeView">
             <summary>
             A tree view showing action maps, actions, and bindings. This is the core piece around which the various
             pieces of action editing functionality revolve.
             </summary>
             <remarks>
             The tree view can be flexibly used to contain only parts of a specific action setup. For example,
             by only adding items for action maps (<see cref="T:UnityEngine.InputSystem.Editor.ActionMapTreeItem"/> to the tree, the tree view
             will become a flat list of action maps. Or by adding only items for actions (<see cref="T:UnityEngine.InputSystem.Editor.ActionTreeItem"/>
             and items for their bindings (<see cref="T:UnityEngine.InputSystem.Editor.BindingTreeItem"/>) to the tree, it will become an action-only
             tree view.
            
             This is used by the action asset editor to separate action maps and their actions into two separate
             tree views (the leftmost and the middle column of the editor).
            
             Each action tree comes with copy-paste and context menu support.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.BuildWithJustBindingsFromAction(UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>
            Build an action tree that shows only the bindings for the given action.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.BuildWithJustActionsAndBindingsFromMap(UnityEditor.SerializedProperty)">
            <summary>
            Build an action tree that shows only the actions and bindings for the given action map.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.BuildWithJustActionMapsFromAsset(UnityEditor.SerializedObject)">
            <summary>
            Build an action tree that contains only the action maps from the given .inputactions asset.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.GetSelectedItemsWithChildrenFilteredOut">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.Editor.InputActionTreeView.GetSelectedItems"/> but with items that are selected but are children of other items
            that also selected being filtered out.
            </summary>
            <remarks>
            This is useful for operations such as copy-paste where copy a parent will implicitly copy the child.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.CopySelectedItemsToClipboard">
            <summary>
            Copy the currently selected items to the clipboard.
            </summary>
            <seealso cref="P:UnityEditor.EditorGUIUtility.systemCopyBuffer"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.DeleteDataOfSelectedItems">
            <summary>
            Remove the data from the currently selected items from the <see cref="T:UnityEditor.SerializedObject"/>
            referenced by the tree's data.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.AddNewActionMap">
            <summary>
            Add a new action map to the toplevel <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionTreeView.AddNewAction">
            <summary>
            Add new action to the currently active action map(s).
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputControlPathDrawer">
             <summary>
             Custom property drawer for string type fields that represent input control paths.
             </summary>
             <remarks>
             To use this drawer on a property, apply <see cref="T:UnityEngine.InputSystem.Layouts.InputControlAttribute"/> on it. To constrain
             what type of control is picked, set the <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout"/> field on the
             attribute.
            
             <example>
             <code>
             // A string representing a control path. Constrain it to picking Button-type controls.
             [InputControl(layout = "Button")]
             [SerializeField] private string m_ControlPath;
             </code>
             </example>
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputControlPicker">
            <summary>
            A popup that allows picking input controls graphically.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputEditorUserSettings">
            <summary>
            Settings that are local to the current user and specific to the input system's use in the editor.
            </summary>
            <remarks>
            These settings are not stored in assets in the project along with the other input settings.
            Instead, they are serialized to JSON and stored in the project's Library/ folder.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Editor.InputEditorUserSettings.kSavePath">
            <summary>
            Where the settings are stored in the user's project.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputEditorUserSettings.addDevicesNotSupportedByProject">
             <summary>
             If this is true, then if <see cref="P:UnityEngine.InputSystem.InputSettings.supportedDevices"/> is not empty, do
             not use it to prevent native devices
             </summary>
             <remarks>
             This switch is useful to preserve use of devices in the editor regardless of whether they the
             kind of devices used by the game at runtime. For example, a game may support only gamepads but
             in the editor, the keyboard, mouse, and tablet should still be usable.
            
             This switch is enabled by default.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputEditorUserSettings.autoSaveInputActionAssets">
            <summary>
            If this is true, then instead of having an explicit save button in the .inputactions asset editor,
            any changes will be saved automatically and immediately.
            </summary>
            <remarks>
            Disabled by default.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionDrawer">
            <summary>
            Property drawer for <see cref="T:UnityEngine.InputSystem.InputAction"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionDrawerBase">
            <summary>
            Base class for property drawers that display input actions.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.ActionTreeItemBase.DeleteData">
            <summary>
            Delete serialized data for the tree item and its children.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.ActionTreeItemBase.GetDropLocation(System.Type,System.Nullable{System.Int32},UnityEditor.SerializedProperty@,System.Int32@)">
            <summary>
            Get information about where to drop an item of the given type and (optionally) the given index.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.ActionMapTreeItem">
            <summary>
            Tree view item for an action map.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.InputActionMap"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.ActionTreeItem">
            <summary>
            Tree view item for an action.
            </summary>
            <see cref="T:UnityEngine.InputSystem.InputAction"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.ActionTreeItem.AddBindingsTo(UnityEditor.IMGUI.Controls.TreeViewItem)">
            <summary>
            Add items for the bindings of just this action to the given parent tree item.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.BindingTreeItem">
            <summary>
            Tree view item for a binding.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.CompositeBindingTreeItem">
            <summary>
            Tree view item for a composite binding.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.PartOfCompositeBindingTreeItem">
            <summary>
            Tree view item for bindings that are parts of composites.
            </summary>
            <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.Lists.NameAndParameterListView">
            <summary>
            A <see cref="T:UnityEditorInternal.ReorderableList"/> to manage a set of name-and-parameter pairs and a <see cref="T:UnityEngine.InputSystem.Editor.Lists.ParameterListView"/>
            to edit the parameters of the currently selected pair.
            </summary>
            <remarks>
            Produces output that can be consumed by <see cref="M:UnityEngine.InputSystem.Utilities.NameAndParameters.ParseMultiple(System.String)"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.Lists.ProcessorsListView">
            <summary>
            A list of processors and their parameters.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.Lists.InteractionsListView">
            <summary>
            A list view of interactions and their parameters.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.Lists.ParameterListView">
             <summary>
             Inspector-like functionality for editing parameter lists as used in <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.
             </summary>
             <remarks>
             This can be used for parameters on interactions, processors, and composites.
            
             Call <see cref="M:UnityEngine.InputSystem.Editor.Lists.ParameterListView.Initialize(System.Type,UnityEngine.InputSystem.Utilities.ReadOnlyArray{UnityEngine.InputSystem.Utilities.NamedValue})"/> to set up (can be done repeatedly on the same instance). Call
             <see cref="M:UnityEngine.InputSystem.Editor.Lists.ParameterListView.OnGUI"/> to render.
            
             Custom parameter GUIs can be defined by deriving from <see cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1"/>.
             This class will automatically incorporate custom GUIs and fall back to default GUIs where no custom
             ones are defined.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.Lists.ParameterListView.onChange">
            <summary>
            Invoked whenever a parameter is changed.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.Lists.ParameterListView.GetParameters">
            <summary>
            Get the current parameter values according to the editor state.
            </summary>
            <returns>An array of parameter values.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.Lists.ParameterListView.Initialize(System.Type,UnityEngine.InputSystem.Utilities.ReadOnlyArray{UnityEngine.InputSystem.Utilities.NamedValue})">
            <summary>
            Initialize the parameter list view based on the given registered type that has parameters to edit. This can be
            things such as interactions, processors, or composites.
            </summary>
            <param name="registeredType">Type of object that the parameters will be passed to at runtime.
            We need this to be able to determine the possible set of parameters and their possible values. This
            can be a class implementing <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>, for example.</param>
            <param name="existingParameters">List of existing parameters. Can be empty.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.Lists.ParameterListView.ReadParameterValuesFrom(System.Object)">
            <summary>
            Refresh <see cref="F:UnityEngine.InputSystem.Editor.Lists.ParameterListView.m_Parameters"/> from the current parameter values in <paramref name="target"/>.
            </summary>
            <param name="target">An instance of the current type we are editing parameters on.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionPropertyDrawer">
            <summary>
            A custom property drawer for <see cref="T:UnityEngine.InputSystem.InputActionProperty"/>.
            </summary>
            <remarks>
            This is basically a toggle between the editor for <see cref="T:UnityEngine.InputSystem.InputActionReference"/>
            and the editor for <see cref="T:UnityEngine.InputSystem.InputAction"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputControlPathEditor">
            <summary>
            Custom editor UI for editing control paths.
            </summary>
            <remarks>
            This is the implementation underlying <see cref="T:UnityEngine.InputSystem.Editor.InputControlPathDrawer"/>. It is useful primarily when
            greater control is required than is offered by the <see cref="T:UnityEditor.PropertyDrawer"/> mechanism. In particular,
            it allows applying additional constraints such as requiring control paths to match ...
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputControlPathEditor.#ctor(UnityEditor.SerializedProperty,UnityEngine.InputSystem.Editor.InputControlPickerState,System.Action,UnityEngine.GUIContent)">
            <summary>
            Initialize the control path editor.
            </summary>
            <param name="pathProperty"><see cref="T:System.String"/> type property that will receive the picked input control path.</param>
            <param name="pickerState">Persistent editing state of the path editor. Used to retain state across domain reloads.</param>
            <param name="onModified">Delegate that is called when the path has been modified.</param>
            <param name="label">Optional label to display instead of display name of <paramref name="pathProperty"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathProperty"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputControlPathEditor.SetExpectedControlLayout(System.String)">
            <summary>
            Constrain the type of control layout that can be picked.
            </summary>
            <param name="expectedControlLayout">Name of the layout. This it the name as registered with
            <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>.</param>.
            <remarks>
            <example>
            <code>
            // Pick only button controls.
            editor.SetExpectedControlLayout("Button");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionImporter">
            <summary>
            Imports an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> from JSON.
            </summary>
            <remarks>
            Can generate code wrappers for the contained action sets as a convenience.
            Will not overwrite existing wrappers except if the generated code actually differs.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.EditorInputControlLayoutCache">
             <summary>
             Caches <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> instances.
             </summary>
             <remarks>
             In the editor we need access to the <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout">InputControlLayouts</see>
             registered with the system in order to facilitate various UI features. Instead of
             constructing layout instances over and over, we keep them around in here.
            
             This class is only available in the editor (when <c>UNITY_EDITOR</c> is true).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.EditorInputControlLayoutCache.allLayouts">
            <summary>
            Iterate over all control layouts in the system.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.EditorInputControlLayoutCache.allUsages">
            <summary>
            Iterate over all unique usages and their respective lists of layouts that use them.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.EditorInputControlLayoutCache.GetOptionalControlsForLayout(System.String)">
            <summary>
            List the controls that may be present on controls or devices of the given layout by virtue
            of being defined in other layouts based on it.
            </summary>
            <param name="layoutName"></param>
            <returns></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.EditorInputControlLayoutCache.OptionalControl">
             <summary>
             An optional control is a control that is not defined on a layout but which is defined
             on a derived layout.
             </summary>
             <remarks>
             An example is the "acceleration" control defined by some layouts based on <see cref="T:UnityEngine.InputSystem.Gamepad"/> (e.g.
             <see cref="!:DualShockGamepad.acceleration"/>. This means gamepads
             MAY have a gyro and thus MAY have an "acceleration" control.
            
             In bindings (<see cref="T:UnityEngine.InputSystem.InputBinding"/>), it is perfectly valid to deal with this opportunistically
             and create a binding to <c>"&lt;Gamepad&gt;/acceleration"</c> which will bind correctly IF the gamepad has
             an acceleration control but will do nothing if it doesn't.
            
             The concept of optional controls permits setting up such bindings in the UI by making controls that
             are present on more specific layouts than the one currently looked at available directly on the
             base layout.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputParameterEditor">
            <summary>
            A custom UI for editing parameter values on a <see cref="T:UnityEngine.InputSystem.InputProcessor"/>, <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>,
            or <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>.
            </summary>
            <remarks>
            When implementing a custom parameter editor, use <see cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1"/> instead.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputParameterEditor.target">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputProcessor"/>, <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, or <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>
            being edited.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputParameterEditor.OnGUI">
            <summary>
            Callback for implementing a custom UI.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1">
             <summary>
             A custom UI for editing parameter values on a <see cref="T:UnityEngine.InputSystem.InputProcessor"/>,
             <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, or <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>.
             </summary>
             <remarks>
             Custom parameter editors do not need to be registered explicitly. Say you have a custom
             <see cref="T:UnityEngine.InputSystem.InputProcessor"/> called <c>QuantizeProcessor</c>. To define a custom editor
             UI for it, simply define a new class based on <c>InputParameterEditor&lt;QuantizeProcessor&gt;</c>.
            
             <example>
             <code>
             public class QuantizeProcessorEditor : InputParameterEditor&lt;QuantizeProcessor&gt;
             {
                 // You can put initialization logic in OnEnable, if you need it.
                 public override void OnEnable()
                 {
                     // Use the 'target' property to access the QuantizeProcessor instance.
                 }
            
                 // In OnGUI, you can define custom UI elements. Use EditorGUILayout to lay
                 // out the controls.
                 public override void OnGUI()
                 {
                     // Say that QuantizeProcessor has a "stepping" property that determines
                     // the stepping distance for discrete values returned by the processor.
                     // We can expose it here as a float field. To apply the modification to
                     // processor object, we just assign the value back to the field on it.
                     target.stepping = EditorGUILayout.FloatField(
                         m_SteppingLabel, target.stepping);
                 }
            
                 private GUIContent m_SteppingLabel = new GUIContent("Stepping",
                     "Discrete stepping with which input values will be quantized.");
             }
             </code>
             </example>
            
             Note that a parameter editor takes over the entire editing UI for the object and
             not just the editing of specific parameters.
            
             The default parameter editor will derive names from the names of the respective
             fields just like the Unity inspector does. Also, it will respect tooltips applied
             to these fields with Unity's <c>TooltipAttribute</c>.
            
             So, let's say that <c>QuantizeProcessor</c> from our example was defined like
             below. In that case, the result would be equivalent to the custom parameter editor
             UI defined above.
            
             <example>
             <code>
             public class QuantizeProcessor : InputProcessor&lt;float&gt;
             {
                 [Tooltip("Discrete stepping with which input values will be quantized.")]
                 public float stepping;
            
                 public override float Process(float value, InputControl control)
                 {
                     return value - value % stepping;
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Editor.InputParameterEditor`1.target">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputProcessor"/>, <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, or <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>
            being edited.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputParameterEditor`1.OnEnable">
            <summary>
            Called after the parameter editor has been initialized.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1.CustomOrDefaultSetting">
            <summary>
            Helper for parameters that have defaults (usually from <see cref="T:UnityEngine.InputSystem.InputSettings"/>).
            </summary>
            <remarks>
            Has a bool toggle to switch between default and custom value.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputBindingPropertiesView">
            <summary>
            UI for editing properties of an <see cref="T:UnityEngine.InputSystem.InputBinding"/>. Right-most pane in action editor when
            binding is selected in middle pane.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputBindingPropertiesView.DrawUseInControlSchemes">
            <summary>
            Draw control scheme matrix that allows selecting which control schemes a particular
            binding appears in.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputActionEditorWindow">
            <summary>
            An editor window to edit .inputactions assets.
            </summary>
            <remarks>
            The .inputactions editor code does not really separate between model and view. Selection state is contained
            in the tree views and persistent across domain reloads via <see cref="T:UnityEditor.IMGUI.Controls.TreeViewState"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionEditorWindow.OnOpenAsset(System.Int32,System.Int32)">
            <summary>
            Open window if someone clicks on an .inputactions asset or an action inside of it.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionEditorWindow.OpenEditor(UnityEngine.InputSystem.InputActionAsset)">
            <summary>
            Open the specified <paramref name="asset"/> in an editor window. Used when someone hits the "Edit Asset" button in the
            importer inspector.
            </summary>
            <param name="asset">The InputActionAsset to open.</param>
            <returns>The editor window.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionEditorWindow.OnToolbarSearchChanged">
            <summary>
            Synchronize the search filter applied to the trees.
            </summary>
            <remarks>
            Note that only filter the action tree. The action map tree remains unfiltered.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputActionEditorWindow.OnActionMapTreeSelectionChanged">
            <summary>
            Synchronize the display state to the currently selected action map.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.TreeViewHelpers">
            <summary>
            Extension methods for working with tree views.
            </summary>
            <seealso cref="T:UnityEditor.IMGUI.Controls.TreeView"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.InputLayoutCodeGenerator.GenerateCodeForDeviceLayout(System.String,System.String,System.String,System.String,System.String)">
             <summary>
             Generate C# code that for the given device layout called <paramref name="layoutName"/> instantly creates
             an <see cref="T:UnityEngine.InputSystem.InputDevice"/> equivalent to what the input system would create by manually interpreting
             the given <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.
             </summary>
             <param name="layoutName">Name of the device layout to generate code for.</param>
             <param name="defines">Null/empty or a valid expression for an #if conditional compilation statement.</param>
             <param name="namePrefix">Prefix to prepend to the type name of <paramref name="layoutName"/>.</param>
             <param name="visibility">C# access modifier to use with the generated class.</param>
             <param name="namespace">Namespace to put the generated class in. If <c>null</c>, namespace of type behind <paramref name="layoutName"/> will be used.</param>
             <returns>C# source code for a precompiled version of the device layout.</returns>
             <remarks>
             The code generated by this method will be many times faster than the reflection-based <see cref="T:UnityEngine.InputSystem.InputDevice"/>
             creation normally performed by the input system. It will also create less GC heap garbage.
            
             The downside to the generated code is that the makeup of the device is hardcoded and can no longer
             be changed by altering the <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> setup of the system.
            
             Note that it is possible to use this method with layouts generated on-the-fly by layout builders such as
             the one employed for <see cref="N:UnityEngine.InputSystem.HID"/>. However, this must be done at compile/build time and can thus not
             be done for devices dynamically discovered at runtime. When this is acceptable, it is a way to dramatically
             speed up the creation of these devices.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterPrecompiledLayout``1(System.String)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.PropertiesViewBase">
            <summary>
            Base class for views that show the properties of actions or bindings.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.SerializedPropertyHelpers">
            <summary>
            Helpers for working with <see cref="T:UnityEditor.SerializedProperty"/> in the editor.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Editor.SerializedPropertyHelpers.CopyToJson(UnityEditor.SerializedProperty,System.Boolean)">
             <summary>
            
             </summary>
             <param name="property"></param>
             <returns></returns>
             <remarks>
             Converting entire objects to JSON is easy using Unity's serialization system but we cannot
             easily convert just a part of the serialized graph to JSON (or any text format for that matter)
             and then recreate the same data from text through SerializedProperties. This method helps by manually
             turning an arbitrary part of a graph into JSON which can then be used with <see cref="M:UnityEngine.InputSystem.Editor.SerializedPropertyHelpers.RestoreFromJson(UnityEditor.SerializedProperty,System.String)"/>
             to write the data back into an existing property.
            
             The primary use for this is copy-paste where serialized data needs to be stored in
             <see cref="P:UnityEditor.EditorGUIUtility.systemCopyBuffer"/>.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Editor.InputControlPickerState">
            <summary>
            Persistent state for <see cref="T:UnityEngine.InputSystem.Editor.InputControlPathEditor"/>.
            </summary>
            <remarks>
            This class encapsulates the viewing state for an input control picker.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.DisableDeviceCommand">
            <summary>
            Command to tell the runtime to no longer send events for the given device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryEnabledStateCommand">
            <summary>
            Command to find out whether a device is currently enabled or not.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryKeyboardLayoutCommand">
            <summary>
            Command to query the name of the current keyboard layout from a device.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.QueryKeyboardLayoutCommand.ReadLayoutName">
            <summary>
            Read the current keyboard layout name from <see cref="F:UnityEngine.InputSystem.LowLevel.QueryKeyboardLayoutCommand.nameBuffer"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.QueryKeyboardLayoutCommand.WriteLayoutName(System.String)">
            <summary>
            Write the given string to <see cref="F:UnityEngine.InputSystem.LowLevel.QueryKeyboardLayoutCommand.nameBuffer"/>.
            </summary>
            <param name="name">Keyboard layout name.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.EnableIMECompositionCommand">
            <summary>
            Device Command that enables IME Composition within the application.  Primarily handled by Keyboard devices.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.EnableIMECompositionCommand.imeEnabled">
            <summary>
            Set to true, and if true, Input Method Editors will be used while typing.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">
            <summary>
            Input functions that have to be performed by the underlying input runtime.
            </summary>
            <remarks>
            The runtime owns the input event queue, reports device discoveries, and runs
            periodic updates that flushes out events from the queue. Updates can also be manually
            triggered by calling <see cref="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.Update(UnityEngine.InputSystem.LowLevel.InputUpdateType)"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.AllocateDeviceId">
            <summary>
            Allocate a new unique device ID.
            </summary>
            <returns>A numeric device ID that is not <see cref="F:UnityEngine.InputSystem.InputDevice.InvalidDeviceId"/>.</returns>
            <remarks>
            Device IDs are managed by the runtime. This method allows creating devices that
            can use the same ID system but are not known to the underlying runtime.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.Update(UnityEngine.InputSystem.LowLevel.InputUpdateType)">
            <summary>
            Manually trigger an update.
            </summary>
            <param name="type">Type of update to run. If this is a combination of updates, each flag
            that is set in the mask will run a separate update.</param>
            <remarks>
            Updates will flush out events and trigger <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onBeforeUpdate"/> and <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onUpdate"/>.
            Also, newly discovered devices will be reported by an update is run.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEvent*)">
            <summary>
            Queue an input event.
            </summary>
            <remarks>
            This method has to be thread-safe.
            </remarks>
            <param name="ptr">Pointer to the event data. Uses the <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> format.</param>
            <remarks>
            Events are copied into an internal buffer. Thus the memory referenced by this method does
            not have to persist until the event is processed.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.DeviceCommand(System.Int32,UnityEngine.InputSystem.LowLevel.InputDeviceCommand*)">
            <summary>
            Perform an I/O transaction directly against a specific device.
            </summary>
            <remarks>
            This function is used to set up device-specific communication controls between
            a device and the user of a device. The interface does not dictate a set of supported
            IOCTL control codes.
            </remarks>
            <param name="deviceId">Device to send the command to.</param>
            <param name="commandPtr">Pointer to the command buffer.</param>
            <returns>Negative value on failure, >=0 on success. Meaning of return values depends on the
            command sent to the device.</returns>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onUpdate">
            <summary>
            Set delegate to be called on input updates.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onBeforeUpdate">
            <summary>
            Set delegate to be called right before <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onUpdate"/>.
            </summary>
            <remarks>
            This delegate is meant to allow events to be queued that should be processed right
            in the upcoming update.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onPlayerLoopInitialization">
            <summary>
            Set delegate to be called during player loop initialization callbacks.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onDeviceDiscovered">
             <summary>
             Set delegate to be called when a new device is discovered.
             </summary>
             <remarks>
             The runtime should delay reporting of already present devices until the delegate
             has been put in place and then call the delegate for every device already in the system.
            
             First parameter is the ID assigned to the device, second parameter is a description
             in JSON format of the device (see <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.FromJson(System.String)"/>).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onPlayerFocusChanged">
            <summary>
            Set delegate to call when the application changes focus.
            </summary>
            <seealso cref="!:Application.onFocusChanged"/>
        </member>
        <!-- Badly formed XML comment ignored for member "P:UnityEngine.InputSystem.LowLevel.IInputRuntime.isPlayerFocused" -->
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onShutdown">
            <summary>
            Set delegate to invoke when system is shutting down.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.pollingFrequency">
            <summary>
            Set the background polling frequency for devices that have to be polled.
            </summary>
            <remarks>
            The frequency is in Hz. A value of 60 means that polled devices get sampled
            60 times a second.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.currentTime">
             <summary>
             The current time on the same timeline that input events are delivered on.
             </summary>
             <remarks>
             This is used to timestamp events that are not explicitly supplied with timestamps.
            
             Time in the input system progresses linearly and in real-time and relates to when Unity was started.
             In the editor, this always corresponds to <see cref="P:UnityEditor.EditorApplication.timeSinceStartup"/>.
            
             Input time, however, is offset in relation to <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>. This is because
             in the player, <see cref="P:UnityEngine.Time.realtimeSinceStartup"/> is reset to 0 upon loading the first scene and
             in the editor, <see cref="P:UnityEngine.Time.realtimeSinceStartup"/> is reset to 0 whenever the editor enters play
             mode. As the resetting runs counter to the need of linearly progressing time for input, the input
             system will not reset time along with <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.currentTimeForFixedUpdate">
            <summary>
            The current time on the same timeline that input events are delivered on, for the current FixedUpdate.
            </summary>
            <remarks>
            This should be used inside FixedUpdate calls instead of currentTime, as FixedUpdates are simulated at times
            not matching the real time the simulation corresponds to.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.unscaledGameTime">
            <summary>
            The value of <c>Time.unscaledTime</c>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.currentTimeOffsetToRealtimeSinceStartup">
            <summary>
            The time offset that <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.currentTime"/> currently has to <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBuffers.defaultStateBuffer">
            <summary>
            Buffer that has state for each device initialized with default values.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBuffers.noiseMaskBuffer">
            <summary>
            Buffer that contains a bit mask that masks out all noisy controls.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBuffers.resetMaskBuffer">
            <summary>
            Buffer that contains a bit mask that masks out all dontReset controls.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.EnableDeviceCommand">
            <summary>
            Command to re-enable a device that has been disabled with <see cref="T:UnityEngine.InputSystem.LowLevel.DisableDeviceCommand"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand">
             <summary>
             Device command to instruct the underlying platform to pair a user account to the targeted device.
             </summary>
             <remarks>
            
             If successful, the platform should then send an <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/>
             to signal that the device configuration has been changed. In response, a <see cref="T:UnityEngine.InputSystem.LowLevel.QueryUserIdCommand"/>
             may be sent to fetch the paired user ID from the device.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand.Result.SuccessfullyInitiated">
            <summary>
            User pairing UI has been successfully opened.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand.Result.ErrorNotSupported">
            <summary>
            System does not support application-invoked user pairing.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand.Result.ErrorAlreadyInProgress">
            <summary>
            There already is a pairing operation in progress and the system does not support
            pairing multiple devices at the same time.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.MouseState">
            <summary>
            Combine a single pointer with buttons and a scroll wheel.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.MouseState.Format">
            <summary>
            Memory format identifier for MouseState.
            </summary>
            <value>Returns "MOUS".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.position">
            <summary>
            Screen-space position of the mouse in pixels.
            </summary>
            <value>Position of mouse on screen.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.position"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.delta">
            <summary>
            Screen-space motion delta of the mouse in pixels.
            </summary>
            <value>Mouse movement.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.delta"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.scroll">
            <summary>
            Scroll-wheel delta of the mouse.
            </summary>
            <value>Scroll wheel delta.</value>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.scroll"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.buttons">
            <summary>
            Button mask for which buttons on the mouse are currently pressed.
            </summary>
            <value>Button state mask.</value>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.MouseButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.leftButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.middleButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.rightButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.backButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.displayIndex">
            <summary>
            The index of the display that was moused.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseState.clickCount">
            <summary>
            Number of clicks performed in succession.
            </summary>
            <value>Successive click count.</value>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.clickCount"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.MouseState.WithButton(UnityEngine.InputSystem.LowLevel.MouseButton,System.Boolean)">
            <summary>
            Set the button mask for the given button.
            </summary>
            <param name="button">Button whose state to set.</param>
            <param name="state">Whether to set the bit on or off.</param>
            <returns>The same MouseState with the change applied.</returns>
            <seealso cref="F:UnityEngine.InputSystem.LowLevel.MouseState.buttons"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.MouseState.format">
            <summary>
            Returns <see cref="P:UnityEngine.InputSystem.LowLevel.MouseState.Format"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.MouseButton">
            <summary>
            Button indices for <see cref="F:UnityEngine.InputSystem.LowLevel.MouseState.buttons"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseButton.Left">
            <summary>
            Left mouse button.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.leftButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseButton.Right">
            <summary>
            Right mouse button.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.rightButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseButton.Middle">
            <summary>
            Middle mouse button.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.middleButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseButton.Forward">
            <summary>
            Second side button.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.MouseButton.Back">
            <summary>
            First side button.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.backButton"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEvent">
             <summary>
             A chunk of memory signaling a data transfer in the input system.
             </summary>
             <remarks>
             Input events are raw memory buffers akin to a byte array. For most uses of the input
             system, it is not necessary to be aware of the event stream in the background. Events
             are written to the internal event buffer by producers -- usually by the platform-specific
             backends sitting in the Unity runtime. Once per fixed or dynamic update (depending on
             what <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/> is set to), the input system then goes and
             flushes out the internal event buffer to process pending events.
            
             Events may signal general device-related occurrences (such as <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/>
             or <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent"/>) or they may signal input activity. The latter kind of
             event is called "state events". In particular, these events are either <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>,
             only.
            
             Events are solely focused on input. To effect output on an input device (e.g. haptics
             effects), "commands" (see <see cref="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand"/>) are used.
            
             Event processing can be listened to using <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>. This callback
             will get triggered for each event as it is processed by the input system.
            
             Note that there is no "routing" mechanism for events, i.e. no mechanism by which the input
             system looks for a handler for a specific event. Instead, events represent low-level activity
             that the input system directly integrates into the state of its <see cref="T:UnityEngine.InputSystem.InputDevice"/>
             instances.
            
             Each type of event is distinguished by its own <see cref="T:UnityEngine.InputSystem.Utilities.FourCC"/> type tag. The tag can
             be queried from the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.type"/> property.
            
             Each event will receive a unique ID when queued to the internal event buffer. The ID can
             be queried using the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId"/> property. Over the lifetime of the input system,
             no two events will receive the same ID. If you repeatedly queue an event from the same
             memory buffer, each individual call of <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/> will result in
             its own unique event ID.
            
             All events are device-specific meaning that <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> will always reference
             some device (which, however, may or may not translate to an <see cref="T:UnityEngine.InputSystem.InputDevice"/>; that
             part depends on whether the input system was able to create an <see cref="T:UnityEngine.InputSystem.InputDevice"/>
             based on the information received from the backend).
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEventPtr"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputEvent.InvalidEventId">
            <summary>
            Default, invalid value for <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId"/>. Upon being queued with
            <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>, no event will receive this ID.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.type">
             <summary>
             Type code for the event.
             </summary>
             <remarks>
             Each type of event has its own unique FourCC tag. For example, state events (see <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>)
             are tagged with "STAT". The type tag for a specific type of event can be queried from its <c>Type</c>
             property (for example, <see cref="F:UnityEngine.InputSystem.LowLevel.StateEvent.Type"/>).
            
             To check whether an event has a specific type tag, you can use <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventPtr.IsA``1"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.sizeInBytes">
             <summary>
             Total size of the event in bytes.
             </summary>
             <value>Size of the event in bytes.</value>
             <remarks>
             Events are variable-size structs. This field denotes the total size of the event
             as stored in memory. This includes the full size of this struct and not just the
             "payload" of the event.
            
             <example>
             <code>
             // Store event in private buffer:
             unsafe byte[] CopyEventData(InputEventPtr eventPtr)
             {
                 var sizeInBytes = eventPtr.sizeInBytes;
                 var buffer = new byte[sizeInBytes];
                 fixed (byte* bufferPtr = buffer)
                 {
                     UnsafeUtility.MemCpy(new IntPtr(bufferPtr), eventPtr.data, sizeInBytes);
                 }
                 return buffer;
             }
             </code>
             </example>
            
             The maximum supported size of events is <c>ushort.MaxValue</c>, i.e. events cannot
             be larger than 64KB.
             </remarks>
             <exception cref="T:System.ArgumentException"><paramref name="value"/> exceeds <c>ushort.MaxValue</c>.</exception>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId">
            <summary>
            Unique serial ID of the event.
            </summary>
            <remarks>
            Events are assigned running IDs when they are put on an event queue (see
            <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>).
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.LowLevel.InputEvent.InvalidEventId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId">
            <summary>
            ID of the device that the event is for.
            </summary>
            <remarks>
            Device IDs are allocated by the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">runtime</see>. No two devices
            will receive the same ID over an application lifecycle regardless of whether the devices
            existed at the same time or not.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDeviceById(System.Int32)"/>
            <seealso cref="F:UnityEngine.InputSystem.InputDevice.InvalidDeviceId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.time">
             <summary>
             Time that the event was generated at.
             </summary>
             <remarks>
             Times are in seconds and progress linearly in real-time. The timeline is the
             same as for <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>.
            
             Note that this implies that event times will reset in the editor every time you
             go into play mode. In effect, this can result in events appearing with negative
             timestamps (i.e. the event was generated before the current zero point for
             <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEvent.internalTime">
            <summary>
            This is the raw input timestamp without the offset to <see cref="P:UnityEngine.Time.realtimeSinceStartup"/>.
            </summary>
            <remarks>
            Internally, we always store all timestamps in "input time" which is relative to the native
            function GetTimeSinceStartup(). <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.currentTime"/> yields the current
            time on this timeline.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEvent.GetNextInMemory(UnityEngine.InputSystem.LowLevel.InputEvent*)">
            <summary>
            Get the next event after the given one.
            </summary>
            <param name="currentPtr">A valid event pointer.</param>
            <returns>Pointer to the next event in memory.</returns>
            <remarks>
            This method applies no checks and must only be called if there is an event following the
            given one. Also, the size of the given event must be 100% as the method will simply
            take the size and advance the given pointer by it (and aligning it to <see cref="F:UnityEngine.InputSystem.LowLevel.InputEvent.kAlignment"/>).
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEvent.GetNextInMemoryChecked(UnityEngine.InputSystem.LowLevel.InputEvent*,UnityEngine.InputSystem.LowLevel.InputEventBuffer@)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEvent.GetNextInMemoryChecked(UnityEngine.InputSystem.LowLevel.InputEvent*,UnityEngine.InputSystem.LowLevel.InputEventBuffer@)">
            <summary>
            Get the next event after the given one. Throw if that would point to invalid memory as indicated
            by the given memory buffer.
            </summary>
            <param name="currentPtr">A valid event pointer to an event inside <paramref name="buffer"/>.</param>
            <param name="buffer">Event buffer in which to advance to the next event.</param>
            <returns>Pointer to the next event.</returns>
            <exception cref="T:System.InvalidOperationException">There are no more events in the given buffer.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventStream">
            <summary>
            The input event stream is a combination of the input event buffer passed from native code and an
            append buffer that is owned by the managed side. Events queued during update are added to the
            append buffer. To calling code, the two buffers look like a single coherent stream of events.
            Calling Advance will first step through the events from the native side, followed by any events
            that have been appended.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventStream.numEventsRetainedInBuffer">
            <summary>
            How many events were left in the native buffer during reading.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventStream.Peek">
            <summary>
            Peeks next event in the stream
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo">
            <summary>
            Interface implemented by all input device state structs which reports the data format identifier of the state.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputStateBlock">
             <summary>
             Information about a memory region storing input state.
             </summary>
             <remarks>
             Input state is kept in raw memory blocks. All state is centrally managed by the input system;
             controls cannot keep their own independent state.
            
             Each state block is tagged with a format code indicating the storage format used for the
             memory block. This can either be one out of a set of primitive formats (such as "INT") or a custom
             format code indicating a more complex format.
            
             Memory using primitive formats can be converted to and from primitive values directly by this struct.
            
             State memory is bit-addressable, meaning that it can be offset from a byte address in bits (<see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.bitOffset"/>)
             and is sized in bits instead of bytes (<see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.sizeInBits"/>). However, in practice, bit-addressing
             memory reads and writes are only supported on the <see cref="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatBit">bitfield primitive format</see>.
            
             Input state memory is restricted to a maximum of 4GB in size. Offsets are recorded in 32 bits.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatInvalid">
            <summary>
            Format code for invalid value type
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatBit">
            <summary>
            Format code for a variable-width bitfield representing an unsigned value,
            i.e. all bits including the highest one represent the magnitude of the value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatSBit">
            <summary>
            Format code for a variable-width bitfield representing a signed value, i.e. the
            highest bit is used as a sign bit (0=unsigned, 1=signed) and the remaining bits represent
            the magnitude of the value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatInt">
            <summary>
            Format code for a 32-bit signed integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatUInt">
            <summary>
            Format code for a 32-bit unsigned integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatShort">
            <summary>
            Format code for a 16-bit signed integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatUShort">
            <summary>
            Format code for a 16-bit unsigned integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatByte">
            <summary>
            Format code for an 8-bit unsigned integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatSByte">
            <summary>
            Format code for an 8-bit signed integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatLong">
            <summary>
            Format code for a 64-bit signed integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatULong">
            <summary>
            Format code for a 64-bit unsigned integer value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatFloat">
            <summary>
            Format code for a 32-bit floating-point value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatDouble">
            <summary>
            Format code for a 64-bit floating-point value.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format">
            <summary>
            Type identifier for the memory layout used by the state.
            </summary>
            <remarks>
            Used for safety checks to make sure that when the system copies state memory, it
            copies between compatible layouts. If set to a primitive state format, also used to
            determine the size of the state block.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventBuffer">
            <summary>
            A buffer of raw memory holding a sequence of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent">input events</see>.
            </summary>
            <remarks>
            Note that event buffers are not thread-safe. It is not safe to write events to the buffer
            concurrently from multiple threads. It is, however, safe to traverse the contents of an
            existing buffer from multiple threads as long as it is not mutated at the same time.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.eventCount">
            <summary>
            Total number of events in the buffer.
            </summary>
            <value>Number of events currently in the buffer.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.sizeInBytes">
             <summary>
             Size of the used portion of the buffer in bytes. Use <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.capacityInBytes"/> to
             get the total allocated size.
             </summary>
             <value>Used size of buffer in bytes.</value>
             <remarks>
             If the size is not known, returns <see cref="F:UnityEngine.InputSystem.LowLevel.InputEventBuffer.BufferSizeUnknown"/>.
            
             Note that the size does not usually correspond to <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.eventCount"/> times <c>sizeof(InputEvent)</c>.
             as <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> instances are variable in size.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.capacityInBytes">
            <summary>
            Total size of allocated memory in bytes. This value minus <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.sizeInBytes"/> is the
            spare capacity of the buffer. Will never be less than <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.sizeInBytes"/>.
            </summary>
            <value>Size of allocated memory in bytes.</value>
            <remarks>
            A buffer's capacity determines how much event data can be written to the buffer before it has to be
            reallocated.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.data">
            <summary>
            The raw underlying memory buffer.
            </summary>
            <value>Underlying buffer of unmanaged memory.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.bufferPtr">
            <summary>
            Pointer to the first event in the buffer.
            </summary>
            <value>Pointer to first event in buffer.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.#ctor(UnityEngine.InputSystem.LowLevel.InputEvent*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct an event buffer using the given memory block containing <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s.
            </summary>
            <param name="eventPtr">A buffer containing <paramref name="eventCount"/> number of input events. The
            individual events in the buffer are variable-sized (depending on the type of each event).</param>
            <param name="eventCount">The number of events in <paramref name="eventPtr"/>. Can be zero.</param>
            <param name="sizeInBytes">Total number of bytes of event data in the memory block pointed to by <paramref name="eventPtr"/>.
            If -1 (default), the size of the actual event data in the buffer is considered unknown and has to be determined by walking
            <paramref name="eventCount"/> number of events (due to the variable size of each event).</param>
            <param name="capacityInBytes">The total size of the memory block allocated at <paramref name="eventPtr"/>. If this
            is larger than <paramref name="sizeInBytes"/>, additional events can be appended to the buffer until the capacity
            is exhausted. If this is -1 (default), the capacity is considered unknown and no additional events can be
            appended to the buffer.</param>
            <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is <c>null</c> and <paramref name="eventCount"/> is not zero
            -or- <paramref name="capacityInBytes"/> is less than <paramref name="sizeInBytes"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.#ctor(Unity.Collections.NativeArray{System.Byte},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Construct an event buffer using the array containing <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s.
            </summary>
            <param name="buffer">A native array containing <paramref name="eventCount"/> number of input events. The
            individual events in the buffer are variable-sized (depending on the type of each event).</param>
            <param name="eventCount">The number of events in <paramref name="buffer"/>. Can be zero.</param>
            <param name="sizeInBytes">Total number of bytes of event data in the <paramref cref="!:buffer"/>.
            If -1 (default), the size of the actual event data in <paramref name="buffer"/> is considered unknown and has to be determined by walking
            <paramref name="eventCount"/> number of events (due to the variable size of each event).</param>
            <param name="transferNativeArrayOwnership">If true, ownership of the <c>NativeArray</c> given by <paramref name="buffer"/> is
            transferred to the <c>InputEventBuffer</c>. Calling <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.Dispose"/> will deallocate the array. Also, <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.AllocateEvent(System.Int32,System.Int32,Unity.Collections.Allocator)"/>
            may re-allocate the array.</param>
            <exception cref="T:System.ArgumentException"><paramref name="buffer"/> has no memory allocated but <paramref name="eventCount"/> is not zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sizeInBytes"/> is greater than the total length allocated for
            <paramref name="buffer"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.AppendEvent(UnityEngine.InputSystem.LowLevel.InputEvent*,System.Int32,Unity.Collections.Allocator)">
            <summary>
            Append a new event to the end of the buffer by copying the event from <paramref name="eventPtr"/>.
            </summary>
            <param name="eventPtr">Data of the event to store in the buffer. This will be copied in full as
            per <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.sizeInBytes"/> found in the event's header.</param>
            <param name="capacityIncrementInBytes">If the buffer needs to be reallocated to accommodate the event, number of
            bytes to grow the buffer by.</param>
            <param name="allocator">If the buffer needs to be reallocated to accommodate the event, the type of allocation to
            use.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventPtr"/> is <c>null</c>.</exception>
            <remarks>
            If the buffer's current capacity (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.capacityInBytes"/>) is smaller than <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.sizeInBytes"/>
            of the given event, the buffer will be reallocated.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.AllocateEvent(System.Int32,System.Int32,Unity.Collections.Allocator)">
             <summary>
             Make space for an event of <paramref name="sizeInBytes"/> bytes and return a pointer to
             the memory for the event.
             </summary>
             <param name="sizeInBytes">Number of bytes to make available for the event including the event header (see <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>).</param>
             <param name="capacityIncrementInBytes">If the buffer needs to be reallocated to accommodate the event, number of
                 bytes to grow the buffer by.</param>
             <param name="allocator">If the buffer needs to be reallocated to accommodate the event, the type of allocation to
             use.</param>
             <returns>A pointer to a block of memory in <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventBuffer.bufferPtr"/>. Store the event data here.</returns>
             <exception cref="T:System.ArgumentException"><paramref name="sizeInBytes"/> is less than the size needed for the
             header of an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>. Will automatically be aligned to a multiple of 4.</exception>
             <remarks>
             Only <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.sizeInBytes"/> is initialized by this method. No other fields from the event's
             header are touched.
            
             The event will be appended to the buffer after the last event currently in the buffer (if any).
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.Contains(UnityEngine.InputSystem.LowLevel.InputEvent*)">
             <summary>
             Whether the given event pointer refers to data within the event buffer.
             </summary>
             <param name="eventPtr"></param>
             <returns></returns>
             <remarks>
             Note that this method does NOT check whether the given pointer points to an actual
             event in the buffer. It solely performs a pointer out-of-bounds check.
            
             Also note that if the size of the memory buffer is unknown (<see cref="F:UnityEngine.InputSystem.LowLevel.InputEventBuffer.BufferSizeUnknown"/>,
             only a lower-bounds check is performed.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventBuffer.AdvanceToNextEvent(UnityEngine.InputSystem.LowLevel.InputEvent*@,UnityEngine.InputSystem.LowLevel.InputEvent*@,System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Advance the read position to the next event in the buffer, preserving or not preserving the
            current event depending on <paramref name="leaveEventInBuffer"/>.
            </summary>
            <param name="currentReadPos"></param>
            <param name="currentWritePos"></param>
            <param name="numEventsRetainedInBuffer"></param>
            <param name="numRemainingEvents"></param>
            <param name="leaveEventInBuffer"></param>
            <remarks>
            This method MUST ONLY BE CALLED if the current event has been fully processed. If the at <paramref name="currentWritePos"/>
            is smaller than the current event, then this method will OVERWRITE parts or all of the current event.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputState">
            <summary>
            Low-level APIs for working with input state memory.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputState.currentUpdateType">
            <summary>
            The type of update that was last run or is currently being run on the input state.
            </summary>
            <remarks>
            This determines which set of buffers are currently active and thus determines which view code
            that queries input state will receive. For example, during editor updates, this will be
            <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Editor"/> and the state buffers for the editor will be active.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputState.updateCount">
            <summary>
            The number of times the current input state has been updated.
            </summary>
        </member>
        <member name="E:UnityEngine.InputSystem.LowLevel.InputState.onChange">
            <summary>
            Callback that is triggered when the state of an input device changes.
            </summary>
            <remarks>
            The first parameter is the device whose state was changed the second parameter is the event
            that triggered the change in state. Note that the latter may be <c>null</c> in case the
            change was performed directly through <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.Change(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.LowLevel.InputUpdateType)"/> rather than through an event.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputState.Change``1(UnityEngine.InputSystem.InputControl,``0,UnityEngine.InputSystem.LowLevel.InputUpdateType,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Perform one update of input state.
             </summary>
             <remarks>
             Incorporates the given state and triggers all state change monitors as needed.
            
             Note that input state changes performed with this method will not be visible on remotes as they will bypass
             event processing. It is effectively equivalent to directly writing into input state memory except that it
             also performs related tasks such as checking state change monitors, flipping buffers, or making the respective
             device current.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputState.Change``1(UnityEngine.InputSystem.InputControl,``0@,UnityEngine.InputSystem.LowLevel.InputUpdateType,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Perform one update of input state.
             </summary>
             <remarks>
             Incorporates the given state and triggers all state change monitors as needed.
            
             Note that input state changes performed with this method will not be visible on remotes as they will bypass
             event processing. It is effectively equivalent to directly writing into input state memory except that it
             also performs related tasks such as checking state change monitors, flipping buffers, or making the respective
             device current.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)">
             <summary>
             Add a monitor that gets triggered every time the state of <paramref name="control"/> changes.
             </summary>
             <param name="control">A control sitting on an <see cref="T:UnityEngine.InputSystem.InputDevice"/> that has been <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>.</param>
             <param name="monitor">Instance of the monitor that should be notified when state changes occur.</param>
             <param name="monitorIndex">Numeric index of the monitors. Monitors on a device are ordered by <em>decreasing</em> monitor index
             and invoked in that order.</param>
             <param name="groupIndex">Numeric group of the monitor. See remarks.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c> -or- <paramref name="monitor"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">The <see cref="T:UnityEngine.InputSystem.InputDevice"/> of <paramref name="control"/> has not been <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>.</exception>
             <remarks>
             All monitors on an <see cref="T:UnityEngine.InputSystem.InputDevice"/> are sorted by the complexity specified in their <paramref name="monitorIndex"/> (in decreasing order) and invoked
             in that order.
            
             Every handler gets an opportunity to set <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.handled"/> to <c>true</c>. When doing so, all remaining pending monitors
             from the same <paramref name="monitor"/> instance that have the same <paramref name="groupIndex"/> will be silenced and skipped over.
             This can be used to establish an order of event "consumption" where one change monitor may prevent another change monitor from triggering.
            
             Monitors are invoked <em>after</em> a state change has been written to the device. If, for example, a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> is
             received that sets <see cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/> to <c>0.5</c>, the value is first applied to the control and then any state
             monitors that may be listening to the change are invoked (thus getting <c>0.5</c> if calling <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>).
            
             <example>
             <code>
             class InputMonitor : IInputStateChangeMonitor
             {
                 public InputMonitor()
                 {
                     // Watch the left and right mouse button.
                     // By supplying monitor indices here, we not only receive the indices in NotifyControlStateChanged,
                     // we also create an ordering between the two monitors. The one on RMB will fire *before* the one
                     // on LMB in case there is a single event that changes both buttons.
                     InputState.AddChangeMonitor(Mouse.current.leftButton, this, monitorIndex: 1);
                     InputState.AddChangeMonitor(Mouse.current.rightButton, this, monitorIndex: 2);
                 }
            
                 public void NotifyControlStateChanged(InputControl control, double time, InputEventPtr eventPtr, long monitorIndex)
                 {
                     Debug.Log($"{control} changed");
            
                     // We can add a monitor timeout that will trigger in case the state of the
                     // given control is not changed within the given time. Let's watch the control
                     // for 2 seconds. If nothing happens, we will get a call to NotifyTimerExpired.
                     // If, however, there is a state change, the timeout is automatically removed
                     // and we will see a call to NotifyControlStateChanged instead.
                     InputState.AddChangeMonitorTimeout(control, this, 2);
                 }
            
                 public void NotifyTimerExpired(InputControl control, double time, long monitorIndex, int timerIndex)
                 {
                     Debug.Log($"{control} was not changed within 2 seconds");
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitorTimeout(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Double,System.Int64,System.Int32)">
            <summary>
            Put a timeout on a previously registered state change monitor.
            </summary>
            <param name="control"></param>
            <param name="monitor"></param>
            <param name="time"></param>
            <param name="monitorIndex"></param>
            <param name="timerIndex"></param>
            <remarks>
            If by the given <paramref name="time"/>, no state change has been registered on the control monitored
            by the given <paramref name="monitor">state change monitor</paramref>, <see cref="M:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor.NotifyTimerExpired(UnityEngine.InputSystem.InputControl,System.Double,System.Int64,System.Int32)"/>
            will be called on <paramref name="monitor"/>. If a state change happens by the given <paramref name="time"/>,
            the monitor is notified as usual and the timer is automatically removed.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.PointerState">
            <summary>
            Default state structure for pointer devices.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PointerState.position">
            <summary>
            Position of the pointer in screen space.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.ICustomDeviceReset">
            <summary>
            A device that implements its own reset logic for when <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
            is called.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.ICustomDeviceReset.Reset">
            <summary>
            Reset the current device state.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.SetIMECursorPositionCommand">
            <summary>
            Sets the position for IME dialogs.  This is in pixels, from the upper left corner going down and to the right.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.NativeInputRuntime">
            <summary>
            Implements <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime"/> based on <see cref="T:UnityEngineInternal.Input.NativeInputSystem"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.GamepadState">
            <summary>
            Default state layout for gamepads.
            </summary>
            <remarks>
            Be aware that unlike some other devices such as <see cref="T:UnityEngine.InputSystem.Mouse"/> or <see cref="T:UnityEngine.InputSystem.Touchscreen"/>,
            gamepad devices tend to have wildly varying state formats, i.e. forms in which they internally
            store their input data. In practice, even on the same platform gamepads will often store
            their data in different formats. This means that <see cref="T:UnityEngine.InputSystem.LowLevel.GamepadState"/> will often <em>not</em>
            be the format in which a particular gamepad (such as <see cref="T:UnityEngine.InputSystem.XInput.XInputController"/>,
            for example) stores its data.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Gamepad"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadState.buttons">
            <summary>
            Button bit mask.
            </summary>
            <value>Button bit mask.</value>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.GamepadButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.buttonNorth"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.buttonWest"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.leftShoulder"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.rightShoulder"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.startButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.selectButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.leftStickButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.rightStickButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadState.leftStick">
            <summary>
            Left stick position. Each axis goes from -1 to 1 with
            0 being center position.
            </summary>
            <value>Left stick position.</value>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadState.rightStick">
            <summary>
            Right stick position. Each axis from -1 to 1 with
            0 being center position.
            </summary>
            <value>Right stick position.</value>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadState.leftTrigger">
            <summary>
            Position of the left trigger. Goes from 0 (not pressed) to 1 (fully pressed).
            </summary>
            <value>Position of left trigger.</value>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadState.rightTrigger">
            <summary>
            Position of the right trigger. Goes from 0 (not pressed) to 1 (fully pressed).
            </summary>
            <value>Position of right trigger.</value>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.rightTrigger"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.GamepadState.format">
            <summary>
            State format tag for GamepadState.
            </summary>
            <value>Returns "GPAD".</value>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.GamepadState.#ctor(UnityEngine.InputSystem.LowLevel.GamepadButton[])">
            <summary>
            Create a gamepad state with the given buttons being pressed.
            </summary>
            <param name="buttons">Buttons to put into pressed state.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buttons"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.GamepadState.WithButton(UnityEngine.InputSystem.LowLevel.GamepadButton,System.Boolean)">
            <summary>
            Set the specific buttons to be pressed or unpressed.
            </summary>
            <param name="button">A gamepad button.</param>
            <param name="value">Whether to set <paramref name="button"/> to be pressed or not pressed in
            <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadState.buttons"/>.</param>
            <returns>GamepadState with a modified <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadState.buttons"/> mask.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.GamepadButton">
            <summary>
            Enum of common gamepad buttons.
            </summary>
            <remarks>
            Can be used as an array indexer on the <see cref="T:UnityEngine.InputSystem.Gamepad"/> class to get individual button controls.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.DpadUp">
            <summary>
            The up button on a gamepad's dpad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.DpadDown">
            <summary>
            The down button on a gamepad's dpad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.DpadLeft">
            <summary>
            The left button on a gamepad's dpad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.DpadRight">
            <summary>
            The right button on a gamepad's dpad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.North">
            <summary>
            The upper action button on a gamepad.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Y"/> and <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Triangle"/> which are the Xbox and PlayStation controller names for this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.East">
            <summary>
            The right action button on a gamepad.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.B"/> and <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Circle"/> which are the Xbox and PlayStation controller names for this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.South">
            <summary>
            The lower action button on a gamepad.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.A"/> and <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Cross"/> which are the Xbox and PlayStation controller names for this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.West">
            <summary>
            The left action button on a gamepad.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.X"/> and <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Square"/> which are the Xbox and PlayStation controller names for this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.LeftStick">
            <summary>
            The button pressed by pressing down the left stick on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.RightStick">
            <summary>
            The button pressed by pressing down the right stick on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.LeftShoulder">
            <summary>
            The left shoulder button on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.RightShoulder">
            <summary>
            The right shoulder button on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Start">
            <summary>
            The start button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Select">
            <summary>
            The select button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.LeftTrigger">
            <summary>
            The left trigger button on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.RightTrigger">
            <summary>
            The right trigger button on a gamepad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.X">
            <summary>
            The X button on an Xbox controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.West"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Y">
            <summary>
            The Y button on an Xbox controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.North"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.A">
            <summary>
            The A button on an Xbox controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.South"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.B">
            <summary>
            The B button on an Xbox controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.East"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Cross">
            <summary>
            The cross button on a PlayStation controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.South"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Square">
            <summary>
            The square button on a PlayStation controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.West"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Triangle">
            <summary>
            The triangle button on a PlayStation controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.North"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.GamepadButton.Circle">
            <summary>
            The circle button on a PlayStation controller.
            </summary>
            <remarks>
            Identical to <see cref="F:UnityEngine.InputSystem.LowLevel.GamepadButton.East"/>, which is the generic name of this button.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.ActionEvent">
             <summary>
             A variable-size event that captures the triggering of an action.
             </summary>
             <remarks>
             Action events capture fully processed values only.
            
             This struct is internal as the data it stores requires having access to <see cref="T:UnityEngine.InputSystem.InputActionState"/>.
             Public access is meant to go through <see cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace"/> which provides a wrapper around
             action events in the form of <see cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace.ActionEventPtr"/>.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.TouchState">
            <summary>
            State layout for a single touch.
            </summary>
            <remarks>
            This is the low-level memory representation of a single touch, i.e the
            way touches are internally transmitted and stored in the system. To update
            touches on a <see cref="T:UnityEngine.InputSystem.Touchscreen"/>, <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>s containing
            TouchStates are sent to the screen.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Controls.TouchControl"/>
            <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.TouchState.Format">
            <summary>
            Memory format tag for TouchState.
            </summary>
            <value>Returns "TOUC".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.touchId">
             <summary>
             Numeric ID of the touch.
             </summary>
             <value>Numeric ID of the touch.</value>
             <remarks>
             While a touch is ongoing, it must have a non-zero ID different from
             all other ongoing touches. Starting with <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>
             and ending with <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>,
             a touch is identified by its ID, i.e. a TouchState with the same ID
             belongs to the same touch.
            
             After a touch has ended or been canceled, an ID can be reused.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.position">
            <summary>
            Screen-space position of the touch in pixels.
            </summary>
            <value>Screen-space position of the touch.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.position"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.delta">
            <summary>
            Screen-space motion delta of the touch in pixels.
            </summary>
            <value>Screen-space movement delta.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.delta"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.pressure">
            <summary>
            Pressure-level of the touch against the touchscreen.
            </summary>
            <value>Pressure of touch.</value>
            <remarks>
            The core range for this value is [0..1] with 1 indicating maximum pressure. Note, however,
            that the actual value may go beyond 1 in practice. This is because the system will usually
            define "maximum pressure" to be less than the physical maximum limit the hardware is capable
            of reporting so that to achieve maximum pressure, one does not need to press as hard as
            possible.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.pressure"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.radius">
            <summary>
            Radius of the touch print on the surface.
            </summary>
            <value>Touch extents horizontally and vertically.</value>
            <remarks>
            The touch radius is given in screen-space pixel coordinates along X and Y centered in the middle
            of the touch. Note that not all screens and systems support radius detection on touches so this
            value may be at <c>default</c> for an otherwise perfectly valid touch.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.radius"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.phaseId">
            <summary>
            <see cref="T:UnityEngine.InputSystem.TouchPhase"/> value of the touch.
            </summary>
            <value>Current <see cref="T:UnityEngine.InputSystem.TouchPhase"/>.</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.TouchState.phase"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.displayIndex">
            <summary>
            The index of the display that was touched.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.startTime">
            <summary>
            Time that the touch was started. Relative to <c>Time.realTimeSinceStartup</c>.
            </summary>
            <value>Time that the touch was started.</value>
            <remarks>
            This is set automatically by <see cref="T:UnityEngine.InputSystem.Touchscreen"/> and does not need to be provided
            by events sent to the touchscreen.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.startTime"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchState.startPosition">
            <summary>
            The position where the touch started.
            </summary>
            <value>Screen-space start position of the touch.</value>
            <remarks>
            This is set automatically by <see cref="T:UnityEngine.InputSystem.Touchscreen"/> and does not need to be provided
            by events sent to the touchscreen.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.startPosition"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.TouchState.phase">
            <summary>
            Get or set the phase of the touch.
            </summary>
            <value>Phase of the touch.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.TouchState.isPrimaryTouch">
            <summary>
            Whether, after not having any touch contacts, this is part of the first touch contact that started.
            </summary>
            <remarks>
            This flag will be set internally by <see cref="T:UnityEngine.InputSystem.Touchscreen"/>. Generally, it is
            not necessary to set this bit manually when feeding data to Touchscreens.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.TouchState.format">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.TouchState.ToString">
            <summary>
            Return a string representation of the state useful for debugging.
            </summary>
            <returns>A string representation of the touch state.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.TouchscreenState">
             <summary>
             Default state layout for touch devices.
             </summary>
             <remarks>
             Combines multiple pointers each corresponding to a single contact.
            
             Normally, TODO (sending state events)
            
             All touches combine to quite a bit of state; ideally send delta events that update
             only specific fingers.
            
             This is NOT used by native. Instead, the native runtime always sends individual touches (<see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/>)
             and leaves state management for a touchscreen as a whole to the managed part of the system.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.TouchscreenState.Format">
            <summary>
            Memory format tag for TouchscreenState.
            </summary>
            <value>Returns "TSCR".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchscreenState.MaxTouches">
            <summary>
            Maximum number of touches that can be tracked at the same time.
            </summary>
            <value>Maximum number of concurrent touches.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TouchscreenState.primaryTouchData">
             <summary>
             Data for the touch that is deemed the "primary" touch at the moment.
             </summary>
             <remarks>
             This touch duplicates touch data from whichever touch is deemed the primary touch at the moment.
             When going from no fingers down to any finger down, the first finger to touch the screen is
             deemed the "primary touch". It stays the primary touch until released. At that point, if any other
             finger is still down, the next finger in <see cref="F:UnityEngine.InputSystem.LowLevel.TouchscreenState.touchData"/> is
            
             Having this touch be its own separate state and own separate control allows actions to track the
             state of the primary touch even if the touch moves from one finger to another in <see cref="F:UnityEngine.InputSystem.LowLevel.TouchscreenState.touchData"/>.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent">
            <summary>
            Indicates that the configuration of a device has changed.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.QueueConfigChangeEvent(UnityEngine.InputSystem.InputDevice,System.Double)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.OnConfigurationChanged"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputUpdateType">
            <summary>
            Enum of different player loop positions where the input system can invoke its update mechanism.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.None">
            <summary>
            Performs no actual update but still allows devices to reset themselves. Usually occurs immediately after domain reload.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Dynamic">
             <summary>
             Update corresponding to <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">Update</a>.
            
             Every frame has exactly one dynamic update. If not reconfigured using <see cref="N:UnityEngine.PlayerLoop"/>,
             the dynamic update happens after all the fixed updates for the frame have run (which can be
             zero or more).
            
             Input updates run before script callbacks on MonoBehaviours are fired.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Fixed">
             <summary>
             Update corresponding to <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">FixedUpdate</a>.
            
             Every frame has zero or more fixed updates. These are run before the dynamic update for the
             frame.
            
             Input updates run before script callbacks on MonoBehaviours are fired.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender">
             <summary>
             Input update that happens right before rendering.
            
             The BeforeRender update affects only devices that have before-render updates enabled. This
             has to be done through a device's layout (<see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.updateBeforeRender"/>
             and is visible through <see cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>.
            
             BeforeRender updates are useful to minimize lag of transform data that is used in rendering
             but is coming from external tracking devices. An example are HMDs. If the head transform used
             for the render camera is not synchronized right before rendering, it can result in a noticeable
             lag between head and camera movement.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Editor">
             <summary>
             Input update that happens right before <see cref="T:UnityEditor.EditorWindow"/>s are updated.
            
             This update only occurs in the editor. It is triggered right before <see cref="F:UnityEditor.EditorApplication.update"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Manual">
            <summary>
            Input updates do not happen automatically but have to be triggered manually by calling <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Default">
            <summary>
            Default update mask. Combines <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Dynamic"/>, <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Fixed"/>, and <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Editor"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommandDelegate">
            <summary>
            Delegate used by <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceCommand"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputDeviceExecuteCommandDelegate">
            <summary>
            Delegate for executing <see cref="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand"/>s inside <see cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>.
            </summary>
            <param name="command">Command to execute.</param>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputDeviceFindControlLayoutDelegate"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand">
             <summary>
             Data header for a command send to an <see cref="T:UnityEngine.InputSystem.InputDevice"/>.
             </summary>
             <remarks>
             Commands are essentially synchronously processed events send directly
             to a specific device. Their primary use is to expose device-specific
             functions without having to extend the C# API used to communicate
             between input code and backend device implementations (which may sit
             in native code).
            
             Like input events, device commands use <see cref="T:UnityEngine.InputSystem.Utilities.FourCC"/> codes
             to indicate their type.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.InputDeviceCommand.GenericFailure">
            <summary>
            Generic failure code for <see cref="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)"/> calls.
            </summary>
            <remarks>
            Any negative return value for an <see cref="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)"/> call should be considered failure.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.DeviceResetEvent">
            <summary>
            Event that causes the state of an <see cref="T:UnityEngine.InputSystem.InputDevice"/> to be reset (see <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>).
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.DeviceResetEvent.baseEvent">
            <summary>
            Common event data.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.DeviceResetEvent.hardReset">
            <summary>
            Whether to also reset <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset"/> controls.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver">
             <summary>
             Interface for devices that implement their own state update handling.
             </summary>
             <remarks>
             The input system has built-in logic to automatically handle the state buffers that store input values for devices. This
             means that if an input event containing input state is processed, its data will be copied automatically into the state
             memory for the device.
            
             However, some devices need to apply custom logic whenever new input is received. An example of this is <see cref="P:UnityEngine.InputSystem.Pointer.delta"/>
             which needs to accumulate deltas as they are received within a frame and then reset the delta at the beginning of a new frame.
            
             Also, devices like <see cref="T:UnityEngine.InputSystem.Touchscreen"/> extensively customize event handling in order to implement features such as
             tap detection and primary touch handling. This is what allows the device to receive state events in <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/>
             format even though that is not the format of the device itself (which is mainly a composite of several TouchStates).
            
             This interface allows to bypass the built-in logic and instead intercept and manually handle state updates.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputDevice"/>
             <seealso cref="T:UnityEngine.InputSystem.Pointer"/>
             <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver.OnNextUpdate">
            <summary>
            A new input update begins. This means that the current state of the device is being carried over into the next
            frame.
            </summary>
            <remarks>
            This is called without the front and back buffer for the device having been flipped. You can use <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.Change(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.LowLevel.InputUpdateType)"/>
            to write values into the device's state (e.g. to reset a given control to its default state) which will implicitly perform
            the buffer flip.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver.OnStateEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            A new state event has been received and is being processed.
            </summary>
            <param name="eventPtr">The state event. This will be either a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or a <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <remarks>
            Use <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.Change(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.LowLevel.InputUpdateType)"/> to write state updates into the device state buffers. While nothing will prevent a device
            from writing directly into the memory buffers retrieved with <see cref="P:UnityEngine.InputSystem.InputControl.currentStatePtr"/>, doing so will bypass
            the buffer flipping logic as well as change detection from change monitors (<see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor"/>; this will
            cause <see cref="T:UnityEngine.InputSystem.InputAction"/> to not work with the device) and thus lead to incorrect behavior.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver.GetStateOffsetForEvent(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr,System.UInt32@)">
             <summary>
             Compute an offset that correlates <paramref name="control"/> with the state in <paramref name="eventPtr"/>.
             </summary>
             <param name="control">Control the state of which we want to access within <paramref name="eventPtr"/>.</param>
             <param name="eventPtr">An input event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/></param>
             <param name="offset"></param>
             <returns>False if the correlation failed or true if <paramref name="offset"/> has been set and should be used
             as the offset for the state of <paramref name="control"/>.</returns>
             <remarks>
             This method will only be called if the given state event has a state format different than that of the device. In that case,
             the memory of the input state captured in the given state event cannot be trivially correlated with the control.
            
             The input system calls the method to know which offset (if any) in the device's state block to consider the state
             in <paramref name="eventPtr"/> relative to when accessing the state for <paramref name="control"/> as found in
             the event.
            
             An example of when this is called is for touch events. These are normally sent in <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/> format
             which, however, is not the state format of <see cref="T:UnityEngine.InputSystem.Touchscreen"/> (which uses a composite of several TouchStates).
             When trying to access the state in <paramref name="eventPtr"/> to, for example, read out the touch position,
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.GetStatePtrFromStateEvent(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IMECompositionEvent">
            <summary>
            A specialized event that contains the current IME Composition string, if IME is enabled and active.
            This event contains the entire current string to date, and once a new composition is submitted will send a blank string event.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IMECompositionString">
            <summary>
            A struct representing an string of characters generated by an IME for text input.
            </summary>
            <remarks>
            This is the internal representation of character strings in the event stream. It is exposed to user content through the
            <see cref="M:UnityEngine.InputSystem.LowLevel.ITextInputReceiver.OnIMECompositionChanged(UnityEngine.InputSystem.LowLevel.IMECompositionString)"/> method. It can easily be converted to a normal C# string using
             <see cref="M:UnityEngine.InputSystem.LowLevel.IMECompositionString.ToString"/>, but is exposed as the raw struct to avoid allocating memory by default.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IEventPreProcessor">
            <summary>
            Gives an opportunity for device to modify event data in-place before it gets propagated to the rest of the system.
            </summary>
            <remarks>
            If device also implements <see cref="T:UnityEngine.InputSystem.LowLevel.IEventMerger"/> it will run first, because we don't process events ahead-of-time.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IEventPreProcessor.PreProcessEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Preprocess the event. !!! Beware !!! currently events can only shrink or stay the same size.
            </summary>
            <param name="currentEventPtr">The event to preprocess.</param>
            <returns>True if event should be processed further, false if event should be skipped and ignored.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputStateHistory">
             <summary>
             Record a history of state changes applied to one or more controls.
             </summary>
             <remarks>
             This class makes it easy to track input values over time. It will automatically retain input state up to a given
             maximum history depth (<see cref="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.historyDepth"/>). When the history is full, it will start overwriting the oldest
             entry each time a new history record is received.
            
             The class listens to changes on the given controls by adding change monitors (<see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor"/>)
             to each control.
            
             <example>
             <code>
             // Track all stick controls in the system.
             var history = new InputStateHistory&lt;Vector2&gt;("*/&lt;Stick&gt;");
             foreach (var control in history.controls)
                 Debug.Log("Capturing input on " + control);
            
             // Start capturing.
             history.StartRecording();
            
             // Perform a couple artificial value changes.
             Gamepad.current.leftStick.QueueValueChange(new Vector2(0.123f, 0.234f));
             Gamepad.current.leftStick.QueueValueChange(new Vector2(0.234f, 0.345f));
             Gamepad.current.leftStick.QueueValueChange(new Vector2(0.345f, 0.456f));
             InputSystem.Update();
            
             // Every value change will be visible in the history.
             foreach (var record in history)
                 Debug.Log($"{record.control} changed value to {record.ReadValue()}");
            
             // Histories allocate unmanaged memory and must be disposed of in order to not leak.
             history.Dispose();
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.Count">
            <summary>
            Total number of state records currently captured in the history.
            </summary>
            <value>Number of records in the collection.</value>
            <remarks>
            This will always be at most <see cref="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.historyDepth"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.historyDepth"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputStateHistory.RecordStateChange(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.version">
            <summary>
            Current version stamp. Every time a record is stored in the history,
            this is incremented by one.
            </summary>
            <value>Version stamp that indicates the number of mutations.</value>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputStateHistory.RecordStateChange(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputStateHistory.historyDepth">
            <summary>
            Maximum number of records that can be recorded in the history.
            </summary>
            <value>Upper limit on number of records.</value>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is negative.</exception>
            <remarks>
            A fixed size memory block of unmanaged memory will be allocated to store history
            records. This property determines TODO
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputStateHistory`1">
            <summary>
            Records value changes of a given control over time.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.PenState">
            <summary>
            Default state layout for pen devices.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.PenState.Format">
            <summary>
            Format code for PenState.
            </summary>
            <value>Returns "PEN ".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.position">
            <summary>
            Current screen-space position of the pen.
            </summary>
            <value>Screen-space position.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.position"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.delta">
            <summary>
            Screen-space motion delta.
            </summary>
            <value>Screen-space motion delta.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.delta"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.tilt">
            <summary>
            The way the pen is leaned over perpendicular to the tablet surface. X goes [-1..1] left to right
            (with -1 and 1 being completely flush to the surface) and Y goes [-1..1] bottom to top.
            </summary>
            <value>Amount pen is leaning over.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pen.tilt"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.pressure">
            <summary>
            Pressure with which the pen is pressed against the surface. 0 is none, 1 is full pressure.
            </summary>
            <value>Pressure with which the pen is pressed.</value>
            <remarks>
            May go beyond 1 depending on pressure calibration on the system. The maximum pressure point
            may be set to less than the physical maximum pressure point determined by the hardware.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.pressure"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.twist">
            <summary>
            Amount by which the pen is rotated around itself.
            </summary>
            <value>Rotation of the pen around itself.</value>
            <seealso cref="P:UnityEngine.InputSystem.Pen.twist"/>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.PenState.buttons">
            <summary>
            Button mask for which buttons on the pen are active.
            </summary>
            <value>Bitmask for buttons on the pen.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.PenState.WithButton(UnityEngine.InputSystem.PenButton,System.Boolean)">
            <summary>
            Set or unset the bit in <see cref="F:UnityEngine.InputSystem.LowLevel.PenState.buttons"/> for the given <paramref name="button"/>.
            </summary>
            <param name="button">Button whose state to set.</param>
            <param name="state">Whether the button is on or off.</param>
            <returns>Same PenState with an updated <see cref="F:UnityEngine.InputSystem.LowLevel.PenState.buttons"/> mask.</returns>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.PenState.format">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventListener">
             <summary>
             Wraps around mechanisms for listening in on the <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> stream made
             available through <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>.
             </summary>
             <remarks>
             This struct can be used to add (<see cref="M:UnityEngine.InputSystem.LowLevel.InputEventListener.op_Addition(UnityEngine.InputSystem.LowLevel.InputEventListener,System.Action{UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice})"/>) or remove (<see cref="M:UnityEngine.InputSystem.LowLevel.InputEventListener.op_Subtraction(UnityEngine.InputSystem.LowLevel.InputEventListener,System.Action{UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice})"/>)
             callbacks directly to/from the event pipeline.
            
             Alternatively, it can be used as an <c>IObservable</c> to <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventListener.Subscribe(System.IObserver{UnityEngine.InputSystem.LowLevel.InputEventPtr})"/> observers to
             the event stream. See <see cref="T:UnityEngine.InputSystem.Utilities.Observable"/> for extension methods to set up various observer
             mechanisms.
            
             <example>
             <code>
             InputSystem.onEvent
                 .ForDevice(Mouse.current)
                 .Call(evt =>
                     {
                         foreach (var control in evt.EnumerateChangedControls())
                             Debug.Log($"Control {control} on mouse has changed value");
                     });
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventListener.op_Addition(UnityEngine.InputSystem.LowLevel.InputEventListener,System.Action{UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice})">
            <summary>
            Add a delegate to be called for each <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> that is processed by the Input System.
            </summary>
            <param name="_"></param>
            <param name="callback">A callback to call for each event.</param>
            <returns>The same listener instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent +=
                (eventPtr, device) =>
                {
                    Debug.Log($"Event for {device}");
                };
            </code>
            </example>
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventListener.op_Subtraction(UnityEngine.InputSystem.LowLevel.InputEventListener,System.Action{UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice})">
            <summary>
            Remove a delegate from <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>.
            </summary>
            <param name="_"></param>
            <param name="callback">A callback that was previously installed on <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>.</param>
            <returns>The same listener instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            InputSystem.onEvent -= myDelegate;
            </code>
            </example>
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventListener.Subscribe(System.IObserver{UnityEngine.InputSystem.LowLevel.InputEventPtr})">
             <summary>
             Subscribe an observer to the event pump.
             </summary>
             <param name="observer">Observer to be notified for each event.</param>
             <returns>A handle to dispose of the subscription.</returns>
             <remarks>
             The easiest way to subscribe is via the extension methods in <see cref="T:UnityEngine.InputSystem.Utilities.Observable"/>.
             <example>
             <code>
             // Subscribe.
             var subscription = InputSystem.onEvent.Call(e => Debug.Log("Event"));
            
             // Unsubscribe.
             subscription.Dispose();
             </code>
             </example>
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent">
            <summary>
            Partial state update for an input device.
            </summary>
            <remarks>
            Avoids having to send a full state memory snapshot when only a small
            part of the state has changed.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.ITextInputReceiver">
            <summary>
            Interface for <see cref="T:UnityEngine.InputSystem.InputDevice"/> classes that can receive text input events.
            </summary>
            <remarks>
            This interface should be implemented by devices that are meant to receive text
            input through <see cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/>.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.IMECompositionEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.ITextInputReceiver.OnTextInput(System.Char)">
             <summary>
             A single, fully-formed Unicode character has been typed on the device.
             </summary>
             <param name="character">Character that was typed. Note that in case the character is part of
             a surrogate pair, this method is called first with the high surrogate and then with the
             low surrogate character.</param>
             <remarks>
             This method is called on a device when a <see cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/> is received
             for the device. <paramref name="character"/> is the <see cref="F:UnityEngine.InputSystem.LowLevel.TextEvent.character"/>
             from the event.
            
             Note that this method will be called *twice* for a single <see cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/>
             in case the given UTF-32 (encoding in the event) needs to be represented as UTF-16
             (encoding of <c>char</c> in C#) surrogate.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.ITextInputReceiver.OnIMECompositionChanged(UnityEngine.InputSystem.LowLevel.IMECompositionString)">
            <summary>
            Called when an IME composition is in-progress or finished.
            </summary>
            <param name="compositionString">The current composition.</param>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.IMECompositionEvent"/>
            <seealso cref="E:UnityEngine.InputSystem.Keyboard.onIMECompositionChange"/>
            <remarks>
            The method will be repeatedly called with the current string while composition is in progress.
            Once composition finishes, the method will be called one more time with a blank composition
            string.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryCanRunInBackground">
            <summary>
            Queries to see if this device is able to continue to send updates and state changes when the application is not if focus.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputDeviceCommandInfo">
            <summary>
            Interface implemented by all input device command structs which reports the data format identifier of the command.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.RequestSyncCommand">
            <summary>
            A command to tell the runtime to sync the device to it's last known state.
            </summary>
            <remarks>
            This triggers an event from the underlying device that represents the whole, current state.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.RequestResetCommand"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent">
            <summary>
            Notifies about the removal of an input device.
            </summary>
            <remarks>
            Device that got removed is the one identified by <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
            of <see cref="F:UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent.baseEvent"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent.baseEvent">
            <summary>
            Common event data.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.KeyboardState">
             <summary>
             Default state layout for keyboards.
             </summary>
             <remarks>
             Can be used to update the state of <see cref="T:UnityEngine.InputSystem.Keyboard"/> devices.
            
             <example>
             <code>
             // Send input event with A key pressed on keyboard.
             InputSystem.QueueStateEvent(Keyboard.current,
                 new KeyboardState(Key.A));
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Keyboard"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.KeyboardState.Format">
            <summary>
            Memory format tag for KeybboardState.
            </summary>
            <value>Returns "KEYS".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.StateEvent">
            <summary>
            A complete state snapshot for an entire input device.
            </summary>
            <remarks>
            This is a variable-sized event.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.StateEvent.stateFormat">
            <summary>
            Type code for the state stored in the event.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.StateEvent.GetState``1">
            <summary>
            Retrieve the state stored in the event.
            </summary>
            <typeparam name="TState">Type of state expected to be stored in the event. <see cref="P:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo.format"/>
            must match <see cref="F:UnityEngine.InputSystem.LowLevel.StateEvent.stateFormat"/>.</typeparam>
            <returns>Copy of the state stored in the event.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="F:UnityEngine.InputSystem.LowLevel.StateEvent.stateFormat"/> does not match <see cref="P:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo.format"/>
            of <typeparamref name="TState"/>.</exception>
            <remarks>
            The event may contain less or more data than what is found in the struct. Only the data found in the event
            is copied. The remainder of the struct is left at default values.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.StateEvent.GetState``1(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.StateEvent.GetState``1(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Retrieve the state stored in the event.
            </summary>
            <typeparam name="TState">Type of state expected to be stored in the event. <see cref="P:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo.format"/>
            must match <see cref="F:UnityEngine.InputSystem.LowLevel.StateEvent.stateFormat"/>.</typeparam>
            <param name="ptr">A pointer to an input event. The pointer is checked for <c>null</c> and
            for whether the type of event it refers to is indeed a StateEvent.</param>
            <returns>Copy of the state stored in the event.</returns>
            <remarks>
            The event may contain less or more data than what is found in the struct. Only the data found in the event
            is copied. The remainder of the struct is left at default values.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><see cref="F:UnityEngine.InputSystem.LowLevel.StateEvent.stateFormat"/> does not match <see cref="P:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo.format"/>
            of <typeparamref name="TState"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="ptr"/> is <c>default(InputEventPtr)</c>.</exception>
            <exception cref="T:System.InvalidCastException"><paramref name="ptr"/> does not refer to a StateEvent.</exception>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.StateEvent.GetState``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.StateEvent.From(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Return the given <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventPtr"/> as a StateEvent pointer.
            </summary>
            <param name="ptr">A pointer to an input event. The pointer is checked for <c>null</c> and
            for whether the type of event it refers to is indeed a StateEvent.</param>
            <returns>Pointer <paramref name="ptr"/> converted to a StateEvent pointer.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ptr"/> is <c>default(InputEventPtr)</c>.</exception>
            <exception cref="T:System.InvalidCastException"><paramref name="ptr"/> does not refer to a StateEvent.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.StateEvent.From(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr@,Unity.Collections.Allocator)">
            <summary>
            Read the current state of <paramref name="device"/> and create a state event from it.
            </summary>
            <param name="device">Device to grab the state from. Must be a device that has been added to the system.</param>
            <param name="eventPtr">Receives a pointer to the newly created state event.</param>
            <param name="allocator">Which native allocator to allocate memory for the event from. By default, the buffer is
            allocated as temporary memory (<see cref="F:Unity.Collections.Allocator.Temp"/>. Note that this means the buffer will not be valid
            past the current frame. Use <see cref="F:Unity.Collections.Allocator.Persistent"/> if the buffer for the state event is meant to
            persist for longer.</param>
            <returns>Buffer of unmanaged memory allocated for the event.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="device"/> has not been added to the system.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.StateEvent.FromDefaultStateFor(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr@,Unity.Collections.Allocator)">
            <summary>
            Create a state event for the given <paramref name="device"/> and copy the default state of the device
            into the event.
            </summary>
            <param name="device">Device to create a state event for. Must be a device that has been added to the system.</param>
            <param name="eventPtr">Receives a pointer to the newly created state event.</param>
            <param name="allocator">Which native allocator to allocate memory for the event from. By default, the buffer is
            allocated as temporary memory (<see cref="F:Unity.Collections.Allocator.Temp"/>. Note that this means the buffer will not be valid
            past the current frame. Use <see cref="F:Unity.Collections.Allocator.Persistent"/> if the buffer for the state event is meant to
            persist for longer.</param>
            <returns>Buffer of unmanaged memory allocated for the event.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="device"/> has not been added to the system.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand">
            <summary>
            Query the ID and the name of the user paired to the device the command is sent to.
            </summary>
            <remarks>
            This command is only supported on platforms where devices can be paired to user accounts
            at the platform level. Currently this is the case for Xbox and PS4. On Switch, <see
            cref="T:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand"/> is supported but the platform does not store
            associations established between devices and users that way.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.Result.DevicePairedToUserAccount">
            <summary>
            The device is currently paired to a user account.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.Result.UserAccountSelectionInProgress">
            <summary>
            The system is currently displaying a prompt for the user to select an account to
            use the device with.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.Result.UserAccountSelectionComplete">
            <summary>
            User account selection completed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.Result.UserAccountSelectionCanceled">
            <summary>
            The system had been displaying a prompt
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.handle">
             <summary>
             Handle of the user account at the platform level.
             </summary>
             <remarks>
             Note that this is wide enough to store a pointer and does not necessarily need to be a plain integer.
             How the backend determines handles for user accounts is up to the backend.
            
             Be aware that a handle is not guaranteed to be valid beyond the current application run. For stable,
             persistent user account handles,use <see cref="P:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.id"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.id">
             <summary>
             Persistent ID of the user account the platform level.
             </summary>
             <remarks>
             This ID is guaranteed to not change between application runs, device restarts, and the user
             changing user names on the account.
            
             Use this ID to associate persistent settings with.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.QueryPairedUserAccountCommand.name">
            <summary>
            Name of the user account at the platform level.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor">
            <summary>
            Interface used to monitor input state changes.
            </summary>
            <remarks>
            Use <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/> to install a state change monitor receiving state change
            callbacks for a specific control.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor.NotifyControlStateChanged(UnityEngine.InputSystem.InputControl,System.Double,UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Int64)">
            <summary>
            Called when the state monitored by a state change monitor has been modified.
            </summary>
            <param name="control">Control that is being monitored by the state change monitor and that had its state
            memory changed.</param>
            <param name="time">Time on the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> timeline at which the control state change was received.</param>
            <param name="eventPtr">If the state change was initiated by a state event (either a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>
            or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>), this is the pointer to that event. Otherwise it is pointer that is still
            <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid"/>, but refers a "dummy" event that is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <param name="monitorIndex">Index of the monitor as passed to <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>.
            </param>
            <remarks>
            To signal that the state change has been processed by the monitor and that no other pending notifications on the
            same monitor instance should be sent, set the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.handled"/> flag to <c>true</c> on <paramref name="eventPtr"/>.
            Note, however, that aside from only silencing change monitors on the same <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor"/> instance,
            it also only silences change monitors with the same <c>groupIndex</c> value as supplied to
            <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor.NotifyTimerExpired(UnityEngine.InputSystem.InputControl,System.Double,System.Int64,System.Int32)">
            <summary>
            Called when a timeout set on a state change monitor has expired.
            </summary>
            <param name="control">Control on which the timeout expired.</param>
            <param name="time">Input time at which the timer expired. This is the time at which an <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> is being
            run whose <see cref="P:UnityEngine.InputSystem.LowLevel.InputState.currentTime"/> is past the time of expiration.</param>
            <param name="monitorIndex">Index of the monitor as given to <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>.</param>
            <param name="timerIndex">Index of the timer as given to <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitorTimeout(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Double,System.Int64,System.Int32)"/>.</param>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitorTimeout(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Double,System.Int64,System.Int32)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "T:UnityEngine.InputSystem.LowLevel.UseWindowsGamingInputCommand" -->
        <member name="T:UnityEngine.InputSystem.LowLevel.TextEvent">
            <summary>
            A single character text input event.
            </summary>
            <remarks>
            Text input does not fit the control-based input model well and thus is
            represented as its own form of input. A device that is capable of receiving
            text input (such as <see cref="T:UnityEngine.InputSystem.Keyboard"/>) receives text input events
            and should implement <see cref="T:UnityEngine.InputSystem.LowLevel.ITextInputReceiver"/> in order for the
            input system to be able to relay these events to the device.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.LowLevel.TextEvent.character">
            <summary>
            Character in UTF-32 encoding.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryKeyNameCommand">
            <summary>
            Command to query the current name of a key according to the current keyboard layout.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventTrace">
             <summary>
             InputEventTrace lets you record input events for later processing. It also has features for writing traces
             to disk, for loading them from disk, and for playing back previously recorded traces.
             </summary>
             <remarks>
             InputEventTrace lets you record input events into a buffer for either a specific device, or for all events
             received by the input system. This is useful for testing purposes or for replaying recorded input.
            
             Note that event traces <em>must</em> be disposed of (by calling <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Dispose"/>) after use or they
             will leak memory on the unmanaged (C++) memory heap.
            
             Event traces are serializable such that they can survive domain reloads in the editor.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.FrameMarkerEvent">
            <summary>
            If <see name="recordFrameMarkers"/> is enabled, an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> with this <see cref="T:UnityEngine.InputSystem.Utilities.FourCC"/>
            code in its <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.type"/> is recorded whenever the input system starts a new update, i.e.
            whenever <see cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/> is triggered. This is useful for replaying events in such
            a way that they are correctly spaced out over frames.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.deviceId">
            <summary>
            Set device to record events for. Set to <see cref="F:UnityEngine.InputSystem.InputDevice.InvalidDeviceId"/> by default
            in which case events from all devices are recorded.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.enabled">
            <summary>
            Whether the trace is currently recording input.
            </summary>
            <value>True if the trace is currently recording events.</value>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Disable"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.recordFrameMarkers">
             <summary>
             If true, input update boundaries will be recorded as events. By default, this is off.
             </summary>
             <value>Whether frame boundaries should be recorded in the trace.</value>
             <remarks>
             When recording with this off, all events are written one after the other for as long
             as the recording is active. This means that when a recording runs over multiple frames,
             it is no longer possible for the trace to tell which events happened in distinct frames.
            
             By turning this feature on, frame marker events (i.e. <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> instances
             with <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.type"/> set to <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.FrameMarkerEvent"/>) will be written
             to the trace every time an input update occurs. When playing such a trace back via <see
             cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>, events will get spaced out over frames corresponding
             to how they were spaced out when input was initially recorded.
            
             Note that having this feature enabled will fill up traces much quicker. Instead of being
             filled up only when there is input, TODO
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>
             <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.FrameMarkerEvent"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.eventCount">
            <summary>
            Total number of events currently in the trace.
            </summary>
            <value>Number of events recorded in the trace.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.totalEventSizeInBytes">
            <summary>
            The amount of memory consumed by all events combined that are currently
            stored in the trace.
            </summary>
            <value>Total size of event data currently in trace.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.allocatedSizeInBytes">
            <summary>
            Total size of memory buffer (in bytes) currently allocated.
            </summary>
            <value>Size of memory currently allocated.</value>
            <remarks>
            The buffer is allocated on the unmanaged heap.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.maxSizeInBytes">
            <summary>
            Largest size (in bytes) that the memory buffer is allowed to grow to. By default, this is
            the same as <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.allocatedSizeInBytes"/> meaning that the buffer is not allowed to grow but will
            rather wrap around when full.
            </summary>
            <value>Largest size the memory buffer is allowed to grow to.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.deviceInfos">
            <summary>
            Information about all devices for which events have been recorded in the trace.
            </summary>
            <value>Record of devices recorded in the trace.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.onFilterEvent">
             <summary>
             Optional delegate to decide whether an input should be stored in a trace. Null by default.
             </summary>
             <value>Delegate to accept or reject individual events.</value>
             <remarks>
             When this is set, the callback will be invoked on every event that would otherwise be stored
             directly in the trace. If the callback returns <c>true</c>, the trace will continue to record
             the event. If the callback returns <c>false</c>, the event will be ignored and not recorded.
            
             The callback should generally mutate the event. If you do so, note that this will impact
             event processing in general, not just recording of the event in the trace.
             </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.LowLevel.InputEventTrace.onEvent">
            <summary>
            Event that is triggered every time an event has been recorded in the trace.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.#ctor(System.Int64,System.Boolean,System.Int64,System.Int64)">
            <summary>
            Create a disabled event trace that does not perform any allocation yet. An event trace only starts consuming resources
            the first time it is enabled.
            </summary>
            <param name="bufferSizeInBytes">Size of buffer that will be allocated on first event captured by trace. Defaults to 1MB.</param>
            <param name="growBuffer">If true, the event buffer will be grown automatically when it reaches capacity, up to a maximum
            size of <paramref name="maxBufferSizeInBytes"/>. This is off by default.</param>
            <param name="maxBufferSizeInBytes">If <paramref name="growBuffer"/> is true, this is the maximum size that the buffer should
            be grown to. If the maximum size is reached, old events are being overwritten.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.String)">
            <summary>
            Write the contents of the event trace to a file.
            </summary>
            <param name="filePath">Path of the file to write.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filePath"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">A directory in <paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.UnauthorizedAccessException"><paramref name="filePath"/> cannot be accessed.</exception>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReadFrom(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.IO.Stream)">
            <summary>
            Write the contents of the event trace to the given stream.
            </summary>
            <param name="stream">Stream to write the data to. Must support seeking (i.e. <c>Stream.canSeek</c> must be true).</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> does not support seeking.</exception>
            <exception cref="T:System.IO.IOException">An error occurred trying to write to <paramref name="stream"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReadFrom(System.String)">
            <summary>
            Read the contents of an input event trace stored in the given file.
            </summary>
            <param name="filePath">Path to a file.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filePath"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">A directory in <paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.UnauthorizedAccessException"><paramref name="filePath"/> cannot be accessed.</exception>
            <remarks>
            This method replaces the contents of the trace with those read from the given file.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReadFrom(System.IO.Stream)">
            <summary>
            Read the contents of an input event trace from the given stream.
            </summary>
            <param name="stream">A stream of binary data containing a recorded event trace as written out with <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.IO.Stream)"/>.
            Must support reading.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> does not support reading.</exception>
            <exception cref="T:System.IO.IOException">An error occurred trying to read from <paramref name="stream"/>.</exception>
            <remarks>
            This method replaces the contents of the event trace with those read from the stream. It does not append
            to the existing trace.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.IO.Stream)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.LoadFrom(System.String)">
            <summary>
            Load an input event trace from the given file.
            </summary>
            <param name="filePath">Path to a file.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filePath"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">A directory in <paramref name="filePath"/> is invalid.</exception>
            <exception cref="T:System.UnauthorizedAccessException"><paramref name="filePath"/> cannot be accessed.</exception>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReadFrom(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.LoadFrom(System.IO.Stream)">
            <summary>
            Load an event trace from a previously captured event stream.
            </summary>
            <param name="stream">A stream as written by <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.IO.Stream)"/>. Must support reading.</param>
            <returns>The loaded event trace.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> is not readable.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
            <exception cref="T:System.IO.IOException">The stream cannot be loaded (e.g. wrong format; details in the exception).</exception>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.WriteTo(System.IO.Stream)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Replay">
            <summary>
            Start a replay of the events in the trace.
            </summary>
            <returns>An object that controls playback.</returns>
            <remarks>
            Calling this method implicitly turns off recording, if currently enabled (i.e. it calls <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Disable"/>),
            as replaying an event trace cannot be done while it is also concurrently modified.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Resize(System.Int64,System.Int64)">
            <summary>
            Resize the current event memory buffer to the specified size.
            </summary>
            <param name="newBufferSize">Size to allocate for the buffer.</param>
            <param name="newMaxBufferSize">Optional parameter to specifying the mark up to which the buffer is allowed to grow. By default,
            this is negative which indicates the buffer should not grow. In this case, <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.maxSizeInBytes"/> will be set
            to <paramref name="newBufferSize"/>. If this parameter is a non-negative number, it must be greater than or equal to
            <paramref name="newBufferSize"/> and will become the new value for <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.maxSizeInBytes"/>.</param>
            <returns>True if the new buffer was successfully allocated.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="newBufferSize"/> is negative.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Clear">
            <summary>
            Reset the trace. Clears all recorded events.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Enable">
            <summary>
            Start recording events.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Disable"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Disable">
            <summary>
            Stop recording events.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Enable"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.GetNextEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr@)">
             <summary>
             Based on the given event pointer, return a pointer to the next event in the trace.
             </summary>
             <param name="current">A pointer to an event in the trace or a <c>default(InputEventTrace)</c>. In the former case,
             the pointer will be updated to the next event, if there is one. In the latter case, the pointer will be updated
             to the first event in the trace, if there is one.</param>
             <returns>True if <c>current</c> has been set to the next event, false otherwise.</returns>
             <remarks>
             Event storage in memory may be circular if the event buffer is fixed in size or has reached maximum
             size and new events start overwriting old events. This method will automatically start with the first
             event when the given <paramref name="current"/> event is null. Any subsequent call with then loop over
             the remaining events until no more events are available.
            
             Note that it is VERY IMPORTANT that the buffer is not modified while iterating over events this way.
             If this is not ensured, invalid memory accesses may result.
            
             <example>
             <code>
             // Loop over all events in the InputEventTrace in the `trace` variable.
             var current = default(InputEventPtr);
             while (trace.GetNextEvent(ref current))
             {
                 Debug.Log(current);
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Dispose">
            <summary>
            Stop recording, if necessary, and clear the trace such that it released unmanaged
            memory which might be allocated.
            </summary>
            <remarks>
            For any trace that has recorded events, calling this method is crucial in order to not
            leak memory on the unmanaged (C++) memory heap.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController">
             <summary>
             Controls replaying of events recorded in an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventTrace"/>.
             </summary>
             <remarks>
             Playback can be controlled either on a per-event or a per-frame basis. Note that playing back events
             frame by frame requires frame markers to be present in the trace (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.recordFrameMarkers"/>).
            
             By default, events will be queued as is except for their timestamps which will be set to the current
             time that each event is queued at.
            
             What this means is that events replay with the same device ID (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>)
             they were captured on. If the trace is replayed in the same session that it was recorded in, this means
             that the events will replay on the same device (if it still exists).
            
             To map recorded events to a different device, you can either call <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithDeviceMappedFromTo(System.Int32,System.Int32)"/> to
             map an arbitrary device ID to a new one or call <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithAllDevicesMappedToNewInstances"/> to create
             new (temporary) devices for the duration of playback.
            
             <example>
             <code>
             var trace = new InputEventTrace(myDevice);
             trace.Enable();
            
             // ... run one or more frames ...
            
             trace.Replay().OneFrame();
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.Replay"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.trace">
            <summary>
            The event trace associated with the replay controller.
            </summary>
            <value>Trace from which events are replayed.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.finished">
            <summary>
            Whether replay has finished.
            </summary>
            <value>True if replay has finished or is not in progress.</value>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEvents"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.paused">
            <summary>
            Whether replay is paused.
            </summary>
            <value>True if replay is currently paused.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.position">
            <summary>
            Current position in the event stream.
            </summary>
            <value>Index of current event in trace.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.createdDevices">
             <summary>
             List of devices created by the replay controller.
             </summary>
             <value>Devices created by the replay controller.</value>
             <remarks>
             By default, a replay controller will queue events as is, i.e. with <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> of
             each event left as is. This means that the events will target existing devices (if any) that have the
             respective ID.
            
             Using <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithAllDevicesMappedToNewInstances"/>, a replay controller can be instructed to create
             new, temporary devices instead for each unique <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> encountered in the stream.
             All devices created by the controller this way will be put on this list.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithAllDevicesMappedToNewInstances"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.Dispose">
            <summary>
            Removes devices created by the controller when using <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithAllDevicesMappedToNewInstances"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithDeviceMappedFromTo(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.InputDevice)">
            <summary>
            Replay events recorded from <paramref name="recordedDevice"/> on device <paramref name="playbackDevice"/>.
            </summary>
            <param name="recordedDevice">Device events have been recorded from.</param>
            <param name="playbackDevice">Device events should be played back on.</param>
            <returns>The same ReplayController instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="recordedDevice"/> is <c>null</c> -or-
            <paramref name="playbackDevice"/> is <c>null</c>.</exception>
            <remarks>
            This method causes all events with a device ID (see <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> and <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>)
            corresponding to the one of <paramref cref="!:recordedDevice"/> to be queued with the device ID of <paramref name="playbackDevice"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithDeviceMappedFromTo(System.Int32,System.Int32)">
            <summary>
            Replace <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> values of events that are equal to <paramref name="recordedDeviceId"/>
            with device ID <paramref name="playbackDeviceId"/>.
            </summary>
            <param name="recordedDeviceId"><see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> to map from.</param>
            <param name="playbackDeviceId"><see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> to map to.</param>
            <returns>The same ReplayController instance.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.WithAllDevicesMappedToNewInstances">
            <summary>
            For all events, create new devices to replay the events on instead of replaying the events on existing devices.
            </summary>
            <returns>The same ReplayController instance.</returns>
            <remarks>
            Note that devices created by the <c>ReplayController</c> will stick around for as long as the replay
            controller is not disposed of. This means that multiple successive replays using the same <c>ReplayController</c>
            will replay the events on the same devices that were created on the first replay. It also means that in order
            to do away with the created devices, it is necessary to call <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.Dispose"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.Dispose"/>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.createdDevices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.OnFinished(System.Action)">
            <summary>
            Invoke the given callback when playback finishes.
            </summary>
            <param name="action">A callback to invoke when playback finishes.</param>
            <returns>The same ReplayController instance.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.OnEvent(System.Action{UnityEngine.InputSystem.LowLevel.InputEventPtr})">
            <summary>
            Invoke the given callback when an event is about to be queued.
            </summary>
            <param name="action">A callback to invoke when an event is getting queued.</param>
            <returns>The same ReplayController instance.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayOneEvent">
             <summary>
             Takes the next event from the trace and queues it.
             </summary>
             <returns>The same ReplayController instance.</returns>
             <exception cref="T:System.InvalidOperationException">There are no more events in the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.trace"/> -or- the only
             events left are frame marker events (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.FrameMarkerEvent"/>).</exception>
             <remarks>
             This method takes the next event at the current read position and queues it using <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>.
             The read position is advanced past the taken event.
            
             Frame marker events (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.FrameMarkerEvent"/>) are skipped.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.Rewind">
            <summary>
            Rewind playback all the way to the beginning of the event trace.
            </summary>
            <returns>The same ReplayController instance.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne">
             <summary>
             Replay all frames one by one from the current playback position.
             </summary>
             <returns>The same ReplayController instance.</returns>
             <remarks>
             Events will be fed to the input system from within <see cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>. Each update
             will receive events for one frame.
            
             Note that for this method to correctly space out events and distribute them to frames, frame markers
             must be present in the trace (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.recordFrameMarkers"/>). If not present, all events will
             be fed into first frame.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.recordFrameMarkers"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEvents"/>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEventsAccordingToTimestamps"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEvents">
            <summary>
            Go through all remaining event in the trace starting at the current read position and queue them using
            <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>.
            </summary>
            <returns>The same ReplayController instance.</returns>
            <remarks>
            Unlike methods such as <see cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>, this method immediately queues events and immediately
            completes playback upon return from the method.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEventsAccordingToTimestamps"/>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEventsAccordingToTimestamps">
             <summary>
             Replay events in a way that tries to preserve the original timing sequence.
             </summary>
             <returns>The same ReplayController instance.</returns>
             <remarks>
             This method will take the current time as the starting time to which make all events
             relative to. Based on this time, it will try to correlate the original event timing
             with the timing of input updates as they happen. When successful, this will compensate
             for differences in frame timings compared to when input was recorded and instead queue
             input in frames that are closer to the original timing.
            
             Note that this method will perform one initial scan of the trace to determine a linear
             ordering of the events by time (the input system does not require any such ordering on the
             events in its queue and thus events in a trace, especially if there are multiple devices
             involved, may be out of order).
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllFramesOneByOne"/>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.InputEventTrace.ReplayController.PlayAllEvents"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventTrace.DeviceInfo">
            <summary>
            Information about a device whose input has been captured in an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventTrace"/>
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.deviceInfos"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.DeviceInfo.deviceId">
            <summary>
            Id of the device as stored in the events for the device.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.DeviceInfo.layout">
            <summary>
            Name of the layout used by the device.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.layout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.DeviceInfo.stateFormat">
            <summary>
            Tag for the format in which state for the device is stored.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventTrace.DeviceInfo.stateSizeInBytes">
            <summary>
            Size of a full state snapshot of the device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputEventTypeInfo">
            <summary>
            Interface implemented by all input event structs which reports the data format identifier of the command.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputMetrics">
            <summary>
            Provides information on the level of throughput going through the system.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.metrics"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.maxNumDevices">
            <summary>
            Maximum number of devices that were concurrently added to the system.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.currentNumDevices">
            <summary>
            Number of devices currently added to the system.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.maxStateSizeInBytes">
            <summary>
            The largest the combined state memory for all devices got.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.currentStateSizeInBytes">
            <summary>
            Total size of the combined state memory for all current devices.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.currentControlCount">
            <summary>
            Total number of <see cref="T:UnityEngine.InputSystem.InputControl"/>s currently alive in
            devices in the system.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.currentLayoutCount">
            <summary>
            Total number of currently registered layouts.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalEventBytes">
            <summary>
            Total number of bytes of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s consumed so far.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalEventCount">
            <summary>
            Total number of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s consumed so far.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalUpdateCount">
            <summary>
            Total number of input system updates run so far.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalEventProcessingTime">
            <summary>
            Total time in seconds spent processing <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s so far.
            </summary>
            <remarks>
            Event processing usually amounts for the majority of time spent in <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
            but not necessarily for all of it.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalEventLagTime">
            <summary>
            Total accumulated time that has passed between when events were generated (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>)
            compared to when they were processed.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.averageEventBytesPerFrame">
            <summary>
            Average size of the event buffer received on every <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.averageProcessingTimePerEvent">
            <summary>
            Average time in seconds spend on processing each individual <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputMetrics.averageLagTimePerEvent">
            <summary>
            Average time it takes from when an event is generated to when it is processed.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputMetrics.totalEventLagTime"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.QueryDimensionsCommand">
            <summary>
            Query dimensions of a device.
            </summary>
            <remarks>
            This is usually used to query screen dimensions from pointer devices.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.IInputUpdateCallbackReceiver">
            <summary>
            Interface to allow custom input devices to receive callbacks when the input system is updated.
            </summary>
            <remarks>
            If an <see cref="T:UnityEngine.InputSystem.InputDevice"/> class implements the IInputUpdateCallbackReceiver interface, any instance of the
            InputDevice will have it's <see cref="M:UnityEngine.InputSystem.LowLevel.IInputUpdateCallbackReceiver.OnUpdate"/> method called whenever the input system updates. This can be used
            to implement custom state update logic for virtual input devices which track some state in the project.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.RequestResetCommand">
            <summary>
            A command to tell the runtime to reset the device to it's default state.
            </summary>
            <remarks>
            This triggers an event being sent from the device that represents an empty, or untouched device.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.RequestSyncCommand"/>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.SetSamplingFrequencyCommand">
            <summary>
            For a device that is sampled periodically, set the frequency at which the device
            is sampled.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.LowLevel.InputEventPtr">
            <summary>
            Pointer to an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>. Makes it easier to work with InputEvents and hides
            the unsafe operations necessary to work with them.
            </summary>
            <remarks>
            Note that event pointers generally refer to event buffers that are continually reused. This means
            that event pointers should not be held on to. Instead, to hold onto event data, manually copy
            an event to a buffer.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventPtr.#ctor(UnityEngine.InputSystem.LowLevel.InputEvent*)">
            <summary>
            Initialize the pointer to refer to the given event.
            </summary>
            <param name="eventPtr">Pointer to an event. Can be <c>null</c>.</param>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid">
            <summary>
            Whether the pointer is not <c>null</c>.
            </summary>
            <value>True if the struct refers to an event.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.handled">
             <summary>
             Whether the event is considered "handled" and should not be processed further.
             </summary>
             <remarks>
             This is used in two ways. Setting it from inside <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/> will
             cause the event to not be processed further. If it is a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or
             <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>, the <see cref="T:UnityEngine.InputSystem.InputDevice"/> targeted by the event will
             not receive the state change.
            
             Setting this flag from inside a state change monitor (see <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>)
             will prevent other monitors on the same <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor"/> not receiving the state change.
             </remarks>
             <exception cref="T:System.InvalidOperationException">The event pointer instance is not <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.LowLevel.InputEventPtr.ToPointer">
            <summary>
            Return the plain pointer wrapped around by the struct.
            </summary>
            <returns>A plain pointer. Can be <c>null</c>.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.TouchControl">
            <summary>
            A control representing a touch contact.
            </summary>
            <remarks>
            Note that unlike most other control types, <c>TouchControls</c> do not have
            a flexible memory layout. They are hardwired to <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/> and
            will not work correctly with a different memory layouts. Additional fields may
            be appended to the struct but what's there in the struct has to be located
            at exactly those memory addresses.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.press">
            <summary>
            Button that indicates whether there is currently an ongoing touch
            contact on the control. When touch is ongoing, button will be 1,
            otherwise button will be 0.
            </summary>
            <value>Control representing an ongoing touch contact.</value>
            <remarks>
            This control simply monitors <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/> and will read as 1 whenever
            the phase is <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>, <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>,
            or <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.displayIndex">
            <summary>
            Gets the index of the display that was touched.
            <see href="https://docs.unity3d.com/ScriptReference/Display.html"/>
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.touchId">
             <summary>
             The ID of the touch contact as reported by the underlying system.
             </summary>
             <value>Control reading out the ID of the touch.</value>
             <remarks>
             Each touch contact that is made with the screen receives its own unique ID which is
             normally assigned by the underlying platform.
            
             Note a platform may reuse touch IDs after their respective touches have finished.
             This means that the guarantee of uniqueness is only made with respect to currently
             ongoing touches.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.LowLevel.TouchState.touchId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.position">
            <summary>
            Absolute screen-space position on the touch surface.
            </summary>
            <value>Control representing the screen-space of the touch.</value>
            <seealso cref="F:UnityEngine.InputSystem.LowLevel.TouchState.position"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.delta">
             <summary>
             Screen-space motion delta of the touch.
             </summary>
             <value>Control representing the screen-space motion delta of the touch.</value>
             <remarks>
             This is either supplied directly by the underlying platform or computed on the
             fly by <see cref="T:UnityEngine.InputSystem.Touchscreen"/> from the last known position of the touch.
            
             Note that deltas have behaviors attached to them different from most other
             controls. See <see cref="P:UnityEngine.InputSystem.Pointer.delta"/> for details.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.LowLevel.TouchState.delta"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.pressure">
             <summary>
             Normalized pressure of the touch against the touch surface.
             </summary>
             <value>Control representing the pressure level of the touch.</value>
             <remarks>
             Not all touchscreens are pressure-sensitive. If unsupported, this control will remain
             at default value.
            
             In general, touch pressure is supported on mobile platforms only.
            
             Note that it is possible for the value to go above 1 even though it is considered normalized. The reason is
             that calibration on the system can put the maximum pressure point below the physically supported maximum value.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.LowLevel.TouchState.pressure"/>
             <seealso cref="P:UnityEngine.InputSystem.Pointer.pressure"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.radius">
            <summary>
            Screen-space radius of the touch.
            </summary>
            <value>Control representing the horizontal and vertical extents of the touch contact.</value>
            <remarks>
            If supported by the device, this reports the size of the touch contact based on its
            <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.position"/> center point. If not supported, this will be <c>default(Vector2)</c>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Pointer.radius"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.phase">
            <summary>
            Current phase of the touch.
            </summary>
            <value>Control representing the current phase of the touch.</value>
            <remarks>
            This will be <see cref="F:UnityEngine.InputSystem.TouchPhase.None"/> if no touch has been registered on the control
            yet or if the control has been reset to its default state.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.isInProgress"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.indirectTouch">
            <summary>
            Whether the touch comes from a source other than direct contact with the touch surface.
            </summary>
            <value>Control indicating whether the touch was generated indirectly.</value>
            <remarks>
            Indirect touches can be generated with a stylus, for example.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.tap">
             <summary>
             Whether the touch has performed a tap.
             </summary>
             <value>Control that indicates whether the touch has tapped the screen.</value>
             <remarks>
             A tap is defined as a touch that begins and ends within <see cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/> and
             stays within <see cref="P:UnityEngine.InputSystem.InputSettings.tapRadius"/> of its <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.startPosition"/>. If this
             is the case for a touch, this button is set to 1 at the time the touch goes to <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
             <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/>.
            
             The button resets to 0 only when another touch is started on the control or when the control
             is reset.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.tapCount"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.tapCount">
            <summary>
            Number of times that the touch has been tapped in succession.
            </summary>
            <value>Control that indicates how many taps have been performed one after the other.</value>
            <remarks>
            Successive taps have to come within <see cref="P:UnityEngine.InputSystem.InputSettings.multiTapDelayTime"/> for them
            to increase the tap count. I.e. if a new tap finishes within that time after <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.startTime"/>
            of the previous touch, the tap count is increased by one. If more than <see cref="P:UnityEngine.InputSystem.InputSettings.multiTapDelayTime"/>
            passes after a tap with no successive tap, the tap count is reset to zero.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.startTime">
            <summary>
            Time in seconds on the same timeline as <c>Time.realTimeSinceStartup</c> when the touch began.
            </summary>
            <value>Control representing the start time of the touch.</value>
            <remarks>
            This is the value of <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> when the touch starts with
            <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/> <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.startPosition">
            <summary>
            Screen-space position where the touch started.
            </summary>
            <value>Control representing the start position of the touch.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.position"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.TouchControl.isInProgress">
            <summary>
            Whether a touch on the control is currently is progress.
            </summary>
            <value>If true, a touch is in progress, i.e. has a <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/> of
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>, <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>, or <see
            cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchControl.#ctor">
            <summary>
            Default-initialize the touch control.
            </summary>
            <remarks>
            Sets the <see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/> to <c>"TOUC"</c>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchControl.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchControl.WriteValueIntoState(UnityEngine.InputSystem.LowLevel.TouchState,System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.QuaternionControl">
            <summary>
            A generic input control reading quaternion (rotation) values.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.QuaternionControl.x">
            <summary>
            The X component of the quaternion.
            </summary>
            <value>Control representing the X component.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.QuaternionControl.y">
            <summary>
            The Y component of the quaternion.
            </summary>
            <value>Control representing the Y component.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.QuaternionControl.z">
            <summary>
            The Z component of the quaternion.
            </summary>
            <value>Control representing the Z component.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.QuaternionControl.w">
            <summary>
            The W component of the quaternion.
            </summary>
            <value>Control representing the W component.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.QuaternionControl.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.QuaternionControl.FinishSetup">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.QuaternionControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.QuaternionControl.WriteValueIntoState(UnityEngine.Quaternion,System.Void*)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.DoubleControl">
            <summary>
            A control reading a <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.DoubleControl.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.DoubleControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.DoubleControl.WriteValueIntoState(System.Double,System.Void*)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.AnyKeyControl">
            <summary>
            A control that simply checks the entire state it's been assigned
            for whether there's any non-zero bytes. If there are, the control
            returns 1.0; otherwise it returns 0.0.
            </summary>
            <remarks>
            This control is used by <see cref="P:UnityEngine.InputSystem.Keyboard.anyKey"/> to create a button
            that is toggled on as long as any of the keys on the keyboard is pressed.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Keyboard.anyKey"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AnyKeyControl.#ctor">
            <summary>
            Default initialization. Sets state size to 1 bit and format to
            <see cref="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatBit"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AnyKeyControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.Vector2Control">
             <summary>
             A floating-point 2D vector control composed of two <see cref="T:UnityEngine.InputSystem.Controls.AxisControl"/>s.
             </summary>
             <remarks>
             An example is <see cref="P:UnityEngine.InputSystem.Pointer.position"/>.
            
             <example>
             <code>
             Debug.Log(string.Format("Mouse position x={0} y={1}",
                 Mouse.current.position.x.ReadValue(),
                 Mouse.current.position.y.ReadValue()));
             </code>
             </example>
            
             Normalization is not implied. The X and Y coordinates can be in any range or units.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.Vector2Control.x">
            <summary>
            Horizontal position of the control.
            </summary>
            <value>Control representing horizontal motion input.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.Vector2Control.y">
            <summary>
            Vertical position of the control.
            </summary>
            <value>Control representing vertical motion input.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.Vector2Control.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.Vector2Control.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.Vector2Control.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.Vector2Control.WriteValueIntoState(UnityEngine.Vector2,System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.Vector2Control.EvaluateMagnitude(System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.ButtonControl">
            <summary>
            An axis that has a trigger point beyond which it is considered to be pressed.
            </summary>
            <remarks>
            By default stored as a single bit. In that format, buttons will only yield 0
            and 1 as values. However, buttons return are <see cref="T:UnityEngine.InputSystem.Controls.AxisControl"/>s and
            yield full floating-point values and may thus have a range of values. See
            <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/> for how button presses on such buttons are handled.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint">
             <summary>
             The minimum value the button has to reach for it to be considered pressed.
             </summary>
             <value>Button press threshold.</value>
             <remarks>
             The button is considered pressed, if it has a value equal to or greater than
             this value.
            
             By default, this property is set to -1. If the value of the property is negative,
             <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> is used.
            
             The value can be configured as a parameter in a layout.
            
             <example>
             <code>
             public class MyDevice : InputDevice
             {
                 [InputControl(parameters = "pressPoint=0.234")]
                 public ButtonControl button { get; private set; }
            
                 //...
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
             <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.pressPointOrDefault"/>
             <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.ButtonControl.pressPointOrDefault">
            <summary>
            Return <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/> if set, otherwise return <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            </summary>
            <value>Effective value to use for press point thresholds.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.ButtonControl.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
            <remarks>
            The default format for the control is <see cref="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatBit"/>.
            The control's minimum value is set to 0 and the maximum value to 1.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.ButtonControl.IsValueConsideredPressed(System.Single)">
            <summary>
            Whether the given value would be considered pressed for this button.
            </summary>
            <param name="value">Value for the button.</param>
            <returns>True if <paramref name="value"/> crosses the threshold to be considered pressed.</returns>
            <seealso cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed">
            <summary>
            Whether the button is currently pressed.
            </summary>
            <value>True if button is currently pressed.</value>
            <remarks>
            A button is considered press if it's value is equal to or greater
            than its button press threshold (<see cref="P:UnityEngine.InputSystem.Controls.ButtonControl.pressPointOrDefault"/>).
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.onAnyButtonPress"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.DiscreteButtonControl">
             <summary>
             A button that is considered pressed if the underlying state has a value in the specific range.
             </summary>
             <remarks>
             This control is most useful for handling HID-style hat switches. Unlike <see cref="T:UnityEngine.InputSystem.Controls.DpadControl"/>,
             which by default is stored as a bitfield of four bits that each represent a direction on the pad,
             these hat switches enumerate the possible directions that the switch can be moved in. For example,
             the value 1 could indicate that the switch is moved to the left whereas 3 could indicate it is
             moved up.
            
             <example>
             <code>
             [StructLayout(LayoutKind.Explicit, Size = 32)]
             internal struct DualShock4HIDInputReport : IInputStateTypeInfo
             {
                 [FieldOffset(0)] public byte reportId;
            
                 [InputControl(name = "dpad", format = "BIT", layout = "Dpad", sizeInBits = 4, defaultState = 8)]
                 [InputControl(name = "dpad/up", format = "BIT", layout = "DiscreteButton", parameters = "minValue=7,maxValue=1,nullValue=8,wrapAtValue=7", bit = 0, sizeInBits = 4)]
                 [InputControl(name = "dpad/right", format = "BIT", layout = "DiscreteButton", parameters = "minValue=1,maxValue=3", bit = 0, sizeInBits = 4)]
                 [InputControl(name = "dpad/down", format = "BIT", layout = "DiscreteButton", parameters = "minValue=3,maxValue=5", bit = 0, sizeInBits = 4)]
                 [InputControl(name = "dpad/left", format = "BIT", layout = "DiscreteButton", parameters = "minValue=5, maxValue=7", bit = 0, sizeInBits = 4)]
                 [FieldOffset(5)] public byte buttons1;
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.minValue">
             <summary>
             Value (inclusive) at which to start considering the button to be pressed.
             </summary>
             <remarks>
             <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.minValue"/> is allowed to be larger than <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.maxValue"/>. This indicates
             a setup where the value wraps around beyond <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.minValue"/>, skips <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue"/>,
             and then goes all the way up to <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.maxValue"/>.
            
             For example, if the underlying state represents a circular D-pad and enumerates its
             9 possible positions (including null state) going clock-wise from 0 to 8 and with 1
             indicating that the D-pad is pressed to the left, then 1, 2, and 8 would indicate
             that the "left" button is held on the D-pad. To set this up, set <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.minValue"/>
             to 8, <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.maxValue"/> to 2, and <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue"/> to 0 (the default).
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.maxValue">
            <summary>
            Value (inclusive) beyond which to stop considering the button to be pressed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.wrapAtValue">
            <summary>
            Value (inclusive) at which the values cut off and wrap back around. Considered to not be set if equal to <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue"/>.
            </summary>
            <remarks>
            This is useful if, for example, an enumeration has more bits than are used for "on" states of controls. For example,
            a bitfield of 4 bits where values 1-7 (i.e. 0001 to 0111) indicate "on" states of controls and value 8 indicating an
            "off" state. In that case, set <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue"/> to 8 and <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.wrapAtValue"/> to 7.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue">
            <summary>
            Value at which the button is considered to not be pressed. Usually zero. Some devices, however,
            use non-zero default states.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.writeMode">
            <summary>
            Determines the behavior of <see cref="M:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteValueIntoState(System.Single,System.Void*)"/>. By default, attempting to write a <see cref="T:UnityEngine.InputSystem.Controls.DiscreteButtonControl"/>
            will result in a <c>NotSupportedException</c>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteMode">
            <summary>
            How <see cref="M:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteValueIntoState(System.Single,System.Void*)"/> should behave.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteMode.WriteDisabled">
            <summary>
            <see cref="M:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteValueIntoState(System.Single,System.Void*)"/> will throw <c>NotSupportedException</c>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.WriteMode.WriteNullAndMaxValue">
            <summary>
            Write <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.nullValue"/> for when the button is considered not pressed and
            write <see cref="F:UnityEngine.InputSystem.Controls.DiscreteButtonControl.maxValue"/> for when the button is considered pressed.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.Vector3Control">
            <summary>
            A floating-point 3D vector control composed of three <see cref="T:UnityEngine.InputSystem.Controls.AxisControl">AxisControls</see>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.IntegerControl">
            <summary>
            A generic input control reading integer values.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.IntegerControl.#ctor">
            <summary>
            Default-initialize an integer control.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.IntegerControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.IntegerControl.WriteValueIntoState(System.Int32,System.Void*)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.KeyControl">
             <summary>
             A key on a <see cref="T:UnityEngine.InputSystem.Keyboard"/>.
             </summary>
             <remarks>
             This is an extended button control which adds various features to account for the fact that keys
             have symbols associated with them which may change depending on keyboard layout as well as in combination
             with other keys.
            
             Note that there is no text input associated with individual keys as text composition is highly
             layout specific and does not need to be key-by-key. For general text input, see <see cref="E:UnityEngine.InputSystem.Keyboard.onTextInput"/>.
             To find the text displayed on a key, use <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.KeyControl.keyCode">
            <summary>
            The code used in Unity to identify the key.
            </summary>
            <remarks>
            This property must be initialized by <see cref="M:UnityEngine.InputSystem.InputControl.FinishSetup"/> of
            the device owning the control.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.KeyControl.scanCode">
            <summary>
            The code that the underlying platform uses to identify the key.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.StickControl">
             <summary>
             A two-axis thumbstick control that can act as both a vector and a four-way dpad.
             </summary>
             <remarks>
             Stick controls are used to represent the thumbsticks on gamepads (see <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/>
             and <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>) as well as the main stick control of joysticks (see
             <see cref="P:UnityEngine.InputSystem.Joystick.stick"/>).
            
             Essentially, a stick is an extended <c>Vector2</c> control that can function either
             as a combined 2D vector, as independent vertical and horizontal axes, or as four
             individual, directional buttons. The following example demonstrates this based on the
             gamepad's left stick.
            
             <example>
             <code>
             // Read stick as a combined 2D vector.
             Gamepad.current.leftStick.ReadValue();
            
             // Read X and Y axis of stick individually.
             Gamepad.current.leftStick.x.ReadValue();
             Gamepad.current.leftStick.y.ReadValue();
            
             // Read the stick as four individual directional buttons.
             Gamepad.current.leftStick.up.ReadValue();
             Gamepad.current.leftStick.down.ReadValue();
             Gamepad.current.leftStick.left.ReadValue();
             Gamepad.current.leftStick.right.ReadValue();
             </code>
             </example>
            
             In terms of memory, a stick controls is still just from one value for the X axis
             and one value for the Y axis.
            
             Unlike dpads (see <see cref="T:UnityEngine.InputSystem.Controls.DpadControl"/>), sticks will usually have deadzone processors
             (see <see cref="T:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor"/>) applied to them to get rid of noise around the
             resting point of the stick. The X and Y axis also have deadzones applied to them by
             default (<see cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>). Note, however, that the deadzoning of
             individual axes is different from the deadzoning applied to the stick as a whole and
             thus does not have to result in exactly the same values. Deadzoning of individual axes
             is linear (i.e. the result is simply clamped and normalized back into [0..1] range) whereas
             the deadzoning of sticks is radial (i.e. the length of the vector is taken into account
             which means that <em>both</em> the X and Y axis contribute).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.StickControl.up">
            <summary>
            A synthetic button representing the upper half of the stick's Y axis, i.e. the 0 to 1 range.
            </summary>
            <value>Control representing the stick's upper half Y axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.StickControl.down">
            <summary>
            A synthetic button representing the lower half of the stick's Y axis, i.e. the -1 to 0 range (inverted).
            </summary>
            <value>Control representing the stick's lower half Y axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.StickControl.left">
            <summary>
            A synthetic button representing the left half of the stick's X axis, i.e. the -1 to 0 range (inverted).
            </summary>
            <value>Control representing the stick's left half X axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.StickControl.right">
            <summary>
            A synthetic button representing the right half of the stick's X axis, i.e. the 0 to 1 range.
            </summary>
            <value>Control representing the stick's right half X axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.DpadControl">
             <summary>
             A control made up of four discrete, directional buttons. Forms a vector
             but can also be addressed as individual buttons.
             </summary>
             <remarks>
             Is stored as four bits by default.
            
             The vector that is aggregated from the button states is normalized. I.e.
             even if pressing diagonally, the vector will have a length of 1 (instead
             of reading something like <c>(1,1)</c> for example).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DpadControl.down">
            <summary>
            The button representing the vertical downwards state of the D-Pad.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DpadControl.left">
            <summary>
            The button representing the horizontal left state of the D-Pad.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DpadControl.right">
            <summary>
            The button representing the horizontal right state of the D-Pad.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.DpadControl.MakeDpadVector(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create a direction vector from the given four button states.
            </summary>
            <param name="up">Whether button representing the up direction is pressed.</param>
            <param name="down">Whether button representing the down direction is pressed.</param>
            <param name="left">Whether button representing the left direction is pressed.</param>
            <param name="right">Whether button representing the right direction is pressed.</param>
            <param name="normalize">Whether to normalize the resulting vector. If this is false, vectors in the diagonal
            directions will have a magnitude of greater than 1. For example, up-left will be (-1,1).</param>
            <returns>A 2D direction vector.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.DpadControl.MakeDpadVector(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a direction vector from the given axis states.
            </summary>
            <param name="up">Axis value representing the up direction.</param>
            <param name="down">Axis value representing the down direction.</param>
            <param name="left">Axis value representing the left direction.</param>
            <param name="right">Axis value representing the right direction.</param>
            <returns>A 2D direction vector.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.AxisControl">
            <summary>
            A floating-point axis control.
            </summary>
            <remarks>
            Can optionally be configured to perform normalization.
            Stored as either a float, a short, a byte, or a single bit.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.AxisControl.Clamp">
            <summary>
            Clamping behavior for an axis control.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.None">
            <summary>
            Do not clamp values.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.BeforeNormalize">
            <summary>
            Clamp values to <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin"/> and <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax"/>
            before normalizing the value.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.AfterNormalize">
            <summary>
            Clamp values to <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin"/> and <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax"/>
            after normalizing the value.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.ToConstantBeforeNormalize">
            <summary>
            Clamp values any value below <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin"/> or above <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax"/>
            to <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampConstant"/> before normalizing the value.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.clamp">
            <summary>
            Clamping behavior when reading values. <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.None"/> by default.
            </summary>
            <value>Clamping behavior.</value>
            <remarks>
            When a value is read from the control's state, it is first converted
            to a floating-point number.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampConstant"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin">
            <summary>
            Lower end of the clamping range when <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/> is not
            <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.None"/>.
            </summary>
            <value>Lower bound of clamping range. Inclusive.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax">
            <summary>
            Upper end of the clamping range when <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/> is not
            <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.None"/>.
            </summary>
            <value>Upper bound of clamping range. Inclusive.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.clampConstant">
            <summary>
            When <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/> is set to <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.Clamp.ToConstantBeforeNormalize"/>
            and the value is outside of the range defined by <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMin"/> and
            <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clampMax"/>, this value is returned.
            </summary>
            <value>Constant value to return when value is outside of clamping range.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.invert">
            <summary>
            If true, the input value will be inverted, i.e. multiplied by -1. Off by default.
            </summary>
            <value>Whether to invert the input value.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.normalize">
            <summary>
            If true, normalize the input value to [0..1] or [-1..1] (depending on the
            value of <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeZero"/>. Off by default.
            </summary>
            <value>Whether to normalize input values or not.</value>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin">
            <summary>
            If <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/> is on, this is the input value that corresponds
            to 0 of the normalized [0..1] or [-1..1] range.
            </summary>
            <value>Input value that should become 0 or -1.</value>
            <remarks>
            In other words, with <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/> on, input values are mapped from
            the range of [normalizeMin..normalizeMax] to [0..1] or [-1..1] (depending on
            <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeZero"/>).
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax">
            <summary>
            If <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/> is on, this is the input value that corresponds
            to 1 of the normalized [0..1] or [-1..1] range.
            </summary>
            <value>Input value that should become 1.</value>
            <remarks>
            In other words, with <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/> on, input values are mapped from
            the range of [normalizeMin..normalizeMax] to [0..1] or [-1..1] (depending on
            <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeZero"/>).
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeZero">
             <summary>
             Where to put the zero point of the normalization range. Only relevant
             if <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/> is set to true. Defaults to 0.
             </summary>
             <value>Zero point of normalization range.</value>
             <remarks>
             The value of this property determines where the zero point is located in the
             range established by <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/> and <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax"/>.
            
             If <c>normalizeZero</c> is placed at <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/>, the normalization
             returns a value in the [0..1] range mapped from the input value range of
             <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/> and <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax"/>.
            
             If <c>normalizeZero</c> is placed in-between <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/> and
             <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax"/>, normalization returns a value in the [-1..1] mapped
             from the input value range of <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMin"/> and <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalizeMax"/>
             and the zero point between the two established by <c>normalizeZero</c>.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.scale">
            <summary>
            Whether the scale the input value by <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.scaleFactor"/>. Off by default.
            </summary>
            <value>True if inputs should be scaled by <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.scaleFactor"/>.</value>
        </member>
        <member name="F:UnityEngine.InputSystem.Controls.AxisControl.scaleFactor">
            <summary>
            Value to multiple input values with. Only applied if <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.scale"/> is <c>true</c>.
            </summary>
            <value>Multiplier for input values.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.Preprocess(System.Single)">
            <summary>
            Apply modifications to the given value according to the parameters configured
            on the control (<see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/>, <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/>, etc).
            </summary>
            <param name="value">Input value.</param>
            <returns>A processed value (clamped, normalized, etc).</returns>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.normalize"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.scale"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.AxisControl.invert"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
            <remarks>
            Defaults the format to <see cref="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatFloat"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.WriteValueIntoState(System.Single,System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.CompareValue(System.Void*,System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.AxisControl.EvaluateMagnitude(System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.DeltaControl">
            <summary>
            A control representing a two-dimensional motion vector that accumulates within a frame
            and resets at the beginning of a frame.
            </summary>
            <remarks>
            Delta controls are
            </remarks>
            <see cref="P:UnityEngine.InputSystem.Pointer.delta"/>
            <seealso cref="P:UnityEngine.InputSystem.Mouse.scroll"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DeltaControl.up">
            <summary>
            A synthetic axis representing the upper half of the Y axis value, i.e. the 0 to 1 range.
            </summary>
            <value>Control representing the control's upper half Y axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DeltaControl.down">
            <summary>
            A synthetic axis representing the lower half of the Y axis value, i.e. the -1 to 1 range (inverted).
            </summary>
            <value>Control representing the control's lower half Y axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DeltaControl.left">
            <summary>
            A synthetic axis representing the left half of the X axis value, i.e. the -1 to 1 range (inverted).
            </summary>
            <value>Control representing the control's left half X axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Controls.DeltaControl.right">
            <summary>
            A synthetic axis representing the right half of the X axis value, i.e. the 0 to 1 range.
            </summary>
            <value>Control representing the control's right half X axis.</value>
            <remarks>
            The control is marked as <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.TouchPressControl">
            <summary>
            A button that reads its pressed state from <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>.
            </summary>
            <remarks>
            This control is used by <see cref="T:UnityEngine.InputSystem.Controls.TouchControl"/> to link <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.press"/>
            to <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>. It will return 1 as long as the value of
            phase is <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>, <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>, or
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>, i.e. as long as the touch is in progress. For
            all other phases, it will return 0.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Controls.TouchControl"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchPressControl.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchPressControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Controls.TouchPhaseControl">
            <summary>
            A control reading a <see cref="T:UnityEngine.InputSystem.TouchPhase"/> value.
            </summary>
            <remarks>
            This is used mainly by <see cref="T:UnityEngine.InputSystem.Touchscreen"/> to read <see cref="P:UnityEngine.InputSystem.LowLevel.TouchState.phase"/>.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchPhaseControl.#ctor">
            <summary>
            Default-initialize the control.
            </summary>
            <remarks>
            Format of the control is <see cref="F:UnityEngine.InputSystem.LowLevel.InputStateBlock.FormatInt"/>
            by default.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchPhaseControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Controls.TouchPhaseControl.WriteValueIntoState(UnityEngine.InputSystem.TouchPhase,System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.Vector2Composite">
             <summary>
             A 2D planar motion vector computed from an up+down button pair and a left+right
             button pair.
             </summary>
             <remarks>
             This composite allows to grab arbitrary buttons from a device and arrange them in
             a D-Pad like configuration. Based on button presses, the composite will return a
             normalized direction vector (normalization can be turned off via <see cref="F:UnityEngine.InputSystem.Composites.Vector2Composite.mode"/>).
            
             Opposing motions cancel each other out. This means that if, for example, both the left
             and right horizontal button are pressed, the resulting horizontal movement value will
             be zero.
            
             <example>
             <code>
             // Set up WASD style keyboard controls.
             action.AddCompositeBinding("2DVector")
                 .With("Up", "&lt;Keyboard&gt;/w")
                 .With("Left", "&lt;Keyboard&gt;/a")
                 .With("Down", "&lt;Keyboard&gt;/s")
                 .With("Right", "&lt;Keyboard&gt;/d");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.Vector3Composite"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.up">
            <summary>
            Binding for the button that represents the up (that is, <c>(0,1)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.down">
            <summary>
            Binding for the button represents the down (that is, <c>(0,-1)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.left">
            <summary>
            Binding for the button represents the left (that is, <c>(-1,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.right">
            <summary>
            Binding for the button that represents the right (that is, <c>(1,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.mode">
             <summary>
             How to synthesize a <c>Vector2</c> from the values read from <see cref="F:UnityEngine.InputSystem.Composites.Vector2Composite.up"/>, <see cref="F:UnityEngine.InputSystem.Composites.Vector2Composite.down"/>,
             <see cref="F:UnityEngine.InputSystem.Composites.Vector2Composite.left"/>, and <see cref="F:UnityEngine.InputSystem.Composites.Vector2Composite.right"/>.
             </summary>
             <value>Determines how X and Y of the resulting <c>Vector2</c> are formed from input values.</value>
             <remarks>
             <example>
             <code>
             var action = new InputAction();
            
             // DigitalNormalized composite (the default). Turns gamepad left stick into
             // control equivalent to the D-Pad.
             action.AddCompositeBinding("2DVector(mode=0)")
                 .With("up", "&lt;Gamepad&gt;/leftStick/up")
                 .With("down", "&lt;Gamepad&gt;/leftStick/down")
                 .With("left", "&lt;Gamepad&gt;/leftStick/left")
                 .With("right", "&lt;Gamepad&gt;/leftStick/right");
            
             // Digital composite. Turns gamepad left stick into control equivalent
             // to the D-Pad except that diagonals will not be normalized.
             action.AddCompositeBinding("2DVector(mode=1)")
                 .With("up", "&lt;Gamepad&gt;/leftStick/up")
                 .With("down", "&lt;Gamepad&gt;/leftStick/down")
                 .With("left", "&lt;Gamepad&gt;/leftStick/left")
                 .With("right", "&lt;Gamepad&gt;/leftStick/right");
            
             // Analog composite. In this case results in setup that behaves exactly
             // the same as leftStick already does. But you could use it, for example,
             // to swap directions by binding "up" to leftStick/down and "down" to
             // leftStick/up.
             action.AddCompositeBinding("2DVector(mode=2)")
                 .With("up", "&lt;Gamepad&gt;/leftStick/up")
                 .With("down", "&lt;Gamepad&gt;/leftStick/down")
                 .With("left", "&lt;Gamepad&gt;/leftStick/left")
                 .With("right", "&lt;Gamepad&gt;/leftStick/right");
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.Vector2Composite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.Vector2Composite.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.Vector2Composite.Mode">
            <summary>
            Determines how a <c>Vector2</c> is synthesized from part controls.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.Mode.Analog">
            <summary>
            Part controls are treated as analog meaning that the floating-point values read from controls
            will come through as is (minus the fact that the down and left direction values are negated).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.Mode.DigitalNormalized">
            <summary>
            Part controls are treated as buttons (on/off) and the resulting vector is normalized. This means
            that if, for example, both left and up are pressed, instead of returning a vector (-1,1), a vector
            of roughly (-0.7,0.7) (that is, corresponding to <c>new Vector2(-1,1).normalized</c>) is returned instead.
            The resulting 2D area is diamond-shaped.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector2Composite.Mode.Digital">
            <summary>
            Part controls are treated as buttons (on/off) and the resulting vector is not normalized. This means
            that if, for example, both left and up are pressed, the resulting vector is (-1,1) and has a length
            greater than 1. The resulting 2D area is box-shaped.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.OneModifierComposite">
             <summary>
             A binding with an additional modifier. The bound controls only trigger when
             the modifier is pressed.
             </summary>
             <remarks>
             This composite can be used to require a button to be held in order to "activate"
             another binding.  This is most commonly used on keyboards to require one of the
             modifier keys (shift, ctrl, or alt) to be held in combination with another control,
             e.g. "CTRL+1".
            
             <example>
             <code>
             // Create a button action that triggers when CTRL+1
             // is pressed on the keyboard.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("OneModifier")
                 .With("Modifier", "&lt;Keyboard&gt;/ctrl")
                 .With("Binding", "&lt;Keyboard&gt;/1")
             </code>
             </example>
            
             However, this can also be used to "gate" other types of controls. For example, a "look"
             action could be bound to mouse <see cref="P:UnityEngine.InputSystem.Pointer.delta"/> such that the <see cref="P:UnityEngine.InputSystem.Keyboard.altKey"/> on the
             keyboard has to be pressed in order for the player to be able to look around.
            
             <example>
             <code>
             lookAction.AddCompositeBinding("OneModifier")
                 .With("Modifier", "&lt;Keyboard&gt;/alt")
                 .With("Binding", "&lt;Mouse&gt;/delta")
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.TwoModifiersComposite"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.OneModifierComposite.modifier">
            <summary>
            Binding for the button that acts as a modifier, e.g. <c>&lt;Keyboard/ctrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding">
            <summary>
            Binding for the control that is gated by the modifier. The composite will assume the value
            of this control while the modifier is considered pressed (that is, has a magnitude equal to or
            greater than the button press point).
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Composites.OneModifierComposite.valueType">
            <summary>
            Type of values read from controls bound to <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Composites.OneModifierComposite.valueSizeInBytes">
            <summary>
            Size of the largest value that may be read from the controls bound to <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.OneModifierComposite.overrideModifiersNeedToBePressedFirst">
             <summary>
             If set to <c>true</c>, the built-in logic to determine if modifiers need to be pressed first is overridden.
             Default value is <c>false</c>.
             </summary>
             <remarks>
             By default, if <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding"/> is bound to only <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>s, then the composite requires
             <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.modifier"/> to be pressed <em>before</em> pressing <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding"/>. This means that binding to, for example,
             <c>Ctrl+B</c>, the <c>ctrl</c> keys have to be pressed before pressing the <c>B</c> key. This is the behavior usually expected
             with keyboard shortcuts.
            
             However, when binding, for example, <c>Ctrl+MouseDelta</c>, it should be possible to press <c>ctrl</c> at any time. The default
             logic will automatically detect the difference between this binding and the button binding in the example above and behave
             accordingly.
            
             This field allows you to explicitly override this default inference and make it so that regardless of what <see cref="F:UnityEngine.InputSystem.Composites.OneModifierComposite.binding"/>
             is bound to, any press sequence is acceptable. For the example binding to <c>Ctrl+B</c>, it would mean that pressing <c>B</c> and
             only then pressing <c>Ctrl</c> will still trigger the binding.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.OneModifierComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.OneModifierComposite.FinishSetup(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.AxisComposite">
             <summary>
             A single axis value computed from one axis that pulls in the <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> direction (<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/>) and one
             axis that pulls in the <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> direction (<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/>).
             </summary>
             <remarks>
             The limits of the axis are determined by <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/>.
             By default, they are set to <c>[-1..1]</c>. The values can be set as parameters.
            
             <example>
             <code>
             var action = new InputAction();
             action.AddCompositeBinding("Axis(minValue=0,maxValue=2")
                 .With("Negative", "&lt;Keyboard&gt;/a")
                 .With("Positive", "&lt;Keyboard&gt;/d");
             </code>
             </example>
            
             If both axes are actuated at the same time, the behavior depends on <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.whichSideWins"/>.
             By default, neither side will win (<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Neither"/>) and the result
             will be 0 (or, more precisely, the midpoint between <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/>).
             This can be customized to make the positive side win (<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Positive"/>)
             or the negative one (<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Negative"/>).
            
             This is useful, for example, in a driving game where break should cancel out accelerate.
             By binding <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> to the break control(s) and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> to the
             acceleration control(s), and setting <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.whichSideWins"/> to <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Negative"/>,
             if the break button is pressed, it will always cause the acceleration button to be ignored.
            
             The actual <em>absolute</em> values of <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> are used
             to scale <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/> respectively. So if, for example, <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/>
             is bound to <see cref="P:UnityEngine.InputSystem.Gamepad.rightTrigger"/> and the trigger is at a value of 0.5, then the resulting
             value is <c>maxValue * 0.5</c> (the actual formula is <c>midPoint + (maxValue - midPoint) * positive</c>).
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.negative">
            <summary>
            Binding for the axis input that controls the negative [<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/>..0] direction of the
            combined axis.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.positive">
            <summary>
            Binding for the axis input that controls the positive [0..<see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/>] direction of the
            combined axis.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue">
             <summary>
             The lower bound that the axis is limited to. -1 by default.
             </summary>
             <remarks>
             This value corresponds to the full actuation of the control(s) bound to <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/>.
            
             <example>
             <code>
             var action = new InputAction();
             action.AddCompositeBinding("Axis(minValue=0,maxValue=2")
                 .With("Negative", "&lt;Keyboard&gt;/a")
                 .With("Positive", "&lt;Keyboard&gt;/d");
             </code>
             </example>
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue"/>
             <seealso cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.maxValue">
             <summary>
             The upper bound that the axis is limited to. 1 by default.
             </summary>
             <remarks>
             This value corresponds to the full actuation of the control(s) bound to <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/>.
            
             <example>
             <code>
             var action = new InputAction();
             action.AddCompositeBinding("Axis(minValue=0,maxValue=2")
                 .With("Negative", "&lt;Keyboard&gt;/a")
                 .With("Positive", "&lt;Keyboard&gt;/d");
             </code>
             </example>
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.Composites.AxisComposite.minValue"/>
             <seealso cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.whichSideWins">
            <summary>
            If both the <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> button are actuated, this
            determines which value is returned from the composite.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Composites.AxisComposite.midPoint">
            <summary>
            The value that is returned if the composite is in a neutral position, that is, if
            neither <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> nor <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated or if
            <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.whichSideWins"/> is set to <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Neither"/> and
            both <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.AxisComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.AxisComposite.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins">
            <summary>
            What happens to the value of an <see cref="T:UnityEngine.InputSystem.Composites.AxisComposite"/> if both <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/>
            and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated at the same time.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Neither">
            <summary>
            If both <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated, the sides cancel
            each other out and the result is 0.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Positive">
            <summary>
            If both <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated, the value of
            <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> wins and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> is ignored.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.AxisComposite.WhichSideWins.Negative">
            <summary>
            If both <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> are actuated, the value of
            <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/> wins and <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.positive"/> is ignored.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.TwoModifiersComposite">
             <summary>
             A binding with two additional modifiers modifier. The bound controls only trigger when
             both modifiers are pressed.
             </summary>
             <remarks>
             This composite can be used to require two buttons to be held in order to "activate"
             another binding.  This is most commonly used on keyboards to require two of the
             modifier keys (shift, ctrl, or alt) to be held in combination with another control,
             e.g. "SHIFT+CTRL+1".
            
             <example>
             <code>
             // Create a button action that triggers when SHIFT+CTRL+1
             // is pressed on the keyboard.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("TwoModifiers")
                 .With("Modifier", "&lt;Keyboard&gt;/ctrl")
                 .With("Modifier", "&lt;Keyboard&gt;/shift")
                 .With("Binding", "&lt;Keyboard&gt;/1")
             </code>
             </example>
            
             However, this can also be used to "gate" other types of controls. For example, a "look"
             action could be bound to mouse <see cref="P:UnityEngine.InputSystem.Pointer.delta"/> such that the <see cref="P:UnityEngine.InputSystem.Keyboard.ctrlKey"/> and
             <see cref="P:UnityEngine.InputSystem.Keyboard.shiftKey"/> on the keyboard have to be pressed in order for the player to be able to
             look around.
            
             <example>
             <code>
             var action = new InputAction();
             action.AddCompositeBinding("TwoModifiers")
                 .With("Modifier1", "&lt;Keyboard&gt;/ctrl")
                 .With("Modifier2", "&lt;Keyboard&gt;/shift")
                 .With("Binding", "&lt;Mouse&gt;/delta");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.OneModifierComposite"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier1">
            <summary>
            Binding for the first button that acts as a modifier, e.g. <c>&lt;Keyboard/leftCtrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier2">
            <summary>
            Binding for the second button that acts as a modifier, e.g. <c>&lt;Keyboard/leftCtrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding">
            <summary>
            Binding for the control that is gated by <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier1"/> and <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier2"/>.
            The composite will assume the value of this button while both of the modifiers are pressed.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.overrideModifiersNeedToBePressedFirst">
             <summary>
             If set to <c>true</c>, the built-in logic to determine if modifiers need to be pressed first is overridden.
             Default value is <c>false</c>.
             </summary>
             <remarks>
             By default, if <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding"/> is bound to only <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>s, then the composite requires
             both <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier1"/> and <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.modifier2"/> to be pressed <em>before</em> pressing <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding"/>.
             This means that binding to, for example, <c>Ctrl+Shift+B</c>, the <c>ctrl</c> and <c>shift</c> keys have to be pressed
             before pressing the <c>B</c> key. This is the behavior usually expected with keyboard shortcuts.
            
             However, when binding, for example, <c>Ctrl+Shift+MouseDelta</c>, it should be possible to press <c>ctrl</c> and <c>shift</c>
             at any time and in any order. The default logic will automatically detect the difference between this binding and the button
             binding in the example above and behave accordingly.
            
             This field allows you to explicitly override this default inference and make it so that regardless of what <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding"/>
             is bound to, any press sequence is acceptable. For the example binding to <c>Ctrl+Shift+B</c>, it would mean that pressing
             <c>B</c> and only then pressing <c>Ctrl</c> and <c>Shift</c> will still trigger the binding.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Composites.TwoModifiersComposite.valueType">
            <summary>
            Type of values read from controls bound to <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Composites.TwoModifiersComposite.valueSizeInBytes">
            <summary>
            Size of the largest value that may be read from the controls bound to <see cref="F:UnityEngine.InputSystem.Composites.TwoModifiersComposite.binding"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.TwoModifiersComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.TwoModifiersComposite.FinishSetup(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.ButtonWithOneModifier">
             <summary>
             A button with an additional modifier. The button only triggers when
             the modifier is pressed.
             </summary>
             <remarks>
             This composite can be used to require another button to be held while
             pressing the button that triggers the action. This is most commonly used
             on keyboards to require one of the modifier keys (shift, ctrl, or alt)
             to be held in combination with another key, e.g. "CTRL+1".
            
             <example>
             <code>
             // Create a button action that triggers when CTRL+1
             // is pressed on the keyboard.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("ButtonWithOneModifier")
                 .With("Modifier", "&lt;Keyboard&gt;/leftCtrl")
                 .With("Modifier", "&lt;Keyboard&gt;/rightControl")
                 .With("Button", "&lt;Keyboard&gt;/1")
             </code>
             </example>
            
             Note that this is not restricted to the keyboard and will preserve
             the full value of the button.
            
             <example>
             <code>
             // Create a button action that requires the A button on the
             // gamepad to be held and will then trigger from the gamepad's
             // left trigger button.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("ButtonWithOneModifier")
                 .With("Modifier", "&lt;Gamepad&gt;/buttonSouth")
                 .With("Button", "&lt;Gamepad&gt;/leftTrigger");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.modifier">
            <summary>
            Binding for the button that acts as a modifier, e.g. <c>&lt;Keyboard/leftCtrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.button">
            <summary>
            Binding for the button that is gated by the modifier. The composite will assume the value
            of this button while the modifier is pressed.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.overrideModifiersNeedToBePressedFirst">
             <summary>
             If set to <c>true</c>, <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.modifier"/> can be pressed after <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.button"/> and the composite will
             still trigger. Default is false.
             </summary>
             <remarks>
             By default, <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.modifier"/> is required to be in pressed state before or at the same time that <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.button"/>
             goes into pressed state for the composite as a whole to trigger. This means that binding to, for example, <c>Shift+B</c>,
             the <c>shift</c> key has to be pressed before pressing the <c>B</c> key. This is the behavior usually expected with
             keyboard shortcuts.
            
             This parameter can be used to bypass this behavior and allow any timing between <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.modifier"/> and <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.button"/>.
             The only requirement is for them both to concurrently be in pressed state.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <summary>
            Return the value of the <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.button"/> part if <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.modifier"/> is pressed. Otherwise
            return 0.
            </summary>
            <param name="context">Evaluation context passed in from the input system.</param>
            <returns>The current value of the composite.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.Composites.ButtonWithOneModifier.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)"/> in this case.
            </summary>
            <param name="context">Evaluation context passed in from the input system.</param>
            <returns>A >0 value if the composite is currently actuated.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers">
             <summary>
             A button with two additional modifiers. The button only triggers when
             both modifiers are pressed.
             </summary>
             <remarks>
             This composite can be used to require two other buttons to be held while
             using the control that triggers the action. This is most commonly used
             on keyboards to require two of the modifier keys (shift, ctrl, or alt)
             to be held in combination with another key, e.g. "CTRL+SHIFT+1".
            
             <example>
             <code>
             // Create a button action that triggers when CTRL+SHIFT+1
             // is pressed on the keyboard.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("TwoModifiers")
                 .With("Modifier1", "&lt;Keyboard&gt;/leftCtrl")
                 .With("Modifier1", "&lt;Keyboard&gt;/rightCtrl")
                 .With("Modifier2", "&lt;Keyboard&gt;/leftShift")
                 .With("Modifier2", "&lt;Keyboard&gt;/rightShift")
                 .With("Button", "&lt;Keyboard&gt;/1")
             </code>
             </example>
            
             Note that this is not restricted to the keyboard and will preserve
             the full value of the button.
            
             <example>
             <code>
             // Create a button action that requires the A and X button on the
             // gamepad to be held and will then trigger from the gamepad's
             // left trigger button.
             var action = new InputAction(type: InputActionType.Button);
             action.AddCompositeBinding("ButtonWithTwoModifiers")
                 .With("Modifier1", "&lt;Gamepad&gt;/buttonSouth")
                 .With("Modifier2", "&lt;Gamepad&gt;/buttonWest")
                 .With("Button", "&lt;Gamepad&gt;/leftTrigger");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.ButtonWithOneModifier"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1">
            <summary>
            Binding for the first button that acts as a modifier, e.g. <c>&lt;Keyboard/leftCtrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2">
            <summary>
            Binding for the second button that acts as a modifier, e.g. <c>&lt;Keyboard/leftCtrl</c>.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.button">
            <summary>
            Binding for the button that is gated by <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1"/> and <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2"/>.
            The composite will assume the value of this button while both of the modifiers are pressed.
            </summary>
            <value>Part index to use with <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>.</value>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.overrideModifiersNeedToBePressedFirst">
             <summary>
             If set to <c>true</c>, <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1"/> and/or <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2"/> can be pressed after <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.button"/>
             and the composite will still trigger. Default is false.
             </summary>
             <remarks>
             By default, <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1"/> and <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2"/> are required to be in pressed state before or at the same
             time that <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.button"/> goes into pressed state for the composite as a whole to trigger. This means that binding to,
             for example, <c>Ctrl+Shift+B</c>, the <c>ctrl</c> <c>shift</c> keys have to be pressed before pressing the <c>B</c> key.
             This is the behavior usually expected with keyboard shortcuts.
            
             This parameter can be used to bypass this behavior and allow any timing between <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1"/>, <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2"/>,
             and <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.button"/>. The only requirement is for all of them to concurrently be in pressed state.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <summary>
            Return the value of the <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.button"/> part while both <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier1"/> and <see cref="F:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.modifier2"/>
            are pressed. Otherwise return 0.
            </summary>
            <param name="context">Evaluation context passed in from the input system.</param>
            <returns>The current value of the composite.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.Composites.ButtonWithTwoModifiers.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)"/> in this case.
            </summary>
            <param name="context">Evaluation context passed in from the input system.</param>
            <returns>A >0 value if the composite is currently actuated.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.Vector3Composite">
             <summary>
             A 3D vector formed from six floating-point inputs.
             </summary>
             <remarks>
             Depending on the setting of <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.mode"/>, the vector is either in  the [-1..1]
             range on each axis (normalized or not depending on <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.mode"/>) or is in the
             full value range of the input controls.
            
             <example>
             <code>
             action.AddCompositeBinding("3DVector")
                 .With("Forward", "&lt;Keyboard&gt;/w")
                 .With("Backward", "&lt;Keyboard&gt;/s")
                 .With("Left", "&lt;Keyboard&gt;/a")
                 .With("Right", "&lt;Keyboard&gt;/d")
                 .With("Up", "&lt;Keyboard&gt;/q")
                 .With("Down", "&lt;Keyboard&gt;/e");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.up">
            <summary>
            Binding for the button that represents the up (that is, <c>(0,1,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.down">
            <summary>
            Binding for the button that represents the down (that is, <c>(0,-1,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.left">
            <summary>
            Binding for the button that represents the left (that is, <c>(-1,0,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.right">
            <summary>
            Binding for the button that represents the right (that is, <c>(1,0,0)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.forward">
            <summary>
            Binding for the button that represents the right (that is, <c>(0,0,1)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.backward">
            <summary>
            Binding for the button that represents the right (that is, <c>(0,0,-1)</c>) direction of the vector.
            </summary>
            <remarks>
            This property is automatically assigned by the input system.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.mode">
            <summary>
            How to synthesize a <c>Vector3</c> from the values read from <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.up"/>, <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.down"/>,
            <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.left"/>, <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.right"/>, <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.forward"/>, and <see cref="F:UnityEngine.InputSystem.Composites.Vector3Composite.backward"/>.
            </summary>
            <value>Determines how X, Y, and Z of the resulting <c>Vector3</c> are formed from input values.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Composites.Vector3Composite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Composites.Vector3Composite.Mode">
            <summary>
            Determines how a <c>Vector3</c> is synthesized from part controls.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.Mode.Analog">
            <summary>
            Part controls are treated as analog meaning that the floating-point values read from controls
            will come through as is (minus the fact that the down and left direction values are negated).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.Mode.DigitalNormalized">
            <summary>
            Part controls are treated as buttons (on/off) and the resulting vector is normalized. This means
            that if, for example, both left and up are pressed, instead of returning a vector (-1,1,0), a vector
            of roughly (-0.7,0.7,0) (that is, corresponding to <c>new Vector3(-1,1,0).normalized</c>) is returned instead.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Composites.Vector3Composite.Mode.Digital">
            <summary>
            Part controls are treated as buttons (on/off) and the resulting vector is not normalized. This means
            that if both left and up are pressed, for example, the resulting vector is (-1,1,0) and has a length
            greater than 1.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis">
            <summary>
            Enum used to identity the axis type in the Android motion input event. See <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidGameControllerState.axis"/>.
            See https://developer.android.com/reference/android/view/MotionEvent#constants_1 for more details.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.X">
            <summary>
            X axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Y">
            <summary>
            Y axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Pressure">
            <summary>
            Pressure axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Size">
            <summary>
            Size axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.TouchMajor">
            <summary>
            TouchMajor axis  of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.TouchMinor">
            <summary>
            TouchMinor axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.ToolMajor">
            <summary>
            ToolMajor axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.ToolMinor">
            <summary>
            ToolMinor axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Orientation">
            <summary>
            Orientation axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Vscroll">
            <summary>
            Vertical Scroll of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Hscroll">
            <summary>
            Horizontal Scroll axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Z">
            <summary>
            Z axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Rx">
            <summary>
            X Rotation axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Ry">
            <summary>
            Y Rotation axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Rz">
            <summary>
            Z Rotation axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.HatX">
            <summary>
            Hat X axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.HatY">
            <summary>
            Hat Y axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Ltrigger">
            <summary>
            Left Trigger axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Rtrigger">
            <summary>
            Right Trigger axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Throttle">
            <summary>
            Throttle axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Rudder">
            <summary>
            Rudder axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Wheel">
            <summary>
            Wheel axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Gas">
            <summary>
            Gas axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Brake">
            <summary>
            Break axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Distance">
            <summary>
            Distance axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Tilt">
            <summary>
            Tilt axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic1">
            <summary>
            Generic 1 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic2">
            <summary>
            Generic 2 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic3">
            <summary>
            Generic 3 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic4">
            <summary>
            Generic 4 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic5">
            <summary>
            Generic 5 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic6">
            <summary>
            Generic 6 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic7">
            <summary>
            Generic 7 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic8">
            <summary>
            Generic 8 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic9">
            <summary>
            Generic 9 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic10">
            <summary>
            Generic 10 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic11">
            <summary>
            Generic 11 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic12">
            <summary>
            Generic 12 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic13">
            <summary>
            Generic 13 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic14">
            <summary>
            Generic 14 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic15">
            <summary>
            Generic 15 axis of a motion event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidAxis.Generic16">
            <summary>
            Generic 16 axis of a motion event.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.LowLevel.AndroidGameControllerState">
            <summary>
            Default state layout for Android game controller.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode">
            <summary>
            Enum used to identity the key in the Android key event. See <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidGameControllerState.buttons"/>.
            See https://developer.android.com/reference/android/view/KeyEvent#constants_1 for more details.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Unknown">
            <summary>
            Unknown key code.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.SoftLeft">
            <summary>
            Soft Left key. Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom left of the display.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.SoftRight">
            <summary>
            Soft Right key. Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom right of the display.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Home">
            <summary>
            Home key. This key is handled by the framework and is never delivered to applications.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Back">
            <summary>
            Back key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Call">
            <summary>
            Call key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Endcall">
            <summary>
            End Call key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha0">
            <summary>
            '0' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha1">
            <summary>
            '1' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha2">
            <summary>
            '2' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha3">
            <summary>
            '3' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha4">
            <summary>
            '4' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha5">
            <summary>
            '5' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha6">
            <summary>
            '6' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha7">
            <summary>
            '7' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha8">
            <summary>
            '8' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Alpha9">
            <summary>
            '9' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Star">
            <summary>
            '*' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Pound">
            <summary>
            '#' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.DpadUp">
            <summary>
            Directional Pad Up key. May also be synthesized from trackball motions.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.DpadDown">
            <summary>
            Directional Pad Down key. May also be synthesized from trackball motions.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.DpadLeft">
            <summary>
            Directional Pad Left key. May also be synthesized from trackball motions.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.DpadRight">
            <summary>
            Directional Pad Right key. May also be synthesized from trackball motions.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.DpadCenter">
            <summary>
            Directional Pad Center key. May also be synthesized from trackball motions.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.VolumeUp">
            <summary>
            Volume Up key. Adjusts the speaker volume up.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.VolumeDown">
            <summary>
            Volume Down key. Adjusts the speaker volume down.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Power">
            <summary>
            Power key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Camera">
            <summary>
            Camera key. Used to launch a camera application or take pictures.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Clear">
            <summary>
            Clear key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.A">
            <summary>
            'A' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.B">
            <summary>
            'B' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.C">
            <summary>
            'C' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.D">
            <summary>
            'D' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.E">
            <summary>
            'E' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F">
            <summary>
            'F' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.G">
            <summary>
            'G' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.H">
            <summary>
            'H' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.I">
            <summary>
            'I' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.J">
            <summary>
            'J' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.K">
            <summary>
            'K' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.L">
            <summary>
            'L' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.M">
            <summary>
            'M' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.N">
            <summary>
            'N' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.O">
            <summary>
            'O' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.P">
            <summary>
            'P' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Q">
            <summary>
            'Q' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.R">
            <summary>
            'R' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.S">
            <summary>
            'S' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.T">
            <summary>
            'T' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.U">
            <summary>
            'U' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.V">
            <summary>
            'V' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.W">
            <summary>
            'W' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.X">
            <summary>
            'X' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Y">
            <summary>
            'Y' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Z">
            <summary>
            'Z' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Comma">
            <summary>
            ',' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Period">
            <summary>
            '.' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AltLeft">
            <summary>
            Left Alt modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AltRight">
            <summary>
            Right Alt modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ShiftLeft">
            <summary>
            Left Shift modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ShiftRight">
            <summary>
            Right Shift modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Tab">
            <summary>
            Tab key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Space">
            <summary>
            Space key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Sym">
            <summary>
            Symbol modifier key. Used to enter alternate symbols.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Explorer">
            <summary>
            Explorer special function key. Used to launch a browser application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Envelope">
            <summary>
            Envelope special function key. Used to launch a mail application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Enter">
            <summary>
            Enter key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Del">
            <summary>
            Backspace key. Deletes characters before the insertion point, unlike <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ForwardDel"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Grave">
            <summary>
            '`' (backtick) key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Minus">
            <summary>
            '-' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Equals">
            <summary>
            '=' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.LeftBracket">
            <summary>
            '[' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.RightBracket">
            <summary>
            ']' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Backslash">
            <summary>
            '\' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Semicolon">
            <summary>
            ';' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Apostrophe">
            <summary>
            ''' (apostrophe) key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Slash">
            <summary>
            '/' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.At">
            <summary>
            '@' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Num">
            <summary>
            Number modifier key. Used to enter numeric symbols. This key is not Num Lock; it is more like <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AltLeft"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Headsethook">
            <summary>
            Headset Hook key. Used to hang up calls and stop media.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Focus">
            <summary>
            Camera Focus key. Used to focus the camera.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Plus">
            <summary>
            '+' key.
            </summary> // *Camera* focus
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Menu">
            <summary>
            Menu key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Notification">
            <summary>
            Notification key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Search">
            <summary>
            Search key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaPlayPause">
            <summary>
            Play/Pause media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaStop">
            <summary>
            Stop media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaNext">
            <summary>
            Play Next media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaPrevious">
            <summary>
            Play Previous media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaRewind">
            <summary>
            Rewind media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaFastForward">
            <summary>
            Fast Forward media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Mute">
            <summary>
            Mute key. Mutes the microphone, unlike <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.VolumeMute"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.PageUp">
            <summary>
            Page Up key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.PageDown">
            <summary>
            Page Down key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Pictsymbols">
            <summary>
            Picture Symbols modifier key. Used to switch symbol sets (Emoji, Kao-moji).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.SwitchCharset">
            <summary>
            Switch Charset modifier key. Used to switch character sets (Kanji, Katakana).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonA">
            <summary>
            A Button key. On a game controller, the A button should be either the button labeled A or the first button on the bottom row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonB">
            <summary>
            B Button key. On a game controller, the B button should be either the button labeled B or the second button on the bottom row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonC">
            <summary>
            C Button key. On a game controller, the C button should be either the button labeled C or the third button on the bottom row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonX">
            <summary>
            X Button key. On a game controller, the X button should be either the button labeled X or the first button on the upper row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonY">
            <summary>
            Y Button key. On a game controller, the Y button should be either the button labeled Y or the second button on the upper row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonZ">
            <summary>
            Z Button key. On a game controller, the Z button should be either the button labeled Z or the third button on the upper row of controller buttons.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonL1">
            <summary>
            L1 Button key. On a game controller, the L1 button should be either the button labeled L1 (or L) or the top left trigger button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonR1">
            <summary>
            R1 Button key. On a game controller, the R1 button should be either the button labeled R1 (or R) or the top right trigger button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonL2">
            <summary>
            L2 Button key. On a game controller, the L2 button should be either the button labeled L2 or the bottom left trigger button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonR2">
            <summary>
            R2 Button key. On a game controller, the R2 button should be either the button labeled R2 or the bottom right trigger button.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonThumbl">
            <summary>
            Left Thumb Button key. On a game controller, the left thumb button indicates that the left (or only) joystick is pressed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonThumbr">
            <summary>
            Right Thumb Button key. On a game controller, the right thumb button indicates that the right joystick is pressed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonStart">
            <summary>
            Start Button key. On a game controller, the button labeled Start.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonSelect">
            <summary>
            Select Button key. On a game controller, the button labeled Select.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ButtonMode">
            <summary>
            Mode Button key. On a game controller, the button labeled Mode.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Escape">
            <summary>
            Escape key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ForwardDel">
            <summary>
            Forward Delete key. Deletes characters ahead of the insertion point, unlike <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Del"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.CtrlLeft">
            <summary>
            Left Control modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.CtrlRight">
            <summary>
            Right Control modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.CapsLock">
            <summary>
            Caps Lock key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ScrollLock">
            <summary>
            Scroll Lock key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MetaLeft">
            <summary>
            Left Meta modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MetaRight">
            <summary>
            Right Meta modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Function">
            <summary>
            Function modifier key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Sysrq">
            <summary>
            System Request / Print Screen key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Break">
            <summary>
            Break / Pause key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MoveHome">
            <summary>
            Home Movement key. Used for scrolling or moving the cursor around to the start of a line or to the top of a list.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MoveEnd">
            <summary>
            End Movement key. Used for scrolling or moving the cursor around to the end of a line or to the bottom of a list.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Insert">
            <summary>
            Insert key. Toggles insert / overwrite edit mode.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Forward">
            <summary>
            Forward key. Navigates forward in the history stack. Complement of <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Back"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaPlay">
            <summary>
            Play media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaPause">
            <summary>
            Play/Pause media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaClose">
            <summary>
            Close media key. May be used to close a CD tray, for example.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaEject">
            <summary>
            Eject media key. May be used to eject a CD tray, for example.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MediaRecord">
            <summary>
            Record media key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F1">
            <summary>
            F1 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F2">
            <summary>
            F2 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F3">
            <summary>
            F3 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F4">
            <summary>
            F4 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F5">
            <summary>
            F5 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F6">
            <summary>
            F6 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F7">
            <summary>
            F7 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F8">
            <summary>
            F8 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F9">
            <summary>
            F9 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F10">
            <summary>
            F10 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F11">
            <summary>
            F11 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.F12">
            <summary>
            F12 key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumLock">
            <summary>
            Num Lock key. This is the Num Lock key; it is different from <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Num"/>. This key alters the behavior of other keys on the numeric keypad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad0">
            <summary>
            Numeric keypad '0' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad1">
            <summary>
            Numeric keypad '1' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad2">
            <summary>
            Numeric keypad '2' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad3">
            <summary>
            Numeric keypad '3' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad4">
            <summary>
            Numeric keypad '4' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad5">
            <summary>
            Numeric keypad '5' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad6">
            <summary>
            'Numeric keypad '6' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad7">
            <summary>
            'Numeric keypad '7' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad8">
            <summary>
            Numeric keypad '8' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Numpad9">
            <summary>
            Numeric keypad '9' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadDivide">
            <summary>
            Numeric keypad '/' key (for division).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadMultiply">
            <summary>
            Numeric keypad '*' key (for multiplication).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadSubtract">
            <summary>
            Numeric keypad '-' key (for subtraction).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadAdd">
            <summary>
            Numeric keypad '+' key (for addition).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadDot">
            <summary>
            Numeric keypad '.' key (for decimals or digit grouping).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadComma">
            <summary>
            Numeric keypad ',' key (for decimals or digit grouping).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadEnter">
            <summary>
            Numeric keypad Enter key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadEquals">
            <summary>
            Numeric keypad '=' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadLeftParen">
            <summary>
            Numeric keypad '(' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.NumpadRightParen">
            <summary>
            Numeric keypad ')' key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.VolumeMute">
            <summary>
            Volume Mute key. Mutes the speaker, unlike <see cref="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Mute"/>. This key should normally be implemented as a toggle such that the first press mutes the speaker and the second press restores the original volum
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Info">
            <summary>
            Info key. Common on TV remotes to show additional information related to what is currently being viewed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ChannelUp">
            <summary>
            Channel up key. On TV remotes, increments the television channel.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ChannelDown">
            <summary>
            Channel down key. On TV remotes, increments the television channel.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ZoomIn">
            <summary>
            Zoom in key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ZoomOut">
            <summary>
            Zoom out key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Tv">
            <summary>
            TV key. On TV remotes, switches to viewing live TV.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Window">
            <summary>
            Window key. On TV remotes, toggles picture-in-picture mode or other windowing functions. On Android Wear devices, triggers a display offset.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Guide">
            <summary>
            Guide key. On TV remotes, shows a programming guide.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Dvr">
            <summary>
            DVR key. On some TV remotes, switches to a DVR mode for recorded shows.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Bookmark">
            <summary>
            Bookmark key. On some TV remotes, bookmarks content or web pages.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Captions">
            <summary>
            Toggle captions key. Switches the mode for closed-captioning text, for example during television shows.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Settings">
            <summary>
            Settings key. Starts the system settings activity.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.TvPower">
            <summary>
            TV power key. On HDMI TV panel devices and Android TV devices that don't support HDMI, toggles the power state of the device. On HDMI source devices, toggles the power state of the HDMI-connected TV via HDMI-CEC and makes the source device follow this power state.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.TvInput">
            <summary>
            TV input key. On TV remotes, switches the input on a television screen.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.StbPower">
            <summary>
            Set-top-box power key. On TV remotes, toggles the power on an external Set-top-box.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.StbInput">
            <summary>
            Set-top-box input key. On TV remotes, switches the input mode on an external Set-top-box.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AvrPower">
            <summary>
            A/V Receiver power key. On TV remotes, toggles the power on an external A/V Receiver.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AvrInput">
            <summary>
            A/V Receiver input key. On TV remotes, switches the input mode on an external A/V Receive
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ProgRed">
            <summary>
            Red "programmable" key. On TV remotes, acts as a contextual/programmable key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ProgGreen">
            <summary>
            Green "programmable" key. On TV remotes, actsas a contextual/programmable key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ProgYellow">
            <summary>
            Yellow "programmable" key. On TV remotes, actsas a contextual/programmable key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ProgBlue">
            <summary>
            Blue "programmable" key. On TV remotes, actsas a contextual/programmable key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.AppSwitch">
            <summary>
            App switch key. Should bring up the application switcher dialog.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button1">
            <summary>
            Generic Game Pad Button #1.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button2">
            <summary>
            Generic Game Pad Button #2.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button3">
            <summary>
            Generic Game Pad Button #3.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button4">
            <summary>
            Generic Game Pad Button #4.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button5">
            <summary>
            Generic Game Pad Button #5.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button6">
            <summary>
            Generic Game Pad Button #6.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button7">
            <summary>
            Generic Game Pad Button #7.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button8">
            <summary>
            Generic Game Pad Button #8.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button9">
            <summary>
            Generic Game Pad Button #9.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button10">
            <summary>
            Generic Game Pad Button #10.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button11">
            <summary>
            Generic Game Pad Button #11.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button12">
            <summary>
            Generic Game Pad Button #12.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button13">
            <summary>
            Generic Game Pad Button #13.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button14">
            <summary>
            Generic Game Pad Button #14.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button15">
            <summary>
            Generic Game Pad Button #15.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Button16">
            <summary>
            Generic Game Pad Button #16.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.LanguageSwitch">
            <summary>
            Language Switch key. Toggles the current input language such as switching between English and Japanese on a QWERTY keyboard. On some devices, the same function may be performed by pressing Shift+Spacebar.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.MannerMode">
            <summary>
            'Manner Mode key. Toggles silent or vibrate mode on and off to make the device behave more politely in certain settings such as on a crowded train. On some devices, the key may only operate when long-pressed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Mode3D">
            <summary>
            3D Mode key. Toggles the display between 2D and 3D mode.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Contacts">
            <summary>
            Contacts special function key. Used to launch an address book application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Calendar">
            <summary>
            Calendar special function key. Used to launch a calendar application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Music">
            <summary>
            Music special function key. Used to launch a music player application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Calculator">
            <summary>
            Calculator special function key. Used to launch a calculator application.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.ZenkakuHankaku">
            <summary>
            Japanese full-width / half-width key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Eisu">
            <summary>
            Japanese alphanumeric key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Muhenkan">
            <summary>
            Japanese non-conversion key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Henkan">
            <summary>
            Japanese conversion key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.KatakanaHiragana">
            <summary>
            Japanese katakana / hiragana key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Yen">
            <summary>
            Japanese Yen key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Ro">
            <summary>
            Japanese Ro key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Kana">
            <summary>
            Japanese kana key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Android.LowLevel.AndroidKeyCode.Assist">
            <summary>
            Assist key. Launches the global assist activity. Not delivered to applications.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidGamepad">
            <summary>
            Gamepad on Android. Comprises all types of gamepads supported on Android.
            </summary>
            <remarks>
            Most of the gamepads:
            - ELAN PLAYSTATION(R)3 Controller
            - My-Power CO.,LTD. PS(R) Controller Adaptor
            (Following tested and work with: Nvidia Shield TV (OS 9); Galaxy Note 20 Ultra (OS 11); Galaxy S9+ (OS 10.0))
            - Sony Interactive Entertainment Wireless (PS4 DualShock) (Also tested and DOES NOT WORK with Galaxy S9 (OS 8.0); Galaxy S8 (OS 7.0); Xiaomi Mi Note2 (OS 8.0))
            - Xbox Wireless Controller (Xbox One) (Also tested and works on Samsung Galaxy S8 (OS 7.0); Xiaomi Mi Note2 (OS 8.0))
            - NVIDIA Controller v01.03/v01.04
            - (Add more)
            map buttons in the following way:
             Left Stick -> AXIS_X(0) / AXIS_Y(1)
             Right Stick -> AXIS_Z (11) / AXIS_RZ(14)
             Right Thumb -> KEYCODE_BUTTON_THUMBR(107)
             Left Thumb -> KEYCODE_BUTTON_THUMBL(106)
             L1 (Left shoulder) -> KEYCODE_BUTTON_L1(102)
             R1 (Right shoulder) -> KEYCODE_BUTTON_R1(103)
             L2 (Left trigger) -> AXIS_BRAKE(23)
             R2 (Right trigger) -> AXIS_GAS(22)
             X -> KEYCODE_BUTTON_X(99)
             Y -> KEYCODE_BUTTON_Y(100)
             B -> KEYCODE_BUTTON_B(97)
             A -> KEYCODE_BUTTON_A(96)
             DPAD -> AXIS_HAT_X(15),AXIS_HAT_Y(16) or KEYCODE_DPAD_LEFT(21), KEYCODE_DPAD_RIGHT(22), KEYCODE_DPAD_UP(19), KEYCODE_DPAD_DOWN(20),
            Note: On Nvidia Shield Console, L2/R2 additionally invoke key events for AXIS_LTRIGGER, AXIS_RTRIGGER (in addition to AXIS_BRAKE, AXIS_GAS)
                  If you connect gamepad to a phone for L2/R2 only AXIS_BRAKE/AXIS_GAS come. AXIS_LTRIGGER, AXIS_RTRIGGER are not invoked.
                  That's why we map triggers only to AXIS_BRAKE/AXIS_GAS
                  Nvidia Shield also reports KEYCODE_BACK instead of KEYCODE_BUTTON_SELECT, so Options(XboxOne Controller)/View(DualShock)/Select buttons do not work
            PS4 controller is officially supported from Android 10 and higher (https://playstation.com/en-us/support/hardware/ps4-pair-dualshock-4-wireless-with-sony-xperia-and-android)
            However, some devices with older OS have fixed PS4 controller support on their drivers this leads to following situation:
            Some gamepads on Android devices (with same Android number version) might have different mappings
             For ex., Dualshock, on NVidia Shield Console (OS 8.0) all buttons correctly map according to rules in AndroidGameControllerState
                      when clicking left shoulder it will go to AndroidKeyCode.ButtonL1, rightShoulder -> AndroidKeyCode.ButtonR1, etc
                      But, on Samsung Galaxy S9 (OS 8.0), the mapping is different (Same for Xiaomi Mi Note2 (OS 8.0), Samsung Galaxy S8 (OS 7.0))
                      when clicking left shoulder it will go to AndroidKeyCode.ButtonY, rightShoulder -> AndroidKeyCode.ButtonZ, etc
             So even though Android version is 8.0 in both cases, Dualshock will only correctly work on NVidia Shield Console
             It's obvious that this depends on the driver and not Android OS, thus we can only assume Samsung in this case doesn't properly support Dualshock in their drivers
             While we can do custom mapping for Samsung, we can never now when will they try to update the driver for Dualshock or some other gamepad
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidGamepadWithDpadAxes">
            <summary>
            Generic controller with Dpad axes
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidGamepadWithDpadButtons">
            <summary>
            Generic controller with Dpad buttons
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidJoystick">
            <summary>
            Joystick on Android.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.DualShock4GamepadAndroid">
            <summary>
            A PlayStation DualShock 4 controller connected to an Android device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.XboxOneGamepadAndroid">
            <summary>
            A PlayStation DualShock 4 controller connected to an Android device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidAccelerometer">
            <summary>
            Accelerometer device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_ACCELEROMETER"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidMagneticFieldSensor">
            <summary>
            Magnetic field sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_MAGNETIC_FIELD"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidGyroscope">
            <summary>
            Gyroscope device on android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_GYROSCOPE"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidLightSensor">
            <summary>
            Light sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_LIGHT"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidPressureSensor">
            <summary>
            Pressure sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_PRESSURE"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidProximity">
            <summary>
            Proximity sensor type on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_PROXIMITY"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidGravitySensor">
            <summary>
            Gravity sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_GRAVITY"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidLinearAccelerationSensor">
            <summary>
            Linear acceleration sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_LINEAR_ACCELERATION"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidRotationVector">
            <summary>
            Rotation vector sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_ROTATION_VECTOR"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidRelativeHumidity">
            <summary>
            Relative humidity sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_RELATIVE_HUMIDITY"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidAmbientTemperature">
            <summary>
            Ambient temperature sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_AMBIENT_TEMPERATURE"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidStepCounter">
            <summary>
            Step counter sensor device on Android.
            </summary>
            <seealso href="https://developer.android.com/reference/android/hardware/Sensor#TYPE_STEP_COUNTER"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Android.AndroidSupport">
            <summary>
            Initializes custom android devices.
            You can use 'adb shell dumpsys input' from terminal to output information about all input devices.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.Haptics.SendHapticImpulseCommand">
            <summary>
            A device command sent to a device to set it's motor rumble amplitude for a set duration.
            </summary>
            <remarks>This is directly used by the <see cref="T:UnityEngine.InputSystem.XR.XRControllerWithRumble"/> class. For clearer details of using this command, see that class.</remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.Haptics.SendHapticImpulseCommand.Create(System.Int32,System.Single,System.Single)">
            <summary>
            Creates a device command that can then be sent to a specific device.
            </summary>
            <param name="motorChannel">The desired motor you want to rumble</param>
            <param name="motorAmplitude">The desired motor amplitude that should be within a [0-1] range.</param>
            <param name="motorDuration">The desired duration of the impulse in seconds.</param>
            <returns>The command that should be sent to the device via <c>InputDevice.ExecuteCommand</c>.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRHMD">
            <summary>
            The base type of all XR head mounted displays.  This can help organize shared behaviour across all HMDs.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRController">
            <summary>
            The base type for all XR handed controllers.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.XRController.leftHand">
            <summary>
            A quick accessor for the currently active left handed device.
            </summary>
            <remarks>If there is no left hand connected, this will be null. This also matches any currently tracked device that contains the 'LeftHand' device usage.</remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.XRController.rightHand">
            <summary>
            A quick accessor for the currently active right handed device.  This is also tracked via usages on the device.
            </summary>
            <remarks>If there is no left hand connected, this will be null. This also matches any currently tracked device that contains the 'RightHand' device usage.</remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRControllerWithRumble">
            <summary>
            Identifies a controller that is capable of rumble or haptics.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.TrackedPoseDriver">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.XR.TrackedPoseDriver"/> component applies the current pose value of a tracked device
            to the <see cref="T:UnityEngine.Transform"/> of the <see cref="T:UnityEngine.GameObject"/>.
            <see cref="T:UnityEngine.InputSystem.XR.TrackedPoseDriver"/> can track multiple types of devices including XR HMDs, controllers, and remotes.
            </summary>
            <remarks>
            For <see cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.positionInput"/> and <see cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.rotationInput"/>, if an action is directly defined
            in the <see cref="T:UnityEngine.InputSystem.InputActionProperty"/>, as opposed to a reference to an action externally defined
            in an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>, the action will automatically be enabled and disabled by this
            behavior during <see cref="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnEnable"/> and <see cref="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnDisable"/>. The enabled state for actions
            externally defined must be managed externally from this behavior.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingType">
            <summary>
            Options for which <see cref="T:UnityEngine.Transform"/> properties to update.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.trackingType"/>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingType.RotationAndPosition">
            <summary>
            Update both rotation and position.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingType.RotationOnly">
            <summary>
            Update rotation only.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingType.PositionOnly">
            <summary>
            Update position only.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingStates">
            <summary>
            These bit flags correspond with <c>UnityEngine.XR.InputTrackingState</c>
            but that enum is not used to avoid adding a dependency to the XR module.
            Only the Position and Rotation flags are used by this class, so velocity and acceleration flags are not duplicated here.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingStates.None">
            <summary>
            Position and rotation are not valid.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingStates.Position">
            <summary>
            Position is valid.
            See <c>InputTrackingState.Position</c>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingStates.Rotation">
            <summary>
            Rotation is valid.
            See <c>InputTrackingState.Rotation</c>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.trackingType">
            <summary>
            The tracking type being used by the Tracked Pose Driver
            to control which <see cref="T:UnityEngine.Transform"/> properties to update.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.XR.TrackedPoseDriver.TrackingType"/>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateType">
            <summary>
            Options for which phases of the player loop will update <see cref="T:UnityEngine.Transform"/> properties.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.updateType"/>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onAfterUpdate"/>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateType.UpdateAndBeforeRender">
            <summary>
            Update after the Input System has completed an update and right before rendering.
            This is the recommended and default option to minimize lag for XR tracked devices.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateType.Update">
            <summary>
            Update after the Input System has completed an update except right before rendering.
            </summary>
            <remarks>
            This may be dynamic update, fixed update, or a manual update depending on the Update Mode
            project setting for Input System.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateType.BeforeRender">
            <summary>
            Update after the Input System has completed an update right before rendering.
            </summary>
            <remarks>
            Note that this update mode may not trigger if there are no XR devices added which use before render timing.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.updateType">
            <summary>
            The update type being used by the Tracked Pose Driver
            to control which phases of the player loop will update <see cref="T:UnityEngine.Transform"/> properties.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateType"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.ignoreTrackingState">
            <summary>
            Ignore tracking state and always treat the input pose as valid when updating the <see cref="T:UnityEngine.Transform"/> properties.
            The recommended value is <see langword="false"/> so the tracking state input is used.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.trackingStateInput"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.positionInput">
            <summary>
            The input action to read the position value of a tracked device.
            Must support reading a value of type <see cref="T:UnityEngine.Vector3"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.rotationInput"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.rotationInput">
            <summary>
            The input action to read the rotation value of a tracked device.
            Must support reading a value of type <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.positionInput"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.trackingStateInput">
            <summary>
            The input action to read the tracking state value of a tracked device.
            Identifies if position and rotation have valid data.
            Must support reading a value of type <see cref="T:System.Int32"/>.
            </summary>
            <remarks>
            See [InputTrackingState](xref:UnityEngine.XR.InputTrackingState) enum for values the input action represents.
            <list type="bullet">
            <item>
            <term>[InputTrackingState.None](xref:UnityEngine.XR.InputTrackingState.None) (0)</term>
            <description>to indicate neither position nor rotation is valid.</description>
            </item>
            <item>
            <term>[InputTrackingState.Position](xref:UnityEngine.XR.InputTrackingState.Position) (1)</term>
            <description>to indicate position is valid.</description>
            </item>
            <item>
            <term>[InputTrackingState.Rotation](xref:UnityEngine.XR.InputTrackingState.Rotation) (2)</term>
            <description>to indicate rotation is valid.</description>
            </item>
            <item>
            <term>[InputTrackingState.Position](xref:UnityEngine.XR.InputTrackingState.Position) <c>|</c> [InputTrackingState.Rotation](xref:UnityEngine.XR.InputTrackingState.Rotation) (3)</term>
            <description>to indicate position and rotation is valid.</description>
            </item>
            </list>
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.ignoreTrackingState"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.Reset">
            <summary>
            This function is called when the user hits the Reset button in the Inspector's context menu
            or when adding the component the first time. This function is only called in editor mode.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.Awake">
            <summary>
            This function is called when the script instance is being loaded.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnEnable">
            <summary>
            This function is called when the object becomes enabled and active.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnDisable">
            <summary>
            This function is called when the object becomes disabled or inactive.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnDestroy">
            <summary>
            This function is called when the <see cref="T:UnityEngine.MonoBehaviour"/> will be destroyed.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.UpdateCallback">
            <summary>
            The callback method called after the Input System has completed an update and processed all pending events.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onAfterUpdate"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnUpdate">
            <summary>
            This method is called after the Input System has completed an update and processed all pending events
            when the type of update is not <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.OnBeforeRender">
            <summary>
            This method is called after the Input System has completed an update and processed all pending events
            when the type of update is <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.PerformUpdate">
            <summary>
            Updates <see cref="T:UnityEngine.Transform"/> properties with the current input pose values that have been read,
            constrained by tracking type and tracking state.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.SetLocalTransform(UnityEngine.Vector3,UnityEngine.Quaternion)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.SetLocalTransform(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Updates <see cref="T:UnityEngine.Transform"/> properties, constrained by tracking type and tracking state.
            </summary>
            <param name="newPosition">The new local position to possibly set.</param>
            <param name="newRotation">The new local rotation to possibly set.</param>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.positionAction">
            <summary>
            (Deprecated) The action to read the position value of a tracked device.
            Must support reading a value of type <see cref="T:UnityEngine.Vector3"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.positionInput"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.rotationAction">
            <summary>
            (Deprecated) The action to read the rotation value of a tracked device.
            Must support reading a value of type <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.XR.TrackedPoseDriver.rotationInput"/>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.TrackedPoseDriver.m_HasMigratedActions">
            <summary>
            Stores whether the fields of type <see cref="T:UnityEngine.InputSystem.InputAction"/> have been migrated to fields of type <see cref="T:UnityEngine.InputSystem.InputActionProperty"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.XR.TrackedPoseDriver.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRUtilities">
            <summary>
            A set of static utilities for registering XR Input Devices externally.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRUtilities.InterfaceMatchAnyVersion">
            <summary>
            A simple Regex pattern that allows InputDeviceMatchers to match to any version of the XRInput interface.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRUtilities.InterfaceV1">
            <summary>
            The initial, now deprecated interface for XRInput.  This version handles button packing for Android differently from current.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRUtilities.InterfaceCurrent">
            <summary>
            The current interface code sent with devices to identify as XRInput devices.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.FeatureType">
            <summary>
            The type of data a <see cref="T:UnityEngine.InputSystem.XR.XRFeatureDescriptor"/> exposes.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.UsageHint">
            <summary>
            Contextual strings that identify the contextual, cross-platform use that a feature represents.  <see cref="T:UnityEngine.XR.CommonUsages"/> for a list of unity's built-in shared usages.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRFeatureDescriptor">
            <summary>
            Describes an individual input on a device, such as a trackpad, or button, or trigger.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRFeatureDescriptor.name">
            <summary>
            The name of the feature.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRFeatureDescriptor.usageHints">
            <summary>
            The uses that this feature should represent, such as trigger, or grip, or touchpad.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRFeatureDescriptor.featureType">
            <summary>
            The type of data this feature exposes.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRFeatureDescriptor.customSize">
            <summary>
            The overall size of the feature.  This is only filled in when the <see cref="F:UnityEngine.InputSystem.XR.XRFeatureDescriptor.featureType"/> is <see cref="F:UnityEngine.InputSystem.XR.FeatureType.Custom"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRDeviceDescriptor">
            <summary>
            Describes an input device: what it can do and how it should be used.  These are reported during device connection, and help identify devices and map input data to the right controls.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.deviceName">
            <summary>
            The name of the device.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.manufacturer">
            <summary>
            The manufacturer of the device.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.serialNumber">
            <summary>
            The serial number of the device.  An empty string if no serial number is available.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.characteristics">
            <summary>
            The capabilities of the device, used to help filter and identify devices that server a certain purpose (e.g. controller, or headset, or hardware tracker).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.deviceId">
            <summary>
            The underlying deviceId, this can be used with <see cref="T:UnityEngine.XR.InputDevices"/> to create a device.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.XRDeviceDescriptor.inputFeatures">
            <summary>
            A list of all input features.  <seealso cref="T:UnityEngine.InputSystem.XR.XRFeatureDescriptor"/>
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.XRDeviceDescriptor.ToJson">
            <summary>
            Converts this structure to a JSON string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.XRDeviceDescriptor.FromJson(System.String)">
            <summary>
            Converts a json string to a new <see cref="T:UnityEngine.InputSystem.XR.XRDeviceDescriptor"/>.
            </summary>
            <param name="json">The JSON string containing <see cref="T:UnityEngine.InputSystem.XR.XRDeviceDescriptor"/> data.</param>
            <returns>A new <see cref="T:UnityEngine.InputSystem.XR.XRDeviceDescriptor"/></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.Bone">
            <summary>
            Represents a 3 dimensional, tracked bone within a hierarchy of other bones.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Bone.m_ParentBoneIndex">
            <summary>
            The index with the device's controls array where the parent bone resides.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Bone.m_Position">
            <summary>
            The tracked position of the bone.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Bone.m_Rotation">
            <summary>
            The tracked rotation of the bone.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Bone.parentBoneIndex">
            <summary>
            The index with the device's controls array where the parent bone resides.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Bone.position">
            <summary>
            The tracked position of the bone.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Bone.rotation">
            <summary>
            The tracked rotation of the bone.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.Eyes">
            <summary>
            Represents a pair of tracked eyes.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_LeftEyePosition">
            <summary>
            The tracked position of the left eye.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_LeftEyeRotation">
            <summary>
            The tracked rotation of the left eye.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_RightEyePosition">
            <summary>
            The tracked position of the right eye.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_RightEyeRotation">
            <summary>
            The tracked rotation of the right eye.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_FixationPoint">
            <summary>
            The point in 3D space that the pair of eyes is looking.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_LeftEyeOpenAmount">
            <summary>
            The amount [0-1] the left eye is open or closed.  1.0 is fully open.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.Eyes.m_RightEyeOpenAmount">
            <summary>
            The amount [0-1] the right eye is open or closed.  1.0 is fully open.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.leftEyePosition">
            <summary>
            The tracked position of the left eye.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.leftEyeRotation">
            <summary>
            The tracked rotation of the left eye.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.rightEyePosition">
            <summary>
            The tracked position of the right eye.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.rightEyeRotation">
            <summary>
            The tracked rotation of the right eye.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.fixationPoint">
            <summary>
            The point in 3D space that the pair of eyes is looking.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.leftEyeOpenAmount">
            <summary>
            The amount [0-1] the left eye is open or closed.  1.0 is fully open.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.Eyes.rightEyeOpenAmount">
            <summary>
            The amount [0-1] the right eye is open or closed.  1.0 is fully open.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.XRSupport">
            <summary>
            A small helper class to aid in initializing and registering XR devices and layout builders.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.XRSupport.Initialize">
            <summary>
            Registers all initial templates and the generalized layout builder with the InputSystem.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.PoseState">
            <summary>
            State layout for a single pose.
            </summary>
            <remarks>
            This is the low-level memory representation of a single pose, i.e the
            way poses are internally transmitted and stored in the system. PoseStates are used on devices containing <see cref="T:UnityEngine.InputSystem.XR.PoseControl"/>s.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.XR.PoseControl"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseState.format">
            <summary>
            Memory format tag for PoseState.
            </summary>
            <value>Returns "Pose".</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.PoseState.#ctor(System.Boolean,UnityEngine.XR.InputTrackingState,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3,UnityEngine.Vector3)">
             <summary>
             Constructor for PoseStates.
            
             Useful for creating PoseStates locally (not from <see cref="T:UnityEngine.InputSystem.XR.PoseControl"/>).
             </summary>
             <param name="isTracked">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.isTracked"/></param>
             <param name="trackingState">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/></param>
             <param name="position">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.position"/></param>
             <param name="rotation">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.rotation"/></param>
             <param name="velocity">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.velocity"/></param>
             <param name="angularVelocity">Value to use for <see cref="F:UnityEngine.InputSystem.XR.PoseState.angularVelocity"/></param>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.isTracked">
            <summary>
            Whether the pose is currently being fully tracked. Otherwise, the tracking is either unavailable, or simulated.
            </summary>
            <remarks>
            Fully tracked means that the pose is accurate and not using any simulated or extrapolated positions, and the system tracking this pose is able to confidently track this object.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.trackingState">
            <summary>
            A Flags Enumeration specifying which other fields in the pose state are valid.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.position">
            <summary>
            The position in 3D space, relative to the tracking origin where this pose represents.
            </summary>
            <remarks>
            Positions are represented in meters.
            This field is only valid if <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/> contains the <see cref="F:UnityEngine.XR.InputTrackingState.Position"/> value.
            See <seealso cref="T:UnityEngine.XR.TrackingOriginModeFlags"/> for information on tracking origins.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.rotation">
            <summary>
            The rotation in 3D space, relative to the tracking origin where this pose represents.
            </summary>
            <remarks>
            This field is only valid if <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/> contains the <see cref="F:UnityEngine.XR.InputTrackingState.Rotation"/> value.
            See <seealso cref="T:UnityEngine.XR.TrackingOriginModeFlags"/> for information on tracking origins.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.velocity">
            <summary>
            The velocity in 3D space, relative to the tracking origin where this pose represents.
            </summary>
            <remarks>
            Velocities are represented in meters per second.
            This field is only valid if <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/> contains the <see cref="F:UnityEngine.XR.InputTrackingState.Velocity"/> value.
            See <seealso cref="T:UnityEngine.XR.TrackingOriginModeFlags"/> for information on tracking origins.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.XR.PoseState.angularVelocity">
            <summary>
            The angular velocity in 3D space, relative to the tracking origin where this pose represents.
            </summary>
            <remarks>
            This field is only valid if <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/> contains the <see cref="F:UnityEngine.XR.InputTrackingState.AngularVelocity"/> value.
            See <seealso cref="T:UnityEngine.XR.TrackingOriginModeFlags"/> for information on tracking origins.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XR.PoseControl">
             <summary>
             A control representing a Pose in 3D space, relative to an XR tracking origin
             </summary>
             <remarks>
             Note that unlike most other control types, <c>PoseControls</c> do not have
             a flexible memory layout. They are hardwired to <see cref="T:UnityEngine.InputSystem.XR.PoseState"/> and
             will not work correctly with a different memory layouts. Additional fields may
             be appended to the struct but what's there in the struct has to be located
             at exactly those memory addresses.
            
             For more information on tracking origins see <see cref="T:UnityEngine.XR.TrackingOriginModeFlags"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.isTracked">
            <summary>
            Represents whether this pose is fully tracked or unavailable/simulated.
            </summary>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.isTracked"/> value.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.isTracked"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.trackingState">
            <summary>
            The other controls on this <see cref="T:UnityEngine.InputSystem.XR.PoseControl"/> that are currently reporting data.
            </summary>
            <remarks>
            This can be missing values when the device tracking this pose is restricted or not tracking properly.
            </remarks>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/> value of the pose retrieved from this control.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.trackingState"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.position">
            <summary>
            The position, in meters, of this tracked pose relative to the tracking origin.
            </summary>
            <remarks>
            The data for this control is only valid if the value returned from <see cref="P:UnityEngine.InputSystem.XR.PoseControl.trackingState"/> contains <see cref="F:UnityEngine.XR.InputTrackingState.Position"/> value.
            </remarks>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.position"/> value of the pose retrieved from this control.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.position"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.rotation">
            <summary>
            The rotation of this tracked pose relative to the tracking origin.
            </summary>
            <remarks>
            The data for this control is only valid if the value returned from <see cref="P:UnityEngine.InputSystem.XR.PoseControl.trackingState"/> contains <see cref="F:UnityEngine.XR.InputTrackingState.Rotation"/> value.
            </remarks>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.rotation"/> value of the pose retrieved from this control.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.rotation"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.velocity">
            <summary>
            The velocity, in meters per second, of this tracked pose relative to the tracking origin.
            </summary>
            <remarks>
            The data for this control is only valid if the value returned from <see cref="P:UnityEngine.InputSystem.XR.PoseControl.trackingState"/> contains <see cref="F:UnityEngine.XR.InputTrackingState.Velocity"/> value.
            </remarks>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.velocity"/> value of the pose retrieved from this control.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.velocity"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XR.PoseControl.angularVelocity">
            <summary>
            The angular velocity of this tracked pose relative to the tracking origin.
            </summary>
            <remarks>
            The data for this control is only valid if the value returned from <see cref="P:UnityEngine.InputSystem.XR.PoseControl.trackingState"/> contains <see cref="F:UnityEngine.XR.InputTrackingState.AngularVelocity"/> value.
            </remarks>
            <value>Control representing whether the pose is being fully tracked. Maps to the <see cref="F:UnityEngine.InputSystem.XR.PoseState.angularVelocity"/> value of the pose retrieved from this control.</value>
            <seealso cref="F:UnityEngine.InputSystem.XR.PoseState.angularVelocity"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.PoseControl.#ctor">
            <summary>
            Default-initialize the pose control.
            </summary>
            <remarks>
            Sets the <see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/> to <c>"Pose"</c>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.XR.PoseControl.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.XR.PoseControl.ReadUnprocessedValueFromState(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.XR.PoseControl.WriteValueIntoState(UnityEngine.InputSystem.XR.PoseState,System.Void*)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor">
            <summary>
            Processes a Vector2 to apply deadzoning according to the magnitude of the vector (rather
            than just clamping individual axes). Normalizes to the min/max range.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor.min">
            <summary>
            Value at which the lower bound deadzone starts.
            </summary>
            <remarks>
            Values in the input at or below min will get dropped and values
            will be scaled to the range between min and max.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.EditorWindowSpaceProcessor">
             <summary>
             If Unity is currently in an <see cref="T:UnityEditor.EditorWindow"/> callback, transforms a 2D coordinate from
             player window space into window space of the current EditorWindow.
             </summary>
             <remarks>
             This processor is only available in the editor. Also, it only works on devices that
             support the <see cref="T:UnityEngine.InputSystem.LowLevel.QueryEditorWindowCoordinatesCommand"/> request.
            
             Outside of <see cref="T:UnityEditor.EditorWindow"/> callbacks, this processor does nothing and just passes through
             the coordinates it receives.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Pointer.position"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.EditorWindowSpaceProcessor.Process(UnityEngine.Vector2,UnityEngine.InputSystem.InputControl)">
            <summary>
            Transform the given player screen-space coordinate into the coordinate space of the current
            <c>EditorWindow</c>.
            </summary>
            <param name="value">GameView screen space coordinate.</param>
            <param name="control">Ignored.</param>
            <returns>The given coordinate transformed into <c>EditorWindow</c> space.</returns>
            <remarks>
            This method will only succeed if the editor is currently in an <c>EditorWindow</c> callback such
            as <c>OnGUI</c>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.ScaleVector2Processor">
             <summary>
             Scale the components of a <see cref="T:UnityEngine.Vector2"/> by constant factors.
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "scaleVector2".
            
             <example>
             <code>
             // Double the length of the vector produced by leftStick on gamepad.
             myAction.AddBinding("&lt;Gamepad&gt;/leftStick").WithProcessor("scaleVector2(x=2,y=2)");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleProcessor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleVector3Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleVector2Processor.x">
            <summary>
            Scale factor to apply to the vector's <c>x</c> axis. Defaults to 1.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleVector2Processor.y">
            <summary>
            Scale factor to apply to the vector's <c>y</c> axis. Defaults to 1.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleVector2Processor.Process(UnityEngine.Vector2,UnityEngine.InputSystem.InputControl)">
            <summary>
            Return <paramref name="value"/> scaled by <see cref="F:UnityEngine.InputSystem.Processors.ScaleVector2Processor.x"/> and <see cref="F:UnityEngine.InputSystem.Processors.ScaleVector2Processor.y"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleVector2Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.InvertProcessor">
             <summary>
             An input processor that inverts its input value.
             </summary>
             <remarks>
             This process is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/> as "invert" by default.
            
             <example>
             <code>
             // Bind to the gamepad's left trigger such that it returns inverted values.
             new InputAction(binding: "&lt;Gamepad&gt;/leftTrigger", processors="invert");
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)">
            <summary>
            Return the inverted value of <paramref name="value"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Invert value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertProcessor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.NormalizeVector3Processor">
            <summary>
            Normalizes a <c>Vector3</c> input value.
            </summary>
            <remarks>
            This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "normalizeVector3".
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Processors.NormalizeVector2Processor"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeVector3Processor.Process(UnityEngine.Vector3,UnityEngine.InputSystem.InputControl)">
            <summary>
            Normalize <paramref name="value"/>. Performs the equivalent of <c>value.normalized</c>.
            </summary>
            <param name="value">Input vector.</param>
            <param name="control">Ignored.</param>
            <returns>Normalized vector.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeVector3Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.InvertVector3Processor">
             <summary>
             Inverts the <c>x</c> and/or <c>y</c> and/or <c>z</c> channel of a <c>Vector3</c>.
             </summary>
             <remarks>
             This process is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/> as "invertVector3" by default.
            
             <example>
             <code>
             // Bind to gravity sensor such that its Y value is inverted.
             new InputAction(binding: "&lt;GravitySensor&gt;/gravity", processors="invertVector3(invertX=false,invertY,invertZ=false)");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.InvertVector2Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertX">
            <summary>
            If true, the <c>x</c> channel of the <c>Vector3</c> input value is inverted. True by default.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertY">
            <summary>
            If true, the <c>y</c> channel of the <c>Vector3</c> input value is inverted. True by default.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertZ">
            <summary>
            If true, the <c>z</c> channel of the <c>Vector3</c> input value is inverted. True by default.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertVector3Processor.Process(UnityEngine.Vector3,UnityEngine.InputSystem.InputControl)">
            <summary>
            Return the given vector with the respective channels being inverted.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Vector with channels inverted according to <see cref="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertX"/>, <see cref="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertY"/>, and <see cref="F:UnityEngine.InputSystem.Processors.InvertVector3Processor.invertZ"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertVector3Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.NormalizeProcessor">
             <summary>
             Normalizes input values in the range <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/> to
             unsigned normalized form [0..1] if <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.zero"/> is placed at (or below) <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/>
             or to signed normalized form [-1..1] if <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.zero"/> is placed in-between
             <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/>.
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "normalize".
            
             Note that this processor does not clamp the incoming value to <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/>.
             To achieve this, either add a <see cref="T:UnityEngine.InputSystem.Processors.ClampProcessor"/> or use <see cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>
             which combines clamping and normalizing.
            
             <example>
             <code>
             </code>
             // Bind to right trigger on gamepad such that the value values below 0.3 and above 0.7 get normalized
             // to values between [0..1].
             new InputAction(binding: "&lt;Gamepad&gt;/rightTrigger", processors: "normalize(min=0.3,max=0.7)");
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.NormalizeVector2Processor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.NormalizeVector3Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min">
            <summary>
            Input value (inclusive) that corresponds to 0 or -1 (depending on <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.zero"/>), the lower bound.
            </summary>
            <remarks>
            If the input value drops below min, the result is undefined.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max">
            <summary>
            Input value (inclusive) that corresponds to 1, the upper bound.
            </summary>
            <remarks>
            If the input value goes beyond max, the result is undefined.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.zero">
            <summary>
            Input value that corresponds to 0. If this is placed at or below <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/>, the resulting normalization
            returns a [0..1] value. If this is placed in-between <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/>, the resulting
            normalization returns a [-1..1] value.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)">
            <summary>
            Normalize <paramref name="value"/> with respect to <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Normalized value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeProcessor.Normalize(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Normalize <paramref name="value"/> with respect to <paramref name="min"/> and <paramref name="max"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="min">Lower bound. See <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.min"/>.</param>
            <param name="max">Upper bound. See <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.max"/>.</param>
            <param name="zero">Zero point. See <see cref="F:UnityEngine.InputSystem.Processors.NormalizeProcessor.zero"/>.</param>
            <returns>Normalized value.</returns>
            <remarks>
            This method performs the same function as <see cref="M:UnityEngine.InputSystem.Processors.NormalizeProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)"/>.
            <example>
            <code>
            // Normalize 2 against a [1..5] range. Returns 0.25.
            NormalizeProcessor.Normalize(2, 1, 5, 1)
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeProcessor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.InvertVector2Processor">
             <summary>
             Inverts the <c>x</c> and/or <c>y</c> channel of a <c>Vector2</c>.
             </summary>
             <remarks>
             This process is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/> as "invertVector2" by default.
            
             <example>
             <code>
             // Bind to the left stick on the gamepad such that its Y channel is inverted.
             new InputAction(binding: "&lt;Gamepad&gt;/leftStick", processors="invertVector2(invertY,invertX=false)");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.InvertVector3Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.InvertVector2Processor.invertX">
            <summary>
            If true, the <c>x</c> channel of the <c>Vector2</c> input value is inverted. True by default.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.InvertVector2Processor.invertY">
            <summary>
            If true, the <c>y</c> channel of the <c>Vector2</c> input value is inverted. True by default.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertVector2Processor.Process(UnityEngine.Vector2,UnityEngine.InputSystem.InputControl)">
            <summary>
            Invert the <c>x</c> and/or <c>y</c> channel of the given <paramref name="value"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Vector2 with inverted channels.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.InvertVector2Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.ScaleProcessor">
             <summary>
             Scale a float value by a constant factor.
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "scale".
            
             <example>
             <code>
             </code>
             // Bind to left trigger on the gamepad such that its values are scaled by a factor of 2.
             new InputAction(binding: "&lt;Gamepad&gt;/leftTrigger", processors: "scale(factor=2)");
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleVector2Processor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleVector3Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleProcessor.factor">
            <summary>
            Scale factor to apply to incoming input values. Defaults to 1 (no scaling).
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)">
            <summary>
            Scale the given <paramref name="value"/> by <see cref="F:UnityEngine.InputSystem.Processors.ScaleProcessor.factor"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Scaled value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleProcessor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.ClampProcessor">
             <summary>
             Clamp a floating-point input to between <see cref="F:UnityEngine.InputSystem.Processors.ClampProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.ClampProcessor.max"/>. This is equivalent
             to <c>Mathf.Clamp(value, min, max)</c>.
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "clamp" by default.
            
             Note that no normalization is performed. If you want to re-normalize the input value after clamping,
             add a <see cref="T:UnityEngine.InputSystem.Processors.NormalizeProcessor"/>. Alternatively, add a <see cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/> which
             both clamps and normalizes.
            
             <example>
             <code>
             </code>
             // Bind to right trigger on gamepad such that the value never drops below 0.3 and never goes
             // above 0.7.
             new InputAction(binding: "&lt;Gamepad&gt;/rightTrigger", processors: "clamp(min=0.3,max=0.7)");
             </example>
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ClampProcessor.min">
            <summary>
            Minimum value (inclusive!) of the accepted value range.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ClampProcessor.max">
            <summary>
            Maximum value (inclusive!) of the accepted value range.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ClampProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)">
            <summary>
            Clamp <paramref name="value"/> to the range of <see cref="F:UnityEngine.InputSystem.Processors.ClampProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.ClampProcessor.max"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Clamped value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ClampProcessor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor">
             <summary>
             Clamps values to the range given by <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.max"/> and re-normalizes the resulting
             value to [0..1].
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "AxisDeadzone".
            
             It acts like a combination of <see cref="T:UnityEngine.InputSystem.Processors.ClampProcessor"/> and <see cref="T:UnityEngine.InputSystem.Processors.NormalizeProcessor"/>.
            
             <example>
             <code>
             </code>
             // Bind to right trigger on gamepad such that the value is clamped and normalized between
             // 0.3 and 0.7.
             new InputAction(binding: "&lt;Gamepad&gt;/rightTrigger", processors: "axisDeadzone(min=0.3,max=0.7)");
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.min">
            <summary>
            Lower bound (inclusive) below which input values get clamped. Corresponds to 0 in the normalized range.
            </summary>
            <remarks>
            If this is equal to 0 (the default), <see cref="P:UnityEngine.InputSystem.InputSettings.defaultDeadzoneMin"/> is used instead.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.max">
            <summary>
            Upper bound (inclusive) beyond which input values get clamped. Corresponds to 1 in the normalized range.
            </summary>
            <remarks>
            If this is equal to 0 (the default), <see cref="P:UnityEngine.InputSystem.InputSettings.defaultDeadzoneMax"/> is used instead.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.Process(System.Single,UnityEngine.InputSystem.InputControl)">
            <summary>
            Normalize <paramref name="value"/> according to <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.min"/> and <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.max"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Normalized value.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.ScaleVector3Processor">
             <summary>
             Scale the components of a <see cref="T:UnityEngine.Vector3"/> by constant factors.
             </summary>
             <remarks>
             This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "scaleVector3".
            
             <example>
             <code>
             // Double the magnitude of gravity values read from a gravity sensor.
             myAction.AddBinding("&lt;GravitySensor&gt;/gravity").WithProcessor("scaleVector3(x=2,y=2,z=2)");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleProcessor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.ScaleVector2Processor"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.x">
            <summary>
            Scale factor to apply to the vector's <c>x</c> axis. Defaults to 1.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.y">
            <summary>
            Scale factor to apply to the vector's <c>y</c> axis. Defaults to 1.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.z">
            <summary>
            Scale factor to apply to the vector's <c>z</c> axis. Defaults to 1.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleVector3Processor.Process(UnityEngine.Vector3,UnityEngine.InputSystem.InputControl)">
            <summary>
            Return <paramref name="value"/> scaled by <see cref="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.x"/>, <see cref="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.y"/>, and <see cref="F:UnityEngine.InputSystem.Processors.ScaleVector3Processor.z"/>.
            </summary>
            <param name="value">Input value.</param>
            <param name="control">Ignored.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.ScaleVector3Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.Processors.NormalizeVector2Processor">
            <summary>
            Normalizes a <c>Vector2</c> input value.
            </summary>
            <remarks>
            This processor is registered (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) under the name "normalizeVector2".
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Processors.NormalizeVector3Processor"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeVector2Processor.Process(UnityEngine.Vector2,UnityEngine.InputSystem.InputControl)">
            <summary>
            Normalize <paramref name="value"/>. Performs the equivalent of <c>value.normalized</c>.
            </summary>
            <param name="value">Input vector.</param>
            <param name="control">Ignored.</param>
            <returns>Normalized vector.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Processors.NormalizeVector2Processor.ToString">
            <inheritdoc/>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.MultiplayerEventSystem">
            <summary>
            A modified EventSystem class, which allows multiple players to have their own instances of a UI,
            each with it's own selection.
            </summary>
            <remarks>
            You can use the <see cref="P:UnityEngine.InputSystem.UI.MultiplayerEventSystem.playerRoot"/> property to specify a part of the hierarchy belonging to the current player.
            Mouse selection will ignore any game objects not within this hierarchy, and all other navigation, using keyboard or
            gamepad for example, will be constrained to game objects under that hierarchy.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.MultiplayerEventSystem.playerRoot">
            <summary>
            The root object of the UI hierarchy that belongs to the given player.
            </summary>
            <remarks>
            This can either be an entire <c>Canvas</c> or just part of the hierarchy of
            a specific <c>Canvas</c>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.TrackedDeviceRaycaster">
            <summary>
            Raycasting implementation for use with <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>s.
            </summary>
            <remarks>
            This component needs to be added alongside the <c>Canvas</c> component. Usually, raycasting is
            performed by the <c>GraphicRaycaster</c> component found there but for 3D raycasting necessary for
            tracked devices, this component is required.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.VirtualMouseInput">
             <summary>
             A component that creates a virtual <see cref="T:UnityEngine.InputSystem.Mouse"/> device and drives its input from gamepad-style inputs. This effectively
             adds a software mouse cursor.
             </summary>
             <remarks>
             This component can be used with UIs that are designed for mouse input, i.e. need to be operated with a cursor.
             By hooking up the <see cref="T:UnityEngine.InputSystem.InputAction"/>s of this component to gamepad input and directing <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorTransform"/>
             to the UI transform of the cursor, you can use this component to drive an on-screen cursor.
            
             Note that this component does not actually trigger UI input itself. Instead, it creates a virtual <see cref="T:UnityEngine.InputSystem.Mouse"/>
             device which can then be picked up elsewhere (such as by <see cref="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule"/>) where mouse/pointer input
             is expected.
            
             Also note that if there is a <see cref="T:UnityEngine.InputSystem.Mouse"/> added by the platform, it is not impacted by this component. More specifically,
             the system mouse cursor will not be moved or otherwise used by this component.
            
             Input from the component is visible in the same frame as the source input on its actions by virtue of using <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.Change(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.LowLevel.InputUpdateType)"/>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Gamepad"/>
             <seealso cref="T:UnityEngine.InputSystem.Mouse"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorTransform">
            <summary>
            Optional transform that will be updated to correspond to the current mouse position.
            </summary>
            <value>Transform to update with mouse position.</value>
            <remarks>
            This is useful for having a UI object that directly represents the mouse cursor. Simply add both the
            <c>VirtualMouseInput</c> component and an <a href="https://docs.unity3d.com/Manual/script-Image.html">Image</a>
            component and hook the <a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">RectTransform</a>
            component for the UI object into here. The object as a whole will then follow the generated mouse cursor
            motion.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorSpeed">
            <summary>
            How many pixels per second the cursor travels in one axis when the respective axis from
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.stickAction"/> is 1.
            </summary>
            <value>Mouse speed in pixels per second.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorMode">
             <summary>
             Determines which cursor representation to use. If this is set to <see cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.SoftwareCursor"/>
             (the default), then <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorGraphic"/> and <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorTransform"/> define a software cursor
             that is made to correspond to the position of <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>. If this is set to <see
             cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.HardwareCursorIfAvailable"/> and there is a native <see cref="T:UnityEngine.InputSystem.Mouse"/> device present,
             the component will take over that mouse device and disable it (so as for it to not also generate position
             updates). It will then use <see cref="M:UnityEngine.InputSystem.Mouse.WarpCursorPosition(UnityEngine.Vector2)"/> to move the system mouse cursor to
             correspond to the position of the <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>. In this case, <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorGraphic"/>
             will be disabled and <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorTransform"/> will not be updated.
             </summary>
             <value>Whether the system mouse cursor (if present) should be made to correspond with the virtual mouse position.</value>
             <remarks>
             Note that regardless of which mode is used for the cursor, mouse input is expected to be picked up from <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            
             Note that if <see cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.HardwareCursorIfAvailable"/> is used, the software cursor is still used
             if no native <see cref="T:UnityEngine.InputSystem.Mouse"/> device is present.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorGraphic">
             <summary>
             The UI graphic element that represents the mouse cursor.
             </summary>
             <value>Graphic element for the software mouse cursor.</value>
             <remarks>
             If <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorMode"/> is set to <see cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.HardwareCursorIfAvailable"/>, this graphic will
             be disabled.
            
             Also, this UI component implicitly determines the <c>Canvas</c> that defines the screen area for the cursor.
             The canvas that this graphic is on will be looked up using <c>GetComponentInParent</c> and then the <c>Canvas.pixelRect</c>
             of the canvas is used as the bounds for the cursor motion range.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.SoftwareCursor"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.scrollSpeed">
            <summary>
            Multiplier for values received from <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.scrollWheelAction"/>.
            </summary>
            <value>Multiplier for scroll values.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse">
            <summary>
            The virtual mouse device that the component feeds with input.
            </summary>
            <value>Instance of virtual mouse or <c>null</c>.</value>
            <remarks>
            This is only initialized after the component has been enabled for the first time. Note that
            when subsequently disabling the component, the property will continue to return the mouse device
            but the device will not be added to the system while the component is not enabled.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.stickAction">
            <summary>
            The Vector2 stick input that drives the mouse cursor, i.e. <see cref="P:UnityEngine.InputSystem.Pointer.position"/> on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/> and the <a
            href="https://docs.unity3d.com/ScriptReference/RectTransform-anchoredPosition.html">anchoredPosition</a>
            on <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorTransform"/> (if set).
            </summary>
            <value>Stick input that drives cursor position.</value>
            <remarks>
            This should normally be bound to controls such as <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> and/or
            <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.leftButtonAction">
            <summary>
            Optional button input that determines when <see cref="P:UnityEngine.InputSystem.Mouse.leftButton"/> is pressed on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.leftButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.rightButtonAction">
            <summary>
            Optional button input that determines when <see cref="P:UnityEngine.InputSystem.Mouse.rightButton"/> is pressed on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.rightButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.middleButtonAction">
            <summary>
            Optional button input that determines when <see cref="P:UnityEngine.InputSystem.Mouse.middleButton"/> is pressed on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.middleButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.forwardButtonAction">
            <summary>
            Optional button input that determines when <see cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/> is pressed on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.backButtonAction">
            <summary>
            Optional button input that determines when <see cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/> is pressed on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.forwardButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.VirtualMouseInput.scrollWheelAction">
            <summary>
            Optional Vector2 value input that determines the value of <see cref="P:UnityEngine.InputSystem.Mouse.scroll"/> on
            <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.virtualMouse"/>.
            </summary>
            <value>Input for <see cref="P:UnityEngine.InputSystem.Mouse.scroll"/>.</value>
            <remarks>
            In case you want to only bind vertical scrolling, simply have a <see cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/>
            with only <c>Up</c> and <c>Down</c> bound and <c>Left</c> and <c>Right</c> deleted or bound to nothing.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode">
            <summary>
            Determines how the cursor for the virtual mouse is represented.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorMode"/>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.SoftwareCursor">
            <summary>
            The cursor is represented as a UI element. See <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorGraphic"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.HardwareCursorIfAvailable">
             <summary>
             If a native <see cref="T:UnityEngine.InputSystem.Mouse"/> device is present, its cursor will be used and driven
             by the virtual mouse using <see cref="M:UnityEngine.InputSystem.Mouse.WarpCursorPosition(UnityEngine.Vector2)"/>. The software cursor
             referenced by <see cref="P:UnityEngine.InputSystem.UI.VirtualMouseInput.cursorGraphic"/> will be disabled.
            
             Note that if no native <see cref="T:UnityEngine.InputSystem.Mouse"/> is present, behavior will fall back to
             <see cref="F:UnityEngine.InputSystem.UI.VirtualMouseInput.CursorMode.SoftwareCursor"/>.
             </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.ExtendedPointerEventData">
             <summary>
             An extension to <c>PointerEventData</c> which makes additional data about the input event available.
             </summary>
             <remarks>
             Instances of this class are sent instead of <see cref="T:UnityEngine.EventSystems.PointerEventData"/>  by <see cref="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule"/>
             for all pointer-type input.
            
             The <see cref="P:UnityEngine.EventSystems.PointerEventData.pointerId"/> property will generally correspond to the <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
             of <see cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.device"/>. An exception to this are touches as each <see cref="T:UnityEngine.InputSystem.Touchscreen"/> may generate several pointers
             (one for each active finger).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.control">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputControl"/> that generated the pointer input.
            The device associated with this control should be the same as this event's device.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.device"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.device">
            <summary>
            The <see cref="T:UnityEngine.InputSystem.InputDevice"/> that generated the pointer input.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Pointer"/>
            <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
            <seealso cref="T:UnityEngine.InputSystem.Mouse"/>
            <seealso cref="T:UnityEngine.InputSystem.Pen"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.touchId">
             <summary>
             For <see cref="F:UnityEngine.InputSystem.UI.UIPointerType.Touch"/> type pointer input, this is the touch ID as reported by the
             <see cref="T:UnityEngine.InputSystem.Touchscreen"/> device.
             </summary>
             <remarks>
             For pointer input that is not coming from touch, this will be 0 (which is not considered a valid touch ID
             by the input system).
            
             Note that for touch input, <see cref="P:UnityEngine.EventSystems.PointerEventData.pointerId"/> will be a combination of the
             device ID of <see cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.device"/> and the touch ID to generate a unique pointer ID even if there
             are multiple touchscreens.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.pointerType">
            <summary>
            Type of pointer that generated the input.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.trackedDevicePosition">
            <summary>
            For <see cref="F:UnityEngine.InputSystem.UI.UIPointerType.Tracked"/> type pointer input, this is the world-space position of
            the <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.trackedDeviceOrientation">
            <summary>
            For <see cref="F:UnityEngine.InputSystem.UI.UIPointerType.Tracked"/> type pointer input, this is the world-space orientation of
            the <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation"/>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.UIPointerType">
            <summary>
            General type of pointer that generated a <see cref="T:UnityEngine.EventSystems.PointerEventData"/> pointer event.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerType.MouseOrPen">
            <summary>
            A <see cref="T:UnityEngine.InputSystem.Mouse"/> or <see cref="T:UnityEngine.InputSystem.Pen"/> or other general <see cref="T:UnityEngine.InputSystem.Pointer"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerType.Touch">
            <summary>
            A <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerType.Tracked">
            <summary>
            A <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.UIPointerBehavior">
            <summary>
            Determine how the UI behaves in the presence of multiple pointer devices.
            </summary>
            <remarks>
            While running, an application may, for example, have both a <see cref="T:UnityEngine.InputSystem.Mouse"/> and a <see cref="T:UnityEngine.InputSystem.Touchscreen"/> device
            and both may end up getting bound to the actions of <see cref="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule"/> and thus both may route
            input into the UI. When this happens, the pointer behavior decides how the UI input module resolves the ambiguity.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerBehavior.SingleMouseOrPenButMultiTouchAndTrack">
             <summary>
             Any input that isn't <see cref="T:UnityEngine.InputSystem.Touchscreen"/> or <see cref="T:UnityEngine.InputSystem.TrackedDevice"/> input is
             treated as a single unified pointer.
            
             This is the default behavior based on the expectation that mice and pens will generally drive a single on-screen
             cursor whereas touch and tracked devices have an inherent ability to generate multiple pointers.
            
             Note that when input from touch or tracked devices is received, the combined pointer for mice and pens (if it exists)
             will be removed. If it was over UI objects, <c>IPointerExitHandler</c>s will be invoked.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerBehavior.SingleUnifiedPointer">
            <summary>
            All input is unified to a single pointer. This means that all input from all pointing devices (<see cref="T:UnityEngine.InputSystem.Mouse"/>,
            <see cref="T:UnityEngine.InputSystem.Pen"/>, <see cref="T:UnityEngine.InputSystem.Touchscreen"/>, and <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>) is routed into a single pointer
            instance. There is only one position on screen which can be controlled from any of these devices.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.UIPointerBehavior.AllPointersAsIs">
            <summary>
            Any pointing device, whether it's <see cref="T:UnityEngine.InputSystem.Mouse"/>, <see cref="T:UnityEngine.InputSystem.Pen"/>, <see cref="T:UnityEngine.InputSystem.Touchscreen"/>,
            or <see cref="T:UnityEngine.InputSystem.TrackedDevice"/> input, is treated as its own independent pointer and arbitrary many
            such pointers can be active at any one time.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule">
             <summary>
             Input module that takes its input from <see cref="T:UnityEngine.InputSystem.InputAction">input actions</see>.
             </summary>
             <remarks>
             This UI input module has the advantage over other such modules that it doesn't have to know
             what devices and types of devices input is coming from. Instead, the actions hide the actual
             sources of input from the module.
            
             When adding this component from code (such as through <c>GameObject.AddComponent</c>), the
             resulting module will automatically have a set of default input actions assigned to it
             (see <see cref="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.AssignDefaultActions"/>).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.deselectOnBackgroundClick">
            <summary>
            Whether to clear the current selection when a click happens that does not hit any <c>GameObject</c>.
            </summary>
            <value>If true (default), clicking outside of any GameObject will reset the current selection.</value>
            <remarks>
            By toggling this behavior off, background clicks will keep the current selection. I.e.
            <c>EventSystem.currentSelectedGameObject</c> will not be changed.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.pointerBehavior">
             <summary>
             How to deal with the presence of pointer-type input from multiple devices.
             </summary>
             <remarks>
             By default, this is set to <see cref="F:UnityEngine.InputSystem.UI.UIPointerBehavior.SingleMouseOrPenButMultiTouchAndTrack"/> which will
             treat input from <see cref="T:UnityEngine.InputSystem.Mouse"/> and <see cref="T:UnityEngine.InputSystem.Pen"/> devices as coming from a single on-screen pointer
             but will treat input from devices such as <see cref="T:UnityEngine.InputSystem.XR.XRController"/> and <see cref="T:UnityEngine.InputSystem.Touchscreen"/> as
             their own discrete pointers.
            
             The primary effect of this setting is to determine whether the user can concurrently point at more than
             a single UI element or not. Whenever multiple pointers are allowed, more than one element may have a pointer
             over it at any one point and thus several elements can be interacted with concurrently.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cursorLockBehavior">
            <summary>
            Where to position the pointer when the cursor is locked.
            </summary>
            <remarks>
            By default, the pointer is positioned at -1, -1 in screen space when the cursor is locked. This has implications
            for using ray casters like <see cref="T:UnityEngine.EventSystems.PhysicsRaycaster"/> because the raycasts will be sent from the pointer
            position. By setting the value of <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cursorLockBehavior"/> to <see cref="F:UnityEngine.InputSystem.UI.InputSystemUIInputModule.CursorLockBehavior.ScreenCenter"/>,
            the raycasts will be sent from the center of the screen. This is useful when trying to interact with world space UI
            using the <see cref="T:UnityEngine.EventSystems.IPointerEnterHandler"/> and <see cref="T:UnityEngine.EventSystems.IPointerExitHandler"/> interfaces when the cursor
            is locked.
            </remarks>
            <see cref="P:UnityEngine.Cursor.lockState"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.localMultiPlayerRoot">
            <summary>
            A root game object to support correct navigation in local multi-player UIs.
            <remarks>
            In local multi-player games where each player has their own UI, players should not be able to navigate into
            another player's UI. Each player should have their own instance of an InputSystemUIInputModule, and this property
            should be set to the root game object containing all UI objects for that player. If set, navigation using the
            <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> action will be constrained to UI objects under that root.
            </remarks>
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.ActivateModule">
            <summary>
            Called by <c>EventSystem</c> when the input module is made current.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.IsPointerOverGameObject(System.Int32)">
             <summary>
             Check whether the given pointer or touch is currently hovering over a <c>GameObject</c>.
             </summary>
             <param name="pointerOrTouchId">ID of the pointer or touch. Meaning this should correspond to either
             <c>PointerEventData.pointerId</c> or <see cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.touchId"/>. The pointer ID
             generally corresponds to the <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> of the pointer device. An exception
             to this are touches as a <see cref="T:UnityEngine.InputSystem.Touchscreen"/> may have multiple pointers (one for each active
             finger). For touch, you can use the <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/> of the touch.
            
             Note that for touch, a pointer will stay valid for one frame before being removed. In other words,
             when <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/> is received for a touch
             and the touch was over a <c>GameObject</c>, the associated pointer is still considered over that
             object for the frame in which the touch ended.
            
             To check whether any pointer is over a <c>GameObject</c>, simply pass a negative value such as -1.</param>
             <returns>True if the given pointer is currently hovering over a <c>GameObject</c>.</returns>
             <remarks>
             The result is true if the given pointer has caused an <c>IPointerEnter</c> event to be sent to a
             <c>GameObject</c>.
            
             This method can be invoked via <c>EventSystem.current.IsPointerOverGameObject</c>.
            
             Be aware that this method relies on state set up during UI event processing that happens in <c>EventSystem.Update</c>,
             that is, as part of <c>MonoBehaviour</c> updates. This step happens <em>after</em> input processing.
             Thus, calling this method earlier than that in the frame will make it poll state from <em>last</em> frame.
            
             Calling this method from within an <see cref="T:UnityEngine.InputSystem.InputAction"/> callback (such as <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>)
             will result in a warning. See the "UI vs Game Input" sample shipped with the Input System package for
             how to deal with this fact.
            
             <example>
             <code>
             // In general, the pointer ID corresponds to the device ID:
             EventSystem.current.IsPointerOverGameObject(XRController.leftHand.deviceId);
             EventSystem.current.IsPointerOverGameObject(Mouse.current.deviceId);
            
             // For touch input, pass the ID of a touch:
             EventSystem.current.IsPointerOverGameObject(Touchscreen.primaryTouch.touchId.ReadValue());
            
             // But can also pass the ID of the entire Touchscreen in which case the result
             // is true if any touch is over a GameObject:
             EventSystem.current.IsPointerOverGameObject(Touchscreen.current.deviceId);
            
             // Finally, any negative value will be interpreted as "any pointer" and will
             // return true if any one pointer is currently over a GameObject:
             EventSystem.current.IsPointerOverGameObject(-1);
             EventSystem.current.IsPointerOverGameObject(); // Equivalent.
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.touchId"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
        </member>
        <member name="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.GetLastRaycastResult(System.Int32)">
             <summary>
             Returns the most recent raycast information for a given pointer or touch.
             </summary>
             <param name="pointerOrTouchId">ID of the pointer or touch. Meaning this should correspond to either
             <c>PointerEventData.pointerId</c> or <see cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.touchId"/>. The pointer ID
             generally corresponds to the <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> of the pointer device. An exception
             to this are touches as a <see cref="T:UnityEngine.InputSystem.Touchscreen"/> may have multiple pointers (one for each active
             finger). For touch, you can use the <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/> of the touch.
            
             Negative values will return an invalid <see cref="T:UnityEngine.EventSystems.RaycastResult"/>.</param>
             <returns>The most recent raycast information.</returns>
             <remarks>
             This method is for the most recent raycast, but depending on when it's called is not guaranteed to be for the current frame.
             This method can be used to determine raycast distances and hit information for visualization.
             <br />
             Use <see cref="P:UnityEngine.EventSystems.RaycastResult.isValid"/> to determine if pointer hit anything.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.ExtendedPointerEventData.touchId"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatDelay">
            <summary>
            Delay in seconds between an initial move action and a repeated move action while <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> is actuated.
            </summary>
            <remarks>
            While <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> is being held down, the input module will first wait for <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatDelay"/> seconds
            after the first actuation of <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> and then trigger a move event every <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatRate"/> seconds.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatRate"/>
            <seealso cref="T:UnityEngine.EventSystems.AxisEventData"/>
            <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatRate">
             <summary>
             Delay in seconds between repeated move actions while <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> is actuated.
             </summary>
             <remarks>
             While <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> is being held down, the input module will first wait for <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatDelay"/> seconds
             after the first actuation of <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> and then trigger a move event every <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatRate"/> seconds.
            
             Note that a maximum of one <see cref="T:UnityEngine.EventSystems.AxisEventData"/> will be sent per frame. This means that even if multiple time
             increments of the repeat delay have passed since the last update, only one move repeat event will be generated.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.moveRepeatDelay"/>
             <seealso cref="T:UnityEngine.EventSystems.AxisEventData"/>
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.xrTrackingOrigin">
            <summary>
            A <see cref="T:UnityEngine.Transform"/> representing the real world origin for tracking devices.
            This is used to convert real world positions and rotations for <see cref="F:UnityEngine.InputSystem.UI.UIPointerType.Tracked"/> pointers into Unity's global space.
            When using the XR Interaction Toolkit, this should be pointing to the XR Rig's Transform.
            </summary>
            <remarks>This will transform all tracked pointers. If unset, or set to null, the Unity world origin will be used as the basis for all tracked positions and rotations.</remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceDragThresholdMultiplier">
            <summary>
            Scales the drag threshold of <c>EventSystem</c> for tracked devices to make selection easier.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <see cref="T:UnityEngine.Vector2"/> 2D screen position
             used as a cursor for pointing at UI elements.
             </summary>
             <remarks>
             The values read from this action determine <see cref="P:UnityEngine.EventSystems.PointerEventData.position"/> and <see cref="P:UnityEngine.EventSystems.PointerEventData.delta"/>.
            
             Together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>, this forms the basis for pointer-type UI input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Vector2"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("Point");
            
             pointAction.AddBinding("&lt;Mouse&gt;/position");
             pointAction.AddBinding("&lt;Touchscreen&gt;/touch*/position");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).point =
                 InputActionReference.Create(pointAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>Vector2</c> scroll wheel value
             used for sending <see cref="T:UnityEngine.EventSystems.PointerEventData"/> events.
             </summary>
             <remarks>
             The values read from this action determine <see cref="P:UnityEngine.EventSystems.PointerEventData.scrollDelta"/>.
            
             Together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>, this forms the basis for pointer-type UI input.
            
             Note that the action is optional. A pointer is fully functional with just <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
             and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/> alone.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Vector2"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("scroll");
             var scrollAction = map.AddAction("scroll");
            
             pointAction.AddBinding("&lt;Mouse&gt;/position");
             pointAction.AddBinding("&lt;Touchscreen&gt;/touch*/position");
            
             scrollAction.AddBinding("&lt;Mouse&gt;/scroll");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).point =
                 InputActionReference.Create(pointAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).scrollWheel =
                 InputActionReference.Create(scrollAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>float</c> button value that determines
             whether the left button of a pointer is pressed.
             </summary>
             <remarks>
             Clicks on this button will use <see cref="F:UnityEngine.EventSystems.PointerEventData.InputButton.Left"/> for <see cref="P:UnityEngine.EventSystems.PointerEventData.button"/>.
            
             Together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>, this forms the basis for pointer-type UI input.
            
             Note that together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>, this action is necessary for a pointer to be functional. The other clicks
             and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/> are optional, however.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Button"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("scroll");
             var clickAction = map.AddAction("click");
            
             pointAction.AddBinding("&lt;Mouse&gt;/position");
             pointAction.AddBinding("&lt;Touchscreen&gt;/touch*/position");
            
             clickAction.AddBinding("&lt;Mouse&gt;/leftButton");
             clickAction.AddBinding("&lt;Touchscreen&gt;/touch*/press");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).point =
                 InputActionReference.Create(pointAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).leftClick =
                 InputActionReference.Create(clickAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>float</c> button value that determines
             whether the middle button of a pointer is pressed.
             </summary>
             <remarks>
             Clicks on this button will use <see cref="F:UnityEngine.EventSystems.PointerEventData.InputButton.Middle"/> for <see cref="P:UnityEngine.EventSystems.PointerEventData.button"/>.
            
             Together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>, this forms the basis for pointer-type UI input.
            
             Note that the action is optional. A pointer is fully functional with just <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
             and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/> alone.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Button"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("scroll");
             var leftClickAction = map.AddAction("leftClick");
             var middleClickAction = map.AddAction("middleClick");
            
             pointAction.AddBinding("&lt;Mouse&gt;/position");
             pointAction.AddBinding("&lt;Touchscreen&gt;/touch*/position");
            
             leftClickAction.AddBinding("&lt;Mouse&gt;/leftButton");
             leftClickAction.AddBinding("&lt;Touchscreen&gt;/touch*/press");
            
             middleClickAction.AddBinding("&lt;Mouse&gt;/middleButton");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).point =
                 InputActionReference.Create(pointAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).leftClick =
                 InputActionReference.Create(leftClickAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).middleClick =
                 InputActionReference.Create(middleClickAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>float"</c> button value that determines
             whether the right button of a pointer is pressed.
             </summary>
             <remarks>
             Clicks on this button will use <see cref="F:UnityEngine.EventSystems.PointerEventData.InputButton.Right"/> for <see cref="P:UnityEngine.EventSystems.PointerEventData.button"/>.
            
             Together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>, this forms the basis for pointer-type UI input.
            
             Note that the action is optional. A pointer is fully functional with just <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
             and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/> alone.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Button"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("scroll");
             var leftClickAction = map.AddAction("leftClick");
             var rightClickAction = map.AddAction("rightClick");
            
             pointAction.AddBinding("&lt;Mouse&gt;/position");
             pointAction.AddBinding("&lt;Touchscreen&gt;/touch*/position");
            
             leftClickAction.AddBinding("&lt;Mouse&gt;/leftButton");
             leftClickAction.AddBinding("&lt;Touchscreen&gt;/touch*/press");
            
             rightClickAction.AddBinding("&lt;Mouse&gt;/rightButton");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).point =
                 InputActionReference.Create(pointAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).leftClick =
                 InputActionReference.Create(leftClickAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).rightClick =
                 InputActionReference.Create(rightClickAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>Vector2</c> 2D motion vector
             used for sending <see cref="T:UnityEngine.EventSystems.AxisEventData"/> navigation events.
             </summary>
             <remarks>
             The events generated from this input will be received by <see cref="M:UnityEngine.EventSystems.IMoveHandler.OnMove(UnityEngine.EventSystems.AxisEventData)"/>.
            
             This action together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.submit"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cancel"/> form the sources for navigation-style
             UI input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Vector2"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("move");
             var submitAction = map.AddAction("submit");
             var cancelAction = map.AddAction("cancel");
            
             moveAction.AddBinding("&lt;Gamepad&gt;/*stick");
             moveAction.AddBinding("&lt;Gamepad&gt;/dpad");
             submitAction.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             cancelAction.AddBinding("&lt;Gamepad&gt;/buttonEast");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).move =
                 InputActionReference.Create(moveAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).submit =
                 InputActionReference.Create(submitAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).cancelAction =
                 InputActionReference.Create(cancelAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.submit"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cancel"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.submit">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>float</c> button value that determines when <c>ISubmitHandler</c>
             is triggered.
             </summary>
             <remarks>
             The events generated from this input will be received by <see cref="T:UnityEngine.EventSystems.ISubmitHandler"/>.
            
             This action together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cancel"/> form the sources for navigation-style
             UI input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("move");
             var submitAction = map.AddAction("submit");
             var cancelAction = map.AddAction("cancel");
            
             moveAction.AddBinding("&lt;Gamepad&gt;/*stick");
             moveAction.AddBinding("&lt;Gamepad&gt;/dpad");
             submitAction.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             cancelAction.AddBinding("&lt;Gamepad&gt;/buttonEast");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).move =
                 InputActionReference.Create(moveAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).submit =
                 InputActionReference.Create(submitAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).cancelAction =
                 InputActionReference.Create(cancelAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cancel"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.cancel">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>float</c> button value that determines when <c>ICancelHandler</c>
             is triggered.
             </summary>
             <remarks>
             The events generated from this input will be received by <see cref="T:UnityEngine.EventSystems.ICancelHandler"/>.
            
             This action together with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.submit"/> form the sources for navigation-style
             UI input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var pointAction = map.AddAction("move");
             var submitAction = map.AddAction("submit");
             var cancelAction = map.AddAction("cancel");
            
             moveAction.AddBinding("&lt;Gamepad&gt;/*stick");
             moveAction.AddBinding("&lt;Gamepad&gt;/dpad");
             submitAction.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             cancelAction.AddBinding("&lt;Gamepad&gt;/buttonEast");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).move =
                 InputActionReference.Create(moveAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).submit =
                 InputActionReference.Create(submitAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).cancelAction =
                 InputActionReference.Create(cancelAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.move"/>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.submit"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>Quaternion</c> value reflecting the orientation of <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>s.
             In combination with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition"/>, this is used to determine the transform of tracked devices from which
             to raycast into the UI scene.
             </summary>
             <remarks>
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition"/> together replace <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/> for
             UI input from <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>. Other than that, UI input for tracked devices is no different from "normal"
             pointer-type input. This means that <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/> can all be used for tracked device input like for regular pointer input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Quaternion"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var positionAction = map.AddAction("position");
             var orientationAction = map.AddAction("orientation");
             var clickAction = map.AddAction("click");
            
             positionAction.AddBinding("&lt;TrackedDevice&gt;/devicePosition");
             orientationAction.AddBinding("&lt;TrackedDevice&gt;/deviceRotation");
             clickAction.AddBinding("&lt;TrackedDevice&gt;/trigger");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).trackedDevicePosition =
                 InputActionReference.Create(positionAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).trackedDeviceOrientation =
                 InputActionReference.Create(orientationAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).leftClick =
                 InputActionReference.Create(clickAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition"/>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition">
             <summary>
             An <see cref="T:UnityEngine.InputSystem.InputAction"/> delivering a <c>Vector3</c> value reflecting the position of <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>s.
             In combination with <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation"/>, this is used to determine the transform of tracked devices from which
             to raycast into the UI scene.
             </summary>
             <remarks>
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDevicePosition"/> together replace <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/> for
             UI input from <see cref="T:UnityEngine.InputSystem.TrackedDevice"/>. Other than that, UI input for tracked devices is no different from "normal"
             pointer-type input. This means that <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.rightClick"/>, <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.middleClick"/>, and
             <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.scrollWheel"/> can all be used for tracked device input like for regular pointer input.
            
             This action should have its <see cref="P:UnityEngine.InputSystem.InputAction.type"/> set to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> and its
             <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set to <c>"Vector3"</c>.
            
             <example>
             <code>
             var asset = ScriptableObject.Create&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("UI");
             var positionAction = map.AddAction("position");
             var orientationAction = map.AddAction("orientation");
             var clickAction = map.AddAction("click");
            
             positionAction.AddBinding("&lt;TrackedDevice&gt;/devicePosition");
             orientationAction.AddBinding("&lt;TrackedDevice&gt;/deviceRotation");
             clickAction.AddBinding("&lt;TrackedDevice&gt;/trigger");
            
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).trackedDevicePosition =
                 InputActionReference.Create(positionAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).trackedDeviceOrientation =
                 InputActionReference.Create(orientationAction);
             ((InputSystemUIInputModule)EventSystem.current.currentInputModule).leftClick =
                 InputActionReference.Create(clickAction);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.trackedDeviceOrientation"/>
        </member>
        <member name="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.AssignDefaultActions">
             <summary>
             Assigns default input actions asset and input actions, similar to how defaults are assigned when creating UI module in editor.
             Useful for creating <see cref="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule"/> at runtime.
             </summary>
             <remarks>
             This instantiates <see cref="T:UnityEngine.InputSystem.DefaultInputActions"/> and assigns it to <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.actionsAsset"/>. It also
             assigns all the various individual actions such as <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.point"/> and <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>.
            
             Note that if an <c>InputSystemUIInputModule</c> component is programmatically added to a <c>GameObject</c>,
             it will automatically receive the default actions as part of its <c>OnEnable</c> method. Use <see cref="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.UnassignActions"/>
             to remove these assignments.
            
             <example>
             <code>
             var go = new GameObject();
             go.AddComponent&lt;EventSystem&gt;();
            
             // Adding the UI module like this will implicitly enable it and thus lead to
             // automatic assignment of the default input actions.
             var uiModule = go.AddComponent&lt;InputSystemUIInputModule&gt;();
            
             // Manually remove the default input actions.
             uiModule.UnassignActions();
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.actionsAsset"/>
             <seealso cref="T:UnityEngine.InputSystem.DefaultInputActions"/>
        </member>
        <member name="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.UnassignActions">
            <summary>
            Remove all action assignments, that is <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.actionsAsset"/> as well as all individual
            actions such as <see cref="P:UnityEngine.InputSystem.UI.InputSystemUIInputModule.leftClick"/>.
            </summary>
            <remarks>
            If the current actions were enabled by the UI input module, they will be disabled in the process.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.UI.InputSystemUIInputModule.AssignDefaultActions"/>
        </member>
        <member name="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule.CursorLockBehavior">
            <summary>
            Controls the origin point of raycasts when the cursor is locked.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.InputSystemUIInputModule.CursorLockBehavior.OutsideScreen">
            <summary>
            The internal pointer position will be set to -1, -1. This short-circuits the raycasting
            logic so no objects will be intersected. This is the default setting.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.UI.InputSystemUIInputModule.CursorLockBehavior.ScreenCenter">
            <summary>
            Raycasts will originate from the center of the screen. This mode can be useful for
            example to check in pointer-driven FPS games if the player is looking at some world-space
            object that implements the <see cref="T:UnityEngine.EventSystems.IPointerEnterHandler"/> and <see cref="T:UnityEngine.EventSystems.IPointerExitHandler"/>
            interfaces.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.UI.PointerModel.ButtonState.ignoreNextClick">
            <summary>
            When we "release" a button other than through user interaction (e.g. through focus switching),
            we don't want this to count as an actual release that ends up clicking. This flag will cause
            generated events to have <c>eligibleForClick</c> to be false.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBinding">
             <summary>
             A mapping of controls to an action.
             </summary>
             <remarks>
             Each binding represents a value received from controls (see <see cref="T:UnityEngine.InputSystem.InputControl"/>).
             There are two main types of bindings: "normal" bindings and "composite" bindings.
            
             Normal bindings directly bind to control(s) by means of <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> which is a "control path"
             (see <see cref="T:UnityEngine.InputSystem.InputControlPath"/> for details about how to form paths). At runtime, the
             path of such a binding may match none, one, or multiple controls. Each control matched by the
             path will feed input into the binding.
            
             Composite bindings do not bind to controls themselves. Instead, they receive their input
             from their "part" bindings and then return a value representing a "composition" of those
             inputs. What composition specifically is performed depends on the type of the composite.
             <see cref="T:UnityEngine.InputSystem.Composites.AxisComposite"/>, for example, will return a floating-point axis value
             computed from the state of two buttons.
            
             The action that is triggered by a binding is determined by its <see cref="P:UnityEngine.InputSystem.InputBinding.action"/> property.
             The resolution to an <see cref="T:UnityEngine.InputSystem.InputAction"/> depends on where the binding is used. For example,
             bindings that are part of <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> will resolve action names to
             actions in the same <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
            
             A binding can also be used as a form of search mask or filter. In this use, <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>,
             <see cref="P:UnityEngine.InputSystem.InputBinding.action"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> become search criteria that are matched
             against other bindings. See <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> for details. This use
             is employed in places such as <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions"/> as well as in
             binding masks on actions (<see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>), action maps (<see
             cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>), and assets (<see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>).
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBinding.Separator">
             <summary>
             Character that is used to separate elements in places such as <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>,
             <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>.
             </summary>
             Some strings on bindings represent lists of elements. An example is <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>
             which may associate a binding with several binding groups, each one delimited by the
             separator.
            
             <remarks>
             <example>
             <code>
             // A binding that belongs to the "Keyboard&amp;Mouse" and "Gamepad" group.
             new InputBinding
             {
                 path = "*/{PrimaryAction},
                 groups = "Keyboard&amp;Mouse;Gamepad"
             };
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.name">
            <summary>
            Optional name for the binding.
            </summary>
            <value>Name of the binding.</value>
            <remarks>
            For bindings that are part of composites (see <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>), this is
            the name of the field on the binding composite object that should be initialized with
            the control target of the binding.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.id">
            <summary>
            Unique ID of the binding.
            </summary>
            <value>Unique ID of the binding.</value>
            <remarks>
            This can be used, for example, when storing binding overrides in local user configurations.
            Using the binding ID, an override can remain associated with one specific binding.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.path">
             <summary>
             Control path being bound to.
             </summary>
             <value>Path of control(s) to source input from.</value>
             <remarks>
             Bindings reference <see cref="T:UnityEngine.InputSystem.InputControl"/>s using a regular expression-like
             language. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/> for details.
            
             If the binding is a composite (<see cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>), the path is the composite
             string instead. For example, for a <see cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/>, the
             path could be something like <c>"Vector2(normalize=false)"</c>.
            
             The path of a binding may be non-destructively override at runtime using <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
             which unlike this property is not serialized. <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/> represents the
             final, effective path.
             </remarks>
             <example>
             <code>
             // A binding that references the left mouse button.
             new InputBinding { path = "&lt;Mouse&gt;/leftButton" }
             </code>
             </example>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
             <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.Parse(System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControl(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.overridePath">
             <summary>
             If the binding is overridden, this is the overriding path.
             Otherwise it is <c>null</c>.
             </summary>
             <value>Path to override the <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> property with.</value>
             <remarks>
             Unlike the <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> property, the value of the override path is not serialized.
             If set, it will take precedence and determine the result of <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/>.
            
             This property can be set to an empty string to disable the binding. During resolution,
             bindings with an empty <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/> will get skipped.
            
             To set the override on an existing binding, use the methods supplied by <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions"/>
             such as <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String)"/>.
            
             <example>
             <code>
             // Override the binding to &lt;Gamepad&gt;/buttonSouth on
             // myAction with a binding to &lt;Gamepad&gt;/buttonNorth.
             myAction.ApplyBindingOverride(
                 new InputBinding
                 {
                     path = "&lt;Gamepad&gt;/buttonSouth",
                     overridePath = "&lt;Gamepad&gt;/buttonNorth"
                 });
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.hasOverrides"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.IInputActionCollection2,System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.interactions">
             <summary>
             Optional list of interactions and their parameters.
             </summary>
             <value>Interactions to put on the binding.</value>
             <remarks>
             Each element in the list is a name of an interaction (as registered with
             <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction``1(System.String)"/>) followed by an optional
             list of parameters.
            
             For example, <c>"slowTap(duration=1.2,pressPoint=0.123)"</c> is one element
             that puts a <see cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction"/> on the binding and
             sets <see cref="F:UnityEngine.InputSystem.Interactions.SlowTapInteraction.duration"/> to 1.2 and
             <see cref="F:UnityEngine.InputSystem.Interactions.SlowTapInteraction.pressPoint"/> to 0.123.
            
             Multiple interactions can be put on a binding by separating them with a comma.
             For example, <c>"tap,slowTap(duration=1.2)"</c> puts both a
             <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/> and <see cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction"/>
             on the binding. See <see cref="T:UnityEngine.InputSystem.IInputInteraction"/> for why the order matters.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.hasOverrides"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.IInputActionCollection2,System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.overrideInteractions">
            <summary>
            Interaction settings to override <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> with.
            </summary>
            <value>Override string for <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> or <c>null</c>.</value>
            <remarks>
            If this is not <c>null</c>, it replaces the value of <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.effectiveInteractions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.hasOverrides"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.IInputActionCollection2,System.String,System.Boolean)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.processors">
            <summary>
            Optional list of processors to apply to control values.
            </summary>
            <value>Value processors to apply to the binding.</value>
            <remarks>
            This string has the same format as <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.processors"/>.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.InputProcessor`1"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.overrideProcessors">
            <summary>
            Processor settings to override <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> with.
            </summary>
            <value>Override string for <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> or <c>null</c>.</value>
            <remarks>
            If this is not <c>null</c>, it replaces the value of <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.effectiveProcessors"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.hasOverrides"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.groups">
             <summary>
             Optional list of binding groups that the binding belongs to.
             </summary>
             <value>List of binding groups or <c>null</c>.</value>
             <remarks>
             This is used, for example, to divide bindings into <see cref="T:UnityEngine.InputSystem.InputControlScheme"/>s.
             Each control scheme is associated with a unique binding group through <see
             cref="P:UnityEngine.InputSystem.InputControlScheme.bindingGroup"/>.
            
             A binding may be associated with multiple groups by listing each group name
             separate by a semicolon (<see cref="F:UnityEngine.InputSystem.InputBinding.Separator"/>).
            
             <example>
             <code>
             new InputBinding
             {
                 path = "*/{PrimaryAction},
                 // Associate the binding both with the "KeyboardMouse" and
                 // the "Gamepad" group.
                 groups = "KeyboardMouse;Gamepad",
             }
             </code>
             </example>
            
             Note that the system places no restriction on what binding groups are used
             for in practice. Their use by <see cref="T:UnityEngine.InputSystem.InputControlScheme"/> is only one
             possible one, but which groups to apply and how to use them is ultimately
             up to you.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.bindingGroup"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.action">
             <summary>
             Name or ID of the action triggered by the binding.
             </summary>
             <remarks>
             This is null if the binding does not trigger an action.
            
             For InputBindings that are used as masks, this can be a "mapName/actionName" combination
             or "mapName/*" to match all actions in the given map.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.name"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.id"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.isComposite">
             <summary>
             Whether the binding is a composite.
             </summary>
             <value>True if the binding is a composite.</value>
             <remarks>
             Composite bindings to not bind to controls to themselves but rather source their
             input from one or more "part binding" (see <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>).
            
             See <see cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/> for more details.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite">
            <summary>
            Whether the binding is a "part binding" of a composite.
            </summary>
            <value>True if the binding is part of a composite.</value>
            <remarks>
            The bindings that make up a composite are laid out sequentially in <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>.
            First comes the composite itself which is flagged with <see cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>. It mentions
            the composite and its parameters in its <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> property. After the composite itself come
            the part bindings. All subsequent bindings marked as <c>isPartOfComposite</c> will be associated
            with the composite.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.hasOverrides">
            <summary>
            True if any of the override properties, that is, <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>,
            and/or <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>, are set (not <c>null</c>).
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Initialize a new binding.
            </summary>
            <param name="path">Path for the binding.</param>
            <param name="action">Action to trigger from the binding.</param>
            <param name="groups">Semicolon-separated list of binding <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> the binding is associated with.</param>
            <param name="processors">Comma-separated list of <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> to apply to the binding.</param>
            <param name="interactions">Comma-separated list of <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> to apply to the
            binding.</param>
            <param name="name">Optional name for the binding.</param>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.effectivePath">
            <summary>
            This is the bindings path which is effectively being used.
            </summary>
            <remarks>
            This is either <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/> if that is set, or <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> otherwise.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.effectiveInteractions">
            <summary>
            This is the interaction config which is effectively being used.
            </summary>
            <remarks>
            This is either <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/> if that is set, or <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> otherwise.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBinding.effectiveProcessors">
            <summary>
            This is the processor config which is effectively being used.
            </summary>
            <remarks>
            This is either <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/> if that is set, or <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> otherwise.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.Equals(UnityEngine.InputSystem.InputBinding)">
            <summary>
            Check whether the binding is equivalent to the given binding.
            </summary>
            <param name="other">Another binding.</param>
            <returns>True if the two bindings are equivalent.</returns>
            <remarks>
            Bindings are equivalent if their <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.effectiveInteractions"/>,
            and <see cref="P:UnityEngine.InputSystem.InputBinding.effectiveProcessors"/>, plus their <see cref="P:UnityEngine.InputSystem.InputBinding.action"/> and <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>
            properties are the same. Note that the string comparisons ignore both case and culture.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.Equals(System.Object)">
            <summary>
            Compare the binding to the given object.
            </summary>
            <param name="obj">An object. May be <c>null</c>.</param>
            <returns>True if the given object is an <c>InputBinding</c> that equals this one.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Equals(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.op_Equality(UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Compare the two bindings for equality.
            </summary>
            <param name="left">The first binding.</param>
            <param name="right">The second binding.</param>
            <returns>True if the two bindings are equal.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Equals(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.op_Inequality(UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Compare the two bindings for inequality.
            </summary>
            <param name="left">The first binding.</param>
            <param name="right">The second binding.</param>
            <returns>True if the two bindings are not equal.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Equals(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.GetHashCode">
            <summary>
            Compute a hash code for the binding.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.ToString">
             <summary>
             Return a string representation of the binding useful for debugging.
             </summary>
             <returns>A string representation of the binding.</returns>
             <example>
             <code>
             var binding = new InputBinding
             {
                 action = "fire",
                 path = "&lt;Gamepad&gt;/buttonSouth",
                 groups = "Gamepad"
             };
            
             // Returns "fire: &lt;Gamepad&gt;/buttonSouth [Gamepad]".
             binding.ToString();
             </code>
             </example>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBinding.DisplayStringOptions">
            <summary>
            A set of flags to turn individual default behaviors of <see cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/> off.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBinding.DisplayStringOptions.DontUseShortDisplayNames">
            <summary>
            Do not use short names of controls as set up by <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.shortDisplayName"/>
            and the <c>"shortDisplayName"</c> property in JSON. This will, for example, not use LMB instead of "left Button"
            on <see cref="P:UnityEngine.InputSystem.Mouse.leftButton"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBinding.DisplayStringOptions.DontOmitDevice">
            <summary>
            By default device names are omitted from display strings. With this option, they are included instead.
            For example, <c>"A"</c> will be <c>"A [Gamepad]"</c> instead.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBinding.DisplayStringOptions.DontIncludeInteractions">
            <summary>
            By default, interactions on bindings are included in the resulting display string. For example, a binding to
            the gamepad's A button that has a "Hold" interaction on it, would come out as "Hold A". This can be suppressed
            with this option in which case the same setup would come out as just "A".
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBinding.DisplayStringOptions.IgnoreBindingOverrides">
            <summary>
            By default, <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/> is used for generating a display name. Using this option, the display
            string can be forced to <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> instead.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)">
             <summary>
             Turn the binding into a string suitable for display in a UI.
             </summary>
             <param name="options">Optional set of formatting options.</param>
             <param name="control">Optional control to which the binding has been resolved. If this is supplied,
             the resulting string can reflect things such as the current keyboard layout or hardware/platform-specific
             naming of controls (e.g. Xbox vs PS4 controllers as opposed to naming things generically based on the
             <see cref="T:UnityEngine.InputSystem.Gamepad"/> layout).</param>
             <returns>A string representation of the binding suitable for display in a UI.</returns>
             <remarks>
             This method works only for bindings that are not composites. If the method is called on a binding
             that is a composite (<see cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/> is true), an empty string will be returned. To automatically
             handle composites, use <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding.DisplayStringOptions,System.String)"/>
             instead.
            
             <example>
             <code>
             var gamepadBinding = new InputBinding("&lt;Gamepad&gt;/buttonSouth");
             var mouseBinding = new InputBinding("&lt;Mouse&gt;/leftButton");
             var keyboardBinding = new InputBinding("&lt;Keyboard&gt;/a");
            
             // Prints "A" except on PS4 where it prints "Cross".
             Debug.Log(gamepadBinding.ToDisplayString());
            
             // Prints "LMB".
             Debug.Log(mouseBinding.ToDisplayString());
            
             // Print "Left Button".
             Debug.Log(mouseBinding.ToDisplayString(DisplayStringOptions.DontUseShortDisplayNames));
            
             // Prints the character associated with the "A" key on the current keyboard layout.
             Debug.Log(keyboardBinding, control: Keyboard.current);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(System.String@,System.String@,UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)">
             <summary>
             Turn the binding into a string suitable for display in a UI.
             </summary>
             <param name="options">Optional set of formatting options.</param>
             <param name="control">Optional control to which the binding has been resolved. If this is supplied,
             the resulting string can reflect things such as the current keyboard layout or hardware/platform-specific
             naming of controls (e.g. Xbox vs PS4 controllers as opposed to naming things generically based on the
             <see cref="T:UnityEngine.InputSystem.Gamepad"/> layout).</param>
             <returns>A string representation of the binding suitable for display in a UI.</returns>
             <remarks>
             This method is the same as <see cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/> except that it
             will also return the name of the device layout and path of the control, if applicable to the binding. This is
             useful when needing more context on the resulting display string, for example to decide on an icon to display
             instead of the textual display string.
            
             <example>
             <code>
             var displayString = new InputBinding("&lt;Gamepad&gt;/dpad/up")
                 .ToDisplayString(out deviceLayout, out controlPath);
            
             // Will print "D-Pad Up".
             Debug.Log(displayString);
            
             // Will print "Gamepad".
             Debug.Log(deviceLayout);
            
             // Will print "dpad/up".
             Debug.Log(controlPath);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,System.String@,System.String@,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,System.String@,System.String@,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)">
             <summary>
             Check whether <paramref name="binding"/> matches the mask
             represented by the current binding.
             </summary>
             <param name="binding">An input binding.</param>
             <returns>True if <paramref name="binding"/> is matched by the mask represented
             by <c>this</c>.</returns>
             <remarks>
             In this method, the current binding acts as a "mask". When used this way, only
             three properties of the binding are taken into account: <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>,
             <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.action"/>.
            
             For each of these properties, the method checks whether they are set on the current
             binding and, if so, matches them against the respective property in <paramref name="binding"/>.
            
             The way this matching works is that the value of the property in the current binding is
             allowed to be a semicolon-separated list where each element specifies one possible value
             that will produce a match.
            
             Note that all comparisons are case-insensitive.
            
             <example>
             <code>
             // Create a couple bindings which we can test against.
             var keyboardBinding = new InputBinding
             {
                 path = "&lt;Keyboard&gt;/space",
                 groups = "Keyboard",
                 action = "Fire"
             };
             var gamepadBinding = new InputBinding
             {
                 path = "&lt;Gamepad&gt;/buttonSouth",
                 groups = "Gamepad",
                 action = "Jump"
             };
             var touchBinding = new InputBinding
             {
                 path = "&lt;Touchscreen&gt;/*/tap",
                 groups = "Touch",
                 action = "Jump"
             };
            
             // Example 1: Match any binding in the "Keyboard" or "Gamepad" group.
             var mask1 = new InputBinding
             {
                 // We put two elements in the list here and separate them with a semicolon.
                 groups = "Keyboard;Gamepad"
             };
            
             mask1.Matches(keyboardBinding); // True
             mask1.Matches(gamepadBinding); // True
             mask1.Matches(touchBinding); // False
            
             // Example 2: Match any binding to the "Jump" or the "Roll" action
             //            (the latter we don't actually have a binding for)
             var mask2 = new InputBinding
             {
                 action = "Jump;Roll"
             };
            
             mask2.Matches(keyboardBinding); // False
             mask2.Matches(gamepadBinding); // True
             mask2.Matches(touchBinding); // True
            
             // Example: Match any binding to the space or enter key in the
             //          "Keyboard" group.
             var mask3 = new InputBinding
             {
                 path = "&lt;Keyboard&gt;/space;&lt;Keyboard&gt;/enter",
                 groups = "Keyboard"
             };
            
             mask3.Matches(keyboardBinding); // True
             mask3.Matches(gamepadBinding); // False
             mask3.Matches(touchBinding); // False
             </code>
             </example>
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HIDParser">
            <summary>
            Turns binary HID descriptors into <see cref="T:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor"/> instances.
            </summary>
            <remarks>
            For information about the format, see the <a href="http://www.usb.org/developers/hidpage/HID1_11.pdf">
            Device Class Definition for Human Interface Devices</a> section 6.2.2.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.HID.HIDParser.ParseReportDescriptor(System.Byte[],UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor@)">
            <summary>
            Parse a HID report descriptor as defined by section 6.2.2 of the
            <a href="http://www.usb.org/developers/hidpage/HID1_11.pdf">HID
            specification</a> and add the elements and collections from the
            descriptor to the given <paramref name="deviceDescriptor"/>.
            </summary>
            <param name="buffer">Buffer containing raw HID report descriptor.</param>
            <param name="deviceDescriptor">HID device descriptor to complete with the information
            from the report descriptor. Elements and collections will get added to this descriptor.</param>
            <returns>True if the report descriptor was successfully parsed.</returns>
            <remarks>
            Will also set <see cref="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.inputReportSize"/>,
            <see cref="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.outputReportSize"/>, and
            <see cref="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.featureReportSize"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID">
            <summary>
            A generic HID input device.
            </summary>
            <remarks>
            This class represents a best effort to mirror the control setup of a HID
            discovered in the system. It is used only as a fallback where we cannot
            match the device to a specific product we know of. Wherever possible we
            construct more specific device representations such as Gamepad.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.HID.HID.QueryHIDReportDescriptorDeviceCommandType">
            <summary>
            Command code for querying the HID report descriptor from a device.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.HID.HID.QueryHIDReportDescriptorSizeDeviceCommandType">
            <summary>
            Command code for querying the HID report descriptor size in bytes from a device.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.HID.HID.hidDescriptor">
            <summary>
            The HID device descriptor as received from the system.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.HIDElementDescriptor">
            <summary>
            Descriptor for a single report element.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.HIDCollectionDescriptor">
            <summary>
            Descriptor for a collection of HID elements.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor">
            <summary>
            HID descriptor for a HID class device.
            </summary>
            <remarks>
            This is a processed view of the combined descriptors provided by a HID as defined
            in the HID specification, i.e. it's a combination of information from the USB device
            descriptor, HID class descriptor, and HID report descriptor.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.vendorId">
            <summary>
            USB vendor ID.
            </summary>
            <remarks>
            To get the string version of the vendor ID, see <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.manufacturer"/>
            on <see cref="P:UnityEngine.InputSystem.InputDevice.description"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.productId">
            <summary>
            USB product ID.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.inputReportSize">
            <summary>
            Maximum size of individual input reports sent by the device.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.outputReportSize">
            <summary>
            Maximum size of individual output reports sent to the device.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor.featureReportSize">
            <summary>
            Maximum size of individual feature reports exchanged with the device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptorBuilder">
            <summary>
            Helper to quickly build descriptors for arbitrary HIDs.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.UsagePage">
            <summary>
            Enumeration of HID usage pages.
            </summary>00
            <remarks>
            Note that some of the values are actually ranges.
            </remarks>
            <seealso href="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf"/>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HID.GenericDesktop">
            <summary>
            Usages in the GenericDesktop HID usage page.
            </summary>
            <seealso href="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf"/>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HIDSupport">
             <summary>
             Adds support for generic HID devices to the input system.
             </summary>
             <remarks>
             Even without this module, HIDs can be used on platforms where we
             support HID has a native backend (Windows and OSX, at the moment).
             However, each supported HID requires a layout specifically targeting
             it as a product.
            
             What this module adds is the ability to turn any HID with usable
             controls into an InputDevice. It will make a best effort to figure
             out a suitable class for the device and will use the HID elements
             present in the HID report descriptor to populate the device.
            
             If there is an existing product-specific layout for a HID, it will
             take precedence and HIDSupport will leave the device alone.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.HIDSupport.HIDPageUsage">
            <summary>
            A pair of HID usage page and HID usage number.
            </summary>
            <remarks>
            Used to describe a HID usage for the <see cref="P:UnityEngine.InputSystem.HID.HIDSupport.supportedHIDUsages"/> property.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HIDSupport.HIDPageUsage.page">
            <summary>
            The usage page.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.HID.HIDSupport.HIDPageUsage.usage">
            <summary>
            A number specifying the usage on the usage page.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.HID.HIDSupport.HIDPageUsage.#ctor(UnityEngine.InputSystem.HID.HID.UsagePage,System.Int32)">
            <summary>
            Create a HIDPageUsage struct by specifying a page and usage.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.HID.HIDSupport.HIDPageUsage.#ctor(UnityEngine.InputSystem.HID.HID.GenericDesktop)">
            <summary>
            Create a HIDPageUsage struct from the GenericDesktop usage page by specifying the usage.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.HID.HIDSupport.supportedHIDUsages">
             <summary>
             An array of HID usages the input is configured to support.
             </summary>
             <remarks>
             The input system will only create <see cref="T:UnityEngine.InputSystem.InputDevice"/>s for HIDs with usages
             listed in this array. Any other HID will be ignored. This saves the input system from
             spending resources on creating layouts and devices for HIDs which are not supported or
             not usable for game input.
            
             By default, this includes only <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.Joystick"/>,
             <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.Gamepad"/> and <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.MultiAxisController"/>,
             but you can set this property to include any other HID usages.
            
             Note that currently on macOS, the only HID usages which can be enabled are
             <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.Joystick"/>, <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.Gamepad"/>,
             <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.MultiAxisController"/>, <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.TabletPCControls"/>,
             and <see cref="F:UnityEngine.InputSystem.HID.HID.GenericDesktop.AssistiveControl"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.HID.HIDSupport.Initialize">
            <summary>
            Add support for generic HIDs to InputSystem.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.HID.Editor.HIDDescriptorWindow">
            <summary>
            A window that dumps a raw HID descriptor in a tree view.
            </summary>
            <remarks>
            Not specific to InputDevices of type <see cref="T:UnityEngine.InputSystem.HID.HID"/> so that it can work with
            any <see cref="T:UnityEngine.InputSystem.InputDevice"/> created for a device using the "HID" interface.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerInput">
             <summary>
             Represents a separate player in the game complete with a set of actions exclusive
             to the player and a set of paired device.
             </summary>
             <remarks>
             PlayerInput is a high-level wrapper around much of the input system's functionality
             which is meant to help getting set up with the new input system quickly. It takes
             care of <see cref="T:UnityEngine.InputSystem.InputAction"/> bookkeeping and has a custom UI(requires the "Unity UI" package) to help
             setting up input.
            
             The component supports local multiplayer implicitly. Each PlayerInput instance
             represents a distinct user with its own set of devices and actions. To orchestrate
             player management and facilitate mechanics such as joining by device activity, use
             <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/>.
            
             The way PlayerInput notifies script code of events is determined by <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/>.
             By default, this is set to <see cref="F:UnityEngine.InputSystem.PlayerNotifications.SendMessages"/> which will use
             <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)"/> to send messages to the <see cref="T:UnityEngine.GameObject"/>
             that PlayerInput sits on.
            
             <example>
             <code>
             // Component to sit next to PlayerInput.
             [RequireComponent(typeof(PlayerInput))]
             public class MyPlayerLogic : MonoBehaviour
             {
                 public GameObject projectilePrefab;
            
                 private Vector2 m_Look;
                 private Vector2 m_Move;
                 private bool m_Fire;
            
                 // 'Fire' input action has been triggered. For 'Fire' we want continuous
                 // action (that is, firing) while the fire button is held such that the action
                 // gets triggered repeatedly while the button is down. We can easily set this
                 // up by having a "Press" interaction on the button and setting it to repeat
                 // at fixed intervals.
                 public void OnFire()
                 {
                     Instantiate(projectilePrefab);
                 }
            
                 // 'Move' input action has been triggered.
                 public void OnMove(InputValue value)
                 {
                     m_Move = value.Get&lt;Vector2&gt;();
                 }
            
                 // 'Look' input action has been triggered.
                 public void OnLook(InputValue value)
                 {
                     m_Look = value.Get&lt;Vector2&gt;();
                 }
            
                 public void OnUpdate()
                 {
                     // Update transform from m_Move and m_Look
                 }
             }
             </code>
             </example>
            
             It is also possible to use the polling API of <see cref="T:UnityEngine.InputSystem.InputAction"/>s (see
             <see cref="P:UnityEngine.InputSystem.InputAction.triggered"/> and <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>)
             in combination with PlayerInput.
            
             <example>
             <code>
             // Component to sit next to PlayerInput.
             [RequireComponent(typeof(PlayerInput))]
             public class MyPlayerLogic : MonoBehaviour
             {
                 public GameObject projectilePrefab;
            
                 private PlayerInput m_PlayerInput;
                 private InputAction m_LookAction;
                 private InputAction m_MoveAction;
                 private InputAction m_FireAction;
            
                 public void OnUpdate()
                 {
                     // First update we look up all the data we need.
                     // NOTE: We don't do this in OnEnable as PlayerInput itself performing some
                     //       initialization work in OnEnable.
                     if (m_PlayerInput == null)
                     {
                         m_PlayerInput = GetComponent&lt;PlayerInput&gt;();
                         m_FireAction = m_PlayerInput.actions["fire"];
                         m_LookAction = m_PlayerInput.actions["look"];
                         m_MoveAction = m_PlayerInput.actions["move"];
                     }
            
                     if (m_FireAction.triggered)
                         /* firing logic... */;
            
                     var move = m_MoveAction.ReadValue&lt;Vector2&gt;();
                     var look = m_LookAction.ReadValue&lt;Vector2&gt;();
                     /* Update transform from move&amp;look... */
                 }
             }
             </code>
             </example>
            
             When enabled, PlayerInput will create an <see cref="T:UnityEngine.InputSystem.Users.InputUser"/> and pair devices to the
             user which are then specific to the player. The set of devices can be controlled explicitly
             when instantiating a PlayerInput through <see cref="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice[])"/>
             or <see cref="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice)"/>. This also makes it possible
             to assign the same device to two different players, e.g. for split-keyboard play.
            
             <example>
             <code>
             var p1 = PlayerInput.Instantiate(playerPrefab,
                 controlScheme: "KeyboardLeft", device: Keyboard.current);
             var p2 = PlayerInput.Instantiate(playerPrefab,
                 controlScheme: "KeyboardRight", device: Keyboard.current);
             </code>
             </example>
            
             If no specific devices are given to a PlayerInput, the component will look for compatible
             devices present in the system and pair them to itself automatically. If the PlayerInput's
             <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/> have control schemes defined for them, PlayerInput will look for a
             control scheme for which all required devices are available and not paired to any other player.
             It will try <see cref="P:UnityEngine.InputSystem.PlayerInput.defaultControlScheme"/> first (if set), but then fall back to trying
             all available schemes in order. Once a scheme is found for which all required devices are
             available, PlayerInput will pair those devices to itself and select the given scheme.
            
             If no control schemes are defined, PlayerInput will try to bind as many as-of-yet unpaired
             devices to itself as it can match to bindings present in the <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>. This means
             that if, for example, there's binding for both keyboard and gamepad and there is one keyboard
             and two gamepads available when PlayerInput is enabled, all three devices will be paired to
             the player.
            
             Note that when using <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/>, device pairing to players is controlled
             from the joining logic. In that case, PlayerInput will automatically pair the device from which
             the player joined. If control schemes are present in <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>, the first one compatible
             with that device is chosen. If additional devices are required, these will be paired from the pool
             of currently unpaired devices.
            
             Device pairings can be changed at any time by either manually controlling pairing through
             <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/> (and related methods) using a PlayerInput's
             assigned <see cref="P:UnityEngine.InputSystem.PlayerInput.user"/> or by switching control schemes (e.g. using
             <see cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(System.String,UnityEngine.InputSystem.InputDevice[])"/>), if any are present in the PlayerInput's
             <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>.
            
             When a player loses a device paired to it (e.g. when it is unplugged or loses power), <see cref="T:UnityEngine.InputSystem.Users.InputUser"/>
             will signal <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/> which is also surfaced as a message,
             <see cref="P:UnityEngine.InputSystem.PlayerInput.deviceLostEvent"/>, or <see cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceLost"/> (depending on <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/>).
             When a device is reconnected, <see cref="T:UnityEngine.InputSystem.Users.InputUser"/> will signal <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceRegained"/>
             which also is surfaced as a message, as <see cref="P:UnityEngine.InputSystem.PlayerInput.deviceRegainedEvent"/>, or <see cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceRegained"/>
             (depending on <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/>).
            
             When there is only a single active PlayerInput in the game, joining is not enabled (see
             <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>), and <see cref="P:UnityEngine.InputSystem.PlayerInput.neverAutoSwitchControlSchemes"/> is not
             set to <c>true</c>, device pairings for the player will also update automatically based on device usage.
            
             If control schemes are present in <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>, then if a device is used (not merely plugged in
             but rather receives input on a non-noisy, non-synthetic control) which is compatible with a control scheme
             other than the currently used one, PlayerInput will attempt to switch to that control scheme. Success depends
             on whether all device requirements for that scheme are met from the set of available devices. If a control
             scheme happens, <see cref="T:UnityEngine.InputSystem.Users.InputUser"/> signals <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.ControlSchemeChanged"/> on
             <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/>.
            
             If no control schemes are present in <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>, PlayerInput will automatically pair any newly
             available device to itself if the given device has any bindings available for it.
            
             Both behaviors described in the previous two paragraphs are automatically disabled if more than one
             PlayerInput is active.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.PlayerInputManager"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerInput.DeviceLostMessage">
            <summary>
            Name of the message that is sent with <c>UnityEngine.Object.SendMessage</c> when a
            player loses a device.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceLost"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerInput.DeviceRegainedMessage">
            <summary>
            Name of the message that is sent with <c>UnityEngine.Object.SendMessage</c> when a
            player regains a device.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceRegained"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerInput.ControlsChangedMessage">
            <summary>
            Name of the message that is sent with <c>UnityEngine.Object.SendMessage</c> when the
            controls used by a player are changed.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.PlayerInput.onControlsChanged"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.inputIsActive">
            <summary>
            Whether input is on the player is active.
            </summary>
            <value>If true, the player is receiving input.</value>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.ActivateInput"/>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.DeactivateInput"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.playerIndex">
             <summary>
             Unique, zero-based index of the player. For example, <c>2</c> for the third player.
             </summary>
             <value>Unique index of the player.</value>
             <remarks>
             Once assigned, a player index will not change.
            
             Note that the player index does not necessarily correspond to the player's index in <see cref="P:UnityEngine.InputSystem.PlayerInput.all"/>.
             The array will always contain all currently enabled players so when a player is disabled or destroyed,
             it will be removed from the array. However, the player index of the remaining players will not change.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.splitScreenIndex">
             <summary>
             If split-screen is enabled (<see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/>),
             this is the index of the screen area used by the player.
             </summary>
             <value>Index of split-screen area assigned to player or -1 if the player is not
             using split-screen.</value>
             <remarks>
             Split screen areas are enumerated row by row and within rows, column by column. So, if, for example,
             there are four separate split-screen areas, the upper left one is #0, the upper right one is #1,
             the lower left one is #2, and the lower right one is #3.
            
             Split screen areas are usually assigned automatically but players can also be assigned to
             areas explicitly through <see cref="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice)"/> or
             <see cref="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayer(System.Int32,System.Int32,System.String,UnityEngine.InputSystem.InputDevice)"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.camera"/>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.actions">
             <summary>
             Input actions associated with the player.
             </summary>
             <value>Asset holding the player's input actions.</value>
             <remarks>
             Note that every player will maintain a unique copy of the given actions such that
             each player receives an identical copy. When assigning the same actions to multiple players,
             the first player will use the given actions as is but any subsequent player will make a copy
             of the actions using <see cref="M:UnityEngine.Object.Instantiate(UnityEngine.Object)"/>.
            
             The asset may contain an arbitrary number of action maps. By setting <see cref="P:UnityEngine.InputSystem.PlayerInput.defaultActionMap"/>,
             one of them can be selected to enabled automatically when PlayerInput is enabled. If no default
             action map is selected, none of the action maps will be enabled by PlayerInput itself. Use
             <see cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentActionMap(System.String)"/> or just call <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/> directly
             to enable a specific map.
            
             Notifications will be sent for all actions in the asset, not just for those in the first action
             map. This means that if additional maps are manually enabled and disabled, notifications will
             be sent for their actions as they receive input.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>
             <seealso cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentActionMap(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme">
            <summary>
            Name of the currently active control scheme.
            </summary>
            <value>Name of the currently active control scheme or <c>null</c>.</value>
            <remarks>
            Note that this property will be <c>null</c> if there are no control schemes
            defined in <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(UnityEngine.InputSystem.InputDevice[])"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.defaultControlScheme"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.defaultControlScheme">
             <summary>
             The default control scheme to try.
             </summary>
             <value>Name of the default control scheme.</value>
             <remarks>
             When PlayerInput is enabled and this is not <c>null</c> and not empty, the PlayerInput
             will look up the control scheme in <see cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/> of
             <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>. If found, PlayerInput will try to activate the scheme. This will
             succeed only if all devices required by the control scheme are either already paired to
             the player or are available as devices not used by other PlayerInputs.
            
             Note that this property only determines the first control scheme to try. If using the
             control scheme fails, PlayerInput will fall back to trying the other control schemes
             (if any) available from <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(UnityEngine.InputSystem.InputDevice[])"/>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.neverAutoSwitchControlSchemes">
             <summary>
             If true, do not automatically switch control schemes even when there is only a single player.
             By default, this property is false.
             </summary>
             <value>If true, do not switch control schemes when other devices are used.</value>
             <remarks>
             By default, when there is only a single PlayerInput enabled, we assume that the game is in
             single-player mode and that the player should be able to freely switch between the control schemes
             supported by the game. For example, if the player is currently using mouse and keyboard, but is
             then switching to a gamepad, PlayerInput should automatically switch to the control scheme for
             gamepads, if present.
            
             When there is more than one PlayerInput or when joining is enabled <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/>,
             this behavior is automatically turned off as we wouldn't know which player is switching if a
             currently unpaired device is used.
            
             By setting this property to true, auto-switching of control schemes is forcibly turned off and
             will thus not be performed even if there is only a single PlayerInput in the game.
            
             Note that you can still switch control schemes manually using <see
             cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(System.String,UnityEngine.InputSystem.InputDevice[])"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.isSinglePlayer"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.currentActionMap">
            <summary>
            The currently enabled action map.
            </summary>
            <value>Reference to the currently enabled action or <c>null</c> if no action
            map has been enabled by PlayerInput.</value>
            <remarks>
            Note that the concept of "current action map" is local to PlayerInput. You can still freely
            enable and disable action maps directly on the <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/> asset. This property
            only tracks which action map has been enabled under the control of PlayerInput, i.e. either
            by means of <see cref="P:UnityEngine.InputSystem.PlayerInput.defaultActionMap"/> or by using <see cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentActionMap(System.String)"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentActionMap(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.defaultActionMap">
            <summary>
            Name (see <see cref="P:UnityEngine.InputSystem.InputActionMap.name"/>) or ID (see <see cref="P:UnityEngine.InputSystem.InputActionMap.id"/>) of the action
            map to enable by default.
            </summary>
            <value>Action map to enable by default or <c>null</c>.</value>
            <remarks>
            By default, when enabled, PlayerInput will not enable any of the actions in the <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>
            asset. By setting this property, however, PlayerInput can be made to automatically enable the respective
            action map.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.currentActionMap"/>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentActionMap(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior">
            <summary>
            Determines how the component notifies listeners about input actions and other input-related
            events pertaining to the player.
            </summary>
            <value>How to trigger notifications on events.</value>
            <remarks>
            By default, the component will use <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)"/> to send messages
            to the <see cref="T:UnityEngine.GameObject"/>. This can be changed by selecting a different <see cref="T:UnityEngine.InputSystem.PlayerNotifications"/>
            behavior.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.actionEvents"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.deviceLostEvent"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.deviceRegainedEvent"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.actionEvents">
            <summary>
            List of events invoked in response to actions being triggered.
            </summary>
            <remarks>
            This array is only used if <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is set to
            <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.deviceLostEvent">
            <summary>
            Event that is triggered when the player loses a device (e.g. the batteries run out).
            </summary>
            <remarks>
            This event is only used if <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is set to
            <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.deviceRegainedEvent">
            <summary>
            Event that is triggered when the player recovers from device loss and is good to go again.
            </summary>
            <remarks>
            This event is only used if <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is set to
            <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.controlsChangedEvent">
             <summary>
             Event that is triggered when the controls used by the player change.
             </summary>
             <remarks>
             This event is only used if <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is set to
             <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents"/>.
            
             The event is trigger when the set of <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/> used by the player change,
             when the player switches to a different control scheme (see <see cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>),
             or when the bindings used by the player are changed (e.g. when rebinding them). Also,
             for <see cref="T:UnityEngine.InputSystem.Keyboard"/> devices, the event is triggered when the currently used
             keyboard layout (see <see cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>) changes.
             </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.PlayerInput.onActionTriggered">
             <summary>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is set to <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, this
             event is triggered when an action fires.
             </summary>
             <value>Callbacks that get called when an action triggers.</value>
             <remarks>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is not set to <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, the
             value of this property is ignored.
            
             The callbacks are called in sync (and with the same argument) with <see cref="E:UnityEngine.InputSystem.InputAction.started"/>,
             <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>, and <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>.
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.InputActionMap.actionTriggered"/>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
             <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.actions"/>
        </member>
        <member name="E:UnityEngine.InputSystem.PlayerInput.onDeviceLost">
             <summary>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, this event
             is triggered when a device paired to the player is disconnected.
             </summary>
             <value>Callbacks that get called when the player loses a device.</value>
             <remarks>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is not <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, the value
             of this property is ignored.
            
             The argument is the player that lost its device (i.e. the player on which the callback is installed).
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceRegained"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/>
        </member>
        <member name="E:UnityEngine.InputSystem.PlayerInput.onDeviceRegained">
             <summary>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, this event
             is triggered when the player previously lost a device and has now regained it or an equivalent device.
             </summary>
             <value>Callbacks that get called when the player regains a device.</value>
             <remarks>
             If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is not <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, the value
             of this property is ignored.
            
             The argument is the player that regained a device (i.e. the player on which the callback is installed).
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.PlayerInput.onDeviceLost"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceRegained"/>
        </member>
        <member name="E:UnityEngine.InputSystem.PlayerInput.onControlsChanged">
            <summary>
            If <see cref="P:UnityEngine.InputSystem.PlayerInput.notificationBehavior"/> is <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents"/>, this event
            is triggered when the controls used by the players are changed.
            </summary>
            <remarks>
            The callback is invoked when the set of <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/> used by the player change,
            when the player switches to a different control scheme (see <see cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>),
            or when the bindings used by the player are changed (e.g. when rebinding them). Also,
            for <see cref="T:UnityEngine.InputSystem.Keyboard"/> devices, the callback is invoked when the currently used
            keyboard layout (see <see cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>) changes.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.camera">
             <summary>
             Optional camera associated with the player.
             </summary>
             <value>Camera specific to the player or <c>null</c>.</value>
             <remarks>
             This is <c>null</c> by default.
            
             Associating a camera with a player is necessary only when using split-screen (see <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/>).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.uiInputModule">
            <summary>
            UI InputModule that should have it's input actions synchronized to this PlayerInput's actions.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.user">
            <summary>
            The internal user tied to the player.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.devices">
            <summary>
            The devices paired to the player.
            </summary>
            <value>List of devices paired to player.</value>
            <remarks>
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.hasMissingRequiredDevices">
            <summary>
            Whether the player is missed required devices. This means that the player's
            input setup is probably at least partially non-functional.
            </summary>
            <value>True if the player is missing devices required by the control scheme.</value>
            <remarks>
            This can happen, for example, if the a device is unplugged during the game.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.hasMissingRequiredDevices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.all">
            <summary>
            List of all players that are currently joined. Sorted by <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/> in
            increasing order.
            </summary>
            <value>List of active PlayerInputs.</value>
            <remarks>
            While the list is sorted by <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/>, note that this does not mean that the <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/>
            of a player corresponds to the index in this list. If, for example, three players join and then the second player leaves,
            the list will contain one player with <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/> 0 followed by one player with <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/> 2.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayer(System.Int32,System.Int32,System.String,UnityEngine.InputSystem.InputDevice)"/>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInput.isSinglePlayer">
             <summary>
             Whether PlayerInput operates in single-player mode.
             </summary>
             <value>If true, there is at most a single PlayerInput.</value>
             <remarks>
             Single-player mode is active while there is at most one PlayerInput (there can also be none) and
             while joining is not enabled in <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/> (if one exists). See <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>.
            
             Automatic control scheme switching (if enabled) is predicated on single-player mode being active.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.neverAutoSwitchControlSchemes"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.GetDevice``1">
            <summary>
            Return the first device of the given type from <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/> paired to the player.
            If no device of this type is paired to the player, return <c>null</c>.
            </summary>
            <typeparam name="TDevice">Type of device to look for (such as <see cref="T:UnityEngine.InputSystem.Mouse"/>). Can be a supertype
            of the actual device type. For example, querying for <see cref="T:UnityEngine.InputSystem.Pointer"/>, may return a <see cref="T:UnityEngine.InputSystem.Mouse"/>.</typeparam>
            <returns>The first device paired to the player that is of the given type or <c>null</c> if the player
            does not have a matching device.</returns>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.devices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.ActivateInput">
             <summary>
             Enable input on the player.
             </summary>
             <remarks>
             Input will automatically be activated when the PlayerInput component is enabled. However, this method
             can be called to reactivate input after deactivating it with <see cref="M:UnityEngine.InputSystem.PlayerInput.DeactivateInput"/>.
            
             Note that activating input will activate the current action map only (see <see cref="P:UnityEngine.InputSystem.PlayerInput.currentActionMap"/>).
             </remarks>
             <see cref="P:UnityEngine.InputSystem.PlayerInput.inputIsActive"/>
             <seealso cref="M:UnityEngine.InputSystem.PlayerInput.DeactivateInput"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.DeactivateInput">
             <summary>
             Disable input on the player.
             </summary>
             <remarks>
             Input is automatically activated when the PlayerInput component is enabled. This method can be
             used to deactivate input manually.
            
             Note that activating input will deactivate the current action map only (see <see cref="P:UnityEngine.InputSystem.PlayerInput.currentActionMap"/>).
             </remarks>
             <see cref="M:UnityEngine.InputSystem.PlayerInput.ActivateInput"/>
             <see cref="P:UnityEngine.InputSystem.PlayerInput.inputIsActive"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(UnityEngine.InputSystem.InputDevice[])">
             <summary>
             Switch the current control scheme to one that fits the given set of devices.
             </summary>
             <param name="devices">A list of input devices. Note that if any of the devices is already paired to another
             player, the device will end up paired to both players.</param>
             <returns>True if the switch was successful, false otherwise. The latter can happen, for example, if
             <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/> does not have a control scheme that fits the given set of devices.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="devices"/> is <c>null</c>.</exception>
             <exception cref="T:System.InvalidOperationException"><see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/> has not been assigned.</exception>
             <remarks>
             The player's currently paired devices (see <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/>) will get unpaired.
            
             <example>
             <code>
             // Switch the first player to keyboard and mouse.
             PlayerInput.all[0]
                 .SwitchCurrentControlScheme(Keyboard.current, Mouse.current);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.SwitchCurrentControlScheme(System.String,UnityEngine.InputSystem.InputDevice[])">
             <summary>
             Switch the player to use the given control scheme together with the given devices.
             </summary>
             <param name="controlScheme">Name of the control scheme. See <see cref="P:UnityEngine.InputSystem.InputControlScheme.name"/>.</param>
             <param name="devices">A list of devices.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="devices"/> is <c>null</c> -or- <paramref name="controlScheme"/> is
             <c>null</c> or empty.</exception>
             <remarks>
             This method can be used to explicitly force a combination of control scheme and a specific set of
             devices.
            
             <example>
             <code>
             // Put player 1 on the "Gamepad" control scheme together
             // with the second gamepad.
             PlayerInput.all[0].SwitchControlScheme(
                 "Gamepad",
                 Gamepad.all[1]);
             </code>
             </example>
            
             The player's currently paired devices (see <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/>) will get unpaired.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>
             <seealso cref="P:UnityEngine.InputSystem.PlayerInput.currentControlScheme"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.GetPlayerByIndex(System.Int32)">
            <summary>
            Return the Nth player.
            </summary>
            <param name="playerIndex">Index of the player to return.</param>
            <returns>The player with the given player index or <c>null</c> if no such
            player exists.</returns>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.FindFirstPairedToDevice(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Find the first PlayerInput who the given device is paired to.
            </summary>
            <param name="device">An input device.</param>
            <returns>The player who is paired to the given device or <c>null</c> if no
            PlayerInput currently is paired to <paramref name="device"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            // Find the player paired to first gamepad.
            var player = PlayerInput.FindFirstPairedToDevice(Gamepad.all[0]);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice)">
            <summary>
            Instantiate a player object and set up and enable its inputs.
            </summary>
            <param name="prefab">Prefab to clone. Must contain a PlayerInput component somewhere in its hierarchy.</param>
            <param name="playerIndex">Player index to assign to the player. See <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/>.
            By default will be assigned automatically based on how many players are in <see cref="P:UnityEngine.InputSystem.PlayerInput.all"/>.</param>
            <param name="controlScheme">Control scheme to activate</param>
            <param name="splitScreenIndex"></param>
            <param name="pairWithDevice">Device to pair to the user. By default, this is <c>null</c> which means
            that PlayerInput will automatically pair with available, unpaired devices based on the control schemes (if any)
            present in <see cref="P:UnityEngine.InputSystem.PlayerInput.actions"/> or on the bindings therein (if no control schemes are present).</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="prefab"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.Instantiate(UnityEngine.GameObject,System.Int32,System.String,System.Int32,UnityEngine.InputSystem.InputDevice[])">
            <summary>
            A wrapper around <see cref="M:UnityEngine.Object.Instantiate(UnityEngine.Object)"/> that allows instantiating a player prefab and
            automatically pair one or more specific devices to the newly created player.
            </summary>
            <param name="prefab">A player prefab containing a <see cref="T:UnityEngine.InputSystem.PlayerInput"/> component in its hierarchy.</param>
            <param name="playerIndex"></param>
            <param name="controlScheme"></param>
            <param name="splitScreenIndex"></param>
            <param name="pairWithDevices"></param>
            <returns></returns>
            <remarks>
            Note that unlike <see cref="M:UnityEngine.Object.Instantiate(UnityEngine.Object)"/>, this method will always activate the resulting
            <see cref="T:UnityEngine.GameObject"/> and its components.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.AssignUserAndDevices">
            <summary>
            Initialize <see cref="P:UnityEngine.InputSystem.PlayerInput.user"/> and <see cref="P:UnityEngine.InputSystem.PlayerInput.devices"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInput.DebugLogAction(UnityEngine.InputSystem.InputAction.CallbackContext)">
            <summary>
            Debug helper method that can be hooked up to actions when using <see cref="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerInput.DeviceLostEvent">
            <summary>
            Event that is triggered when an <see cref="T:UnityEngine.InputSystem.InputDevice"/> paired to a <see cref="T:UnityEngine.InputSystem.PlayerInput"/> is disconnected.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.deviceLostEvent"/>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerInput.DeviceRegainedEvent">
            <summary>
            Event that is triggered when a <see cref="T:UnityEngine.InputSystem.PlayerInput"/> regains an <see cref="T:UnityEngine.InputSystem.InputDevice"/> previously lost.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.deviceRegainedEvent"/>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerInput.ControlsChangedEvent">
            <summary>
            Event that is triggered when the set of controls used by a <see cref="T:UnityEngine.InputSystem.PlayerInput"/> changes.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInput.controlsChangedEvent"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSystemObject">
            <summary>
            A hidden, internal object we put in the editor to bundle input system state
            and help us survive domain reloads.
            </summary>
            <remarks>
            Player doesn't need this stuff because there's no domain reloads to survive.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.LowLevel.DualSenseHIDInputReport">
            <summary>
            This is abstract input report for PS5 DualSense controller, similar to what is on the wire, but not exactly binary matching any state events.
            See ConvertInputReport for the exact conversion.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.LowLevel.DualShock4HIDInputReport">
            <summary>
            Structure of HID input reports for PS4 DualShock 4 controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.LowLevel.DualShock3HIDInputReport">
            <summary>
            Structure of HID input reports for PS3 DualShock 3 controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.LowLevel.DualShockHIDOutputReport">
            <summary>
            PS4 output report sent as command to HID backend.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.DualSenseGamepadHID">
            <summary>
            PS5 DualSense controller that is interfaced to a HID backend.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualSenseGamepadHID.SetMotorSpeedsAndLightBarColor(System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{UnityEngine.Color})">
             <summary>
             Set motor speeds of both motors and the light bar color simultaneously.
             </summary>
             <param name="lowFrequency"><see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/></param>
             <param name="highFrequency"><see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/></param>
             <param name="color"><see cref="M:UnityEngine.InputSystem.DualShock.IDualShockHaptics.SetLightBarColor(UnityEngine.Color)"/></param>
             <returns>True if the command succeeded. Will return false if another command is currently being processed.</returns>
             <remarks>
             Use this method to set both the motor speeds and the light bar color in the same call. This method exists
             because it is currently not possible to process an input/output control (IOCTL) command while another one
             is in flight. For example, calling <see cref="M:UnityEngine.InputSystem.DualShock.DualSenseGamepadHID.SetMotorSpeeds(System.Single,System.Single)"/> immediately after calling
             <see cref="M:UnityEngine.InputSystem.DualShock.DualSenseGamepadHID.SetLightBarColor(UnityEngine.Color)"/> might result in only the light bar color changing. The <see cref="M:UnityEngine.InputSystem.DualShock.DualSenseGamepadHID.SetMotorSpeeds(System.Single,System.Single)"/>
             call could fail. It is however possible to combine multiple IOCTL instructions into a single command, which
             is what this method does.
            
             See <see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/> and <see cref="M:UnityEngine.InputSystem.DualShock.IDualShockHaptics.SetLightBarColor(UnityEngine.Color)"/>
             for the respective documentation regarding setting rumble and light bar color.</remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID">
            <summary>
            PS4 DualShock controller that is interfaced to a HID backend.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID.SetMotorSpeedsAndLightBarColor(System.Single,System.Single,UnityEngine.Color)">
             <summary>
             Set motor speeds of both motors and the light bar color simultaneously.
             </summary>
             <param name="lowFrequency"><see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/></param>
             <param name="highFrequency"><see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/></param>
             <param name="color"><see cref="M:UnityEngine.InputSystem.DualShock.IDualShockHaptics.SetLightBarColor(UnityEngine.Color)"/></param>
             <returns>True if the command succeeded. Will return false if another command is currently being processed.</returns>
             <remarks>
             Use this method to set both the motor speeds and the light bar color in the same call. This method exists
             because it is currently not possible to process an input/output control (IOCTL) command while another one
             is in flight. For example, calling <see cref="M:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID.SetMotorSpeeds(System.Single,System.Single)"/> immediately after calling
             <see cref="M:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID.SetLightBarColor(UnityEngine.Color)"/> might result in only the light bar color changing. The <see cref="M:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID.SetMotorSpeeds(System.Single,System.Single)"/>
             call could fail. It is however possible to combine multiple IOCTL instructions into a single command, which
             is what this method does.
            
             See <see cref="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)"/> and <see cref="M:UnityEngine.InputSystem.DualShock.IDualShockHaptics.SetLightBarColor(UnityEngine.Color)"/>
             for the respective documentation regarding setting rumble and light bar color.</remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.IDualShockHaptics">
            <summary>
            Extended haptics interface for DualShock controllers.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.IDualShockHaptics.SetLightBarColor(UnityEngine.Color)">
            <summary>
            Set the color of the light bar on the back of the controller.
            </summary>
            <param name="color">Color to use for the light bar. Alpha component is ignored. Also,
            RBG values are clamped into [0..1] range.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.DualShockSupport">
            <summary>
            Adds support for PS4 DualShock controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DualShock.DualShockGamepad">
            <summary>
            A Sony DualShock/DualSense controller.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.touchpadButton">
            <summary>
            Button that is triggered when the touchbar on the controller is pressed down.
            </summary>
            <value>Control representing the touchbar button.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.optionsButton">
            <summary>
            The right side button in the middle section of the controller. Equivalent to
            <see cref="P:UnityEngine.InputSystem.Gamepad.startButton"/>.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.startButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.shareButton">
            <summary>
            The left side button in the middle section of the controller. Equivalent to
            <see cref="P:UnityEngine.InputSystem.Gamepad.selectButton"/>
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.selectButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.L1">
            <summary>
            The left shoulder button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.leftShoulder"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.R1">
            <summary>
            The right shoulder button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.rightShoulder"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.L2">
            <summary>
            The left trigger button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.R2">
            <summary>
            The right trigger button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.rightTrigger"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.L3">
            <summary>
            The left stick press button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.leftStickButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.R3">
            <summary>
            The right stick press button.
            </summary>
            <value>Equivalent to <see cref="P:UnityEngine.InputSystem.Gamepad.rightStickButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.DualShock.DualShockGamepad.current">
            <summary>
            The last used/added DualShock controller.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualShockGamepad.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualShockGamepad.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualShockGamepad.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.DualShock.DualShockGamepad.SetLightBarColor(UnityEngine.Color)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.WebGL.WebGLJoystick">
            <summary>
            A Joystick or Gamepad on WebGL that does not have any known mapping.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.WebGL.WebGLGamepad">
            <summary>
            Gamepad on WebGL that uses the "standard" mapping.
            </summary>
            <seealso href="https://w3c.github.io/gamepad/#remapping"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionPhase">
            <summary>
            Trigger phase of an <see cref="T:UnityEngine.InputSystem.InputAction"/>.
            </summary>
            <remarks>
            Actions can be triggered in steps. For example, a <see cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction">
            'slow tap'</see> will put an action into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> phase when a button
            the action is bound to is pressed. At that point, however, the action still
            has to wait for the expiration of a timer in order to make it a 'slow tap'. If
            the button is release before the timer expires, the action will be <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>
            whereas if the button is held long enough, the action will be <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.phase"/>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionPhase.Disabled">
            <summary>
            The action is not enabled.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionPhase.Waiting">
             <summary>
             The action is enabled and waiting for input on its associated controls.
            
             This is the phase that an action goes back to once it has been <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
             or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionPhase.Started">
             <summary>
             An associated control has been actuated such that it may lead to the action
             being triggered. Will lead to <see cref="E:UnityEngine.InputSystem.InputAction.started"/> getting called.
            
             This phase will only be invoked if there are interactions on the respective control
             binding. Without any interactions, an action will go straight from <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>
             into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> and back into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/> whenever an associated
             control changes value.
            
             An example of an interaction that uses the <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> phase is <see cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction"/>.
             When the button it is bound to is pressed, the associated action goes into the <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
             phase. At this point, the interaction does not yet know whether the button press will result in just
             a tap or will indeed result in slow tap. If the button is released before the time it takes to
             recognize a slow tap, then the action will go to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/> and then back to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>.
             If, however, the button is held long enough for it to qualify as a slow tap, the action will progress
             to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> and then go back to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>.
            
             <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> can be useful for UI feedback. For example, in a game where the weapon can be charged,
             UI feedback can be initiated when the action is <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>.
            
             <example>
             <code>
             fireAction.started +=
                 ctx =>
                 {
                     if (ctx.interaction is SlowTapInteraction)
                     {
                         weaponCharging = true;
                         weaponChargeStartTime = ctx.time;
                     }
                 }
             fireAction.canceled +=
                 ctx =>
                 {
                     weaponCharging = false;
                 }
             fireAction.performed +=
                 ctx =>
                 {
                     Fire();
                     weaponCharging = false;
                 }
             </code>
             </example>
            
             By default, an action is started as soon as a control moves away from its default value. This is
             the case for both <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> actions (which, however, does not yet have to mean
             that the button press threshold has been reached; see <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>)
             and <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> actions. <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> does not use
             the <c>Started</c> phase and instead goes straight to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
            
             For <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> actions, <c>Started</c> will immediately be followed by <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
            
             Note that interactions (see <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>) can alter how an action does or does not progress through
             the phases.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionPhase.Performed">
             <summary>
             The action has been performed. Leads to <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> getting called.
            
             By default, a <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> action performs when a control crosses the button
             press threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>), a <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
             action performs on any value change that isn't the default value, and a <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/>
             action performs on any value change including going back to the default value.
            
             Note that interactions (see <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>) can alter how an action does or does not progress through
             the phases.
            
             For a given action, finding out whether it was performed in the current frame can be done with <see cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/>.
            
             <example>
             <code>
             action.WasPerformedThisFrame();
             </code>
             </example>
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionPhase.Canceled">
             <summary>
             The action has stopped. Leads to <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> getting called.
            
             By default, a <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> action cancels when a control falls back below the button
             press threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>) and a <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
             action cancels when a control moves back to its default value. A <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> action
             does not generally cancel based on input on its controls.
            
             An action will also get canceled when it is disabled while in progress (see <see cref="M:UnityEngine.InputSystem.InputAction.Disable"/>).
             Also, when an <see cref="T:UnityEngine.InputSystem.InputDevice"/> that is
            
             Note that interactions (see <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>) can alter how an action does or does not progress through
             the phases.
             </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Mouse">
             <summary>
             An input device representing a mouse.
             </summary>
             <remarks>
             Adds a scroll wheel and a typical 3-button setup with a left, middle, and right
             button.
            
             To control cursor display and behavior, use <see cref="T:UnityEngine.Cursor"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.scroll">
            <summary>
            The horizontal and vertical scroll wheels.
            </summary>
            <value>Control representing the mouse scroll wheels.</value>
            <remarks>
            The <c>x</c> component corresponds to the horizontal scroll wheel, the
            <c>y</c> component to the vertical scroll wheel. Most mice do not have
            horizontal scroll wheels and will thus only see activity on <c>y</c>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.leftButton">
            <summary>
            The left mouse button.
            </summary>
            <value>Control representing the left mouse button.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.middleButton">
            <summary>
            The middle mouse button.
            </summary>
            <value>Control representing the middle mouse button.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.rightButton">
            <summary>
            The right mouse button.
            </summary>
            <value>Control representing the right mouse button.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.backButton">
            <summary>
            The first side button, often labeled/used as "back".
            </summary>
            <value>Control representing the back button on the mouse.</value>
            <remarks>
            On Windows, this corresponds to <c>RI_MOUSE_BUTTON_4</c>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.forwardButton">
            <summary>
            The second side button, often labeled/used as "forward".
            </summary>
            <value>Control representing the forward button on the mouse.</value>
            <remarks>
            On Windows, this corresponds to <c>RI_MOUSE_BUTTON_5</c>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.clickCount">
            <summary>
            Number of times any of the mouse buttons has been clicked in succession within
            the system-defined click time threshold.
            </summary>
            <value>Control representing the mouse click count.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Mouse.current">
            <summary>
            The mouse that was added or updated last or null if there is no mouse
            connected to the system.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.MakeCurrent">
            <summary>
            Called when the mouse becomes the current mouse.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.OnAdded">
            <summary>
            Called when the mouse is added to the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.OnRemoved">
            <summary>
            Called when the device is removed from the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.WarpCursorPosition(UnityEngine.Vector2)">
            <summary>
            Move the operating system's mouse cursor.
            </summary>
            <param name="position">New position in player window space.</param>
            <remarks>
            The <see cref="P:UnityEngine.InputSystem.Pointer.position"/> property will not update immediately but rather will update in the
            next input update.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.OnNextUpdate">
            <summary>
            Implements <see cref="M:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver.OnNextUpdate"/> for the mouse.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Mouse.OnStateEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Implements <see cref="M:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver.OnStateEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/> for the mouse.
            </summary>
            <param name="eventPtr"></param>
        </member>
        <member name="T:UnityEngine.InputSystem.Switch.LowLevel.SwitchProControllerHIDInputState">
            <summary>
            Structure of HID input reports for Switch Pro controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Switch.SwitchProControllerHID">
            <summary>
            A Nintendo Switch Pro controller connected to a desktop mac/windows PC using the HID interface.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Switch.SwitchSupportHID">
            <summary>
            Adds support for Switch NPad controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.LowLevel.MotionAuthorizationStatus">
            <summary>
            Describes the access for motion related features.
            </summary>
            <remarks>Enum values map values from CoreMotion.framework/Headers/CMAuthorization.h</remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.iOS.LowLevel.MotionAuthorizationStatus.NotDetermined">
            <summary>
            The access status was not yet determined.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.iOS.LowLevel.MotionAuthorizationStatus.Restricted">
            <summary>
            Access was denied due system settings.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.iOS.LowLevel.MotionAuthorizationStatus.Denied">
            <summary>
            Access was denied by the user.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.iOS.LowLevel.MotionAuthorizationStatus.Authorized">
            <summary>
            Access was allowed by the user.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.LowLevel.iOSStepCounter">
             <summary>
             Step Counter (also known as pedometer) sensor for iOS.
             </summary>
             <remarks>
             You need to enable Motion Usage in Input System settings (see <see cref="P:UnityEngine.InputSystem.InputSettings.iOSSettings.motionUsage"/>), to be allowed
             to access the sensor on the user's device.
             <example>
             <code>
             void Start()
             {
                 InputSystem.EnableDevice(StepCounter.current);
             }
            
             void OnGUI()
             {
                 GUILayout.Label(StepCounter.current.stepCounter.ReadValue().ToString());
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.iOSSettings.motionUsage"/>
        </member>
        <member name="M:UnityEngine.InputSystem.iOS.LowLevel.iOSStepCounter.IsAvailable">
            <summary>
            Does the phone support the pedometer?
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.iOS.LowLevel.iOSStepCounter.AuthorizationStatus">
            <summary>
            Indicates whether the app is authorized to gather data for step counter sensor.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.PrivacyDataUsage">
            <summary>
            Governs access to a privacy-related resource on the user's device. Corresponds to a key in the application's
            Information Property List (Info.plist).
            </summary>
            <seealso href="https://developer.apple.com/documentation/bundleresources/information_property_list/protected_resources"/>
        </member>
        <member name="P:UnityEngine.InputSystem.iOS.PrivacyDataUsage.enabled">
             <summary>
             Whether access to the respective resource will be requested.
             </summary>
             <remarks>
             Before accessing a resource or a sensor, you need to explicitly enable the usage for it, otherwise the access for the resource will be denied.
            
             If this is set to true, the respective protected resource key will be entered in the application's Information Property List (Info.plist)
             using <see cref="P:UnityEngine.InputSystem.iOS.PrivacyDataUsage.usageDescription"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.iOS.PrivacyDataUsage.usageDescription">
            <summary>
            Provide meaningful usage description.
            </summary>
            <remarks>
            The description will be presented to the user in the dialog when you'll try to access a related resource or sensor.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.iOSGameController">
            <summary>
            A generic Gamepad connected to an iOS device.
            </summary>
            <remarks>
            Any MFi-certified Gamepad which is not an <see cref="T:UnityEngine.InputSystem.iOS.XboxOneGampadiOS"/> or <see cref="T:UnityEngine.InputSystem.iOS.DualShock4GampadiOS"/> will
            be represented as an iOSGameController.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.XboxOneGampadiOS">
            <summary>
            An Xbox One Bluetooth controller connected to an iOS device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.DualShock4GampadiOS">
            <summary>
            A PlayStation DualShock 4 controller connected to an iOS device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.iOS.DualSenseGampadiOS">
            <summary>
            A PlayStation DualSense controller connected to an iOS device.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.MultiTapInteraction">
            <summary>
            Interaction that requires multiple taps (press and release within <see cref="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapTime"/>) spaced no more
            than <see cref="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapDelay"/> seconds apart. This equates to a chain of <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/> with
            a maximum delay between each tap.
            </summary>
            <remarks>
            The interaction goes into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> on the first press and then will not
            trigger again until either the full tap sequence is performed (in which case the interaction triggers
            <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>) or the multi-tap is aborted by a timeout being hit (in which
            case the interaction will trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>).
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapTime">
            <summary>
            The time in seconds within which the control needs to be pressed and released to perform the interaction.
            </summary>
            <remarks>
            If this value is equal to or smaller than zero, the input system will use (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>) instead.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapDelay">
            <summary>
            The time in seconds which is allowed to pass between taps.
            </summary>
            <remarks>
            If this time is exceeded, the multi-tap interaction is canceled.
            If this value is equal to or smaller than zero, the input system will use the duplicate value of <see cref="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapTime"/> instead.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.tapCount">
            <summary>
            The number of taps required to perform the interaction.
            </summary>
            <remarks>
            How many taps need to be performed in succession. Two means double-tap, three means triple-tap, and so on.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.MultiTapInteraction.pressPoint">
            <summary>
            Magnitude threshold that must be crossed by an actuated control for the control to
            be considered pressed.
            </summary>
            <remarks>
            If this is less than or equal to 0 (the default), <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> is used instead.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Interactions.MultiTapInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Interactions.MultiTapInteraction.Reset">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.MultiTapInteractionEditor">
            <summary>
            UI that is displayed when editing <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> in the editor.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.PressInteraction">
             <summary>
             Performs the action at specific points in a button press-and-release sequence according top <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.behavior"/>.
             </summary>
             <remarks>
             By default, uses <see cref="F:UnityEngine.InputSystem.Interactions.PressBehavior.PressOnly"/> which performs the action as soon as the control crosses the
             button press threshold defined by <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/>. The action then will not trigger again until the control
             is first released.
            
             Can be set to instead trigger on release (that is, when the control goes back below the button press threshold) using
             <see cref="F:UnityEngine.InputSystem.Interactions.PressBehavior.ReleaseOnly"/> or can be set to trigger on both press and release using <see cref="F:UnityEngine.InputSystem.Interactions.PressBehavior.PressAndRelease"/>).
            
             Note that using an explicit press interaction is only necessary if the goal is to either customize the press behavior
             of a button or when binding to controls that are not buttons as such (the press interaction compares magnitudes to
             <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/> and thus any type of control that can deliver a magnitude can act as a button). The default
             behavior available out of the box when binding <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> type actions to button-type controls
             (<see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>) corresponds to using a press modifier with <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.behavior"/>
             set to <see cref="F:UnityEngine.InputSystem.Interactions.PressBehavior.PressOnly"/> and <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/> left at default.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint">
            <summary>
            Amount of actuation required before a control is considered pressed.
            </summary>
            <remarks>
            If zero (default), defaults to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.PressInteraction.behavior">
            <summary>
            Determines how button presses trigger the action.
            </summary>
            <remarks>
            By default (PressOnly), the action is performed on press.
            With ReleaseOnly, the action is performed on release. With PressAndRelease, the action is
            performed on press and on release.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.PressBehavior">
            <summary>
            Determines how to trigger an action based on button presses.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.behavior"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.PressBehavior.PressOnly">
            <summary>
            Perform the action when the button is pressed.
            </summary>
            <remarks>
            Triggers <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> when a control crosses the button press threshold.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.PressBehavior.ReleaseOnly">
            <summary>
            Perform the action when the button is released.
            </summary>
            <remarks>
            Triggers <see cref="E:UnityEngine.InputSystem.InputAction.started"/> when a control crosses the button press threshold and
            <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> when the control goes back below the button press threshold.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.PressBehavior.PressAndRelease">
            <summary>
            Perform the action when the button is pressed and when the button is released.
            </summary>
            <remarks>
            Triggers <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> when a control crosses the button press threshold
            and triggers <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> again when it goes back below the button press
            threshold.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.PressInteractionEditor">
            <summary>
            UI that is displayed when editing <see cref="T:UnityEngine.InputSystem.Interactions.PressInteraction"/> in the editor.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.TapInteraction">
            <summary>
            Performs the action if the control is pressed held for at least the set
            duration (which defaults to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>)
            and then released.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.TapInteraction.duration">
            <summary>
            The time in seconds within which the control needs to be pressed and released to perform the interaction.
            </summary>
            <remarks>
            If this value is equal to or smaller than zero, the input system will use (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>) instead.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.TapInteraction.pressPoint">
            <summary>
            The press point required to perform the interaction.
            </summary>
            <remarks>
            For analog controls (such as trigger axes on a gamepad), the control needs to be engaged by at least this
            value to perform the interaction.
            If this value is equal to or smaller than zero, the input system will use (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>) instead.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.HoldInteraction">
             <summary>
             Performs the action if the control is pressed and held for at least the
             set duration (which defaults to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultHoldTime"/>).
             </summary>
             <remarks>
             The action is started when the control is pressed. If the control is released before the
             set <see cref="F:UnityEngine.InputSystem.Interactions.HoldInteraction.duration"/>, the action is canceled. As soon as the hold time is reached,
             the action performs. The action then stays performed until the control is released, at
             which point the action cancels.
            
             <example>
             <code>
             // Action that requires A button on gamepad to be held for half a second.
             var action = new InputAction(binding: "&lt;Gamepad&gt;/buttonSouth", interactions: "hold(duration=0.5)");
             </code>
             </example>
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.HoldInteraction.duration">
             <summary>
             Duration in seconds that the control must be pressed for the hold to register.
             </summary>
             <remarks>
             If this is less than or equal to 0 (the default), <see cref="P:UnityEngine.InputSystem.InputSettings.defaultHoldTime"/> is used.
            
             Duration is expressed in real time and measured against the timestamps of input events
             (<see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>) not against game time (<see cref="P:UnityEngine.Time.time"/>).
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.HoldInteraction.pressPoint">
            <summary>
            Magnitude threshold that must be crossed by an actuated control for the control to
            be considered pressed.
            </summary>
            <remarks>
            If this is less than or equal to 0 (the default), <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> is used instead.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Interactions.HoldInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Interactions.HoldInteraction.Reset">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.HoldInteractionEditor">
            <summary>
            UI that is displayed when editing <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> in the editor.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction">
            <summary>
            Performs the action if the control is pressed and held for at least the set
            duration (which defaults to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultSlowTapTime"/>)
            and then released.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.SlowTapInteraction.duration">
            <summary>
            The time in seconds within which the control needs to be pressed and released to perform the interaction.
            </summary>
            <remarks>
            If this value is equal to or smaller than zero, the input system will use (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultSlowTapTime"/>) instead.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Interactions.SlowTapInteraction.pressPoint">
            <summary>
            The press point required to perform the interaction.
            </summary>
            <remarks>
            For analog controls (such as trigger axes on a gamepad), the control needs to be engaged by at least this
            value to perform the interaction.
            If this value is equal to or smaller than zero, the input system will use (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>) instead.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.OnScreen.OnScreenControl">
             <summary>
             Base class for on-screen controls.
             </summary>
             <remarks>
             The set of on-screen controls together forms a device. A control layout
             is automatically generated from the set and a device using the layout is
             added to the system when the on-screen controls are enabled.
            
             The layout that the generated layout is based on is determined by the
             control paths chosen for each on-screen control. If, for example, an
             on-screen control chooses the 'a' key from the "Keyboard" layout as its
             path, a device layout is generated that is based on the "Keyboard" layout
             and the on-screen control becomes the 'a' key in that layout.
            
             If a <see cref="T:UnityEngine.GameObject"/> has multiple on-screen controls that reference different
             types of device layouts (e.g. one control references 'buttonWest' on
             a gamepad and another references 'leftButton' on a mouse), then a device
             is created for each type referenced by the setup.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.controlPath">
             <summary>
             The control path (see <see cref="T:UnityEngine.InputSystem.InputControlPath"/>) for the control that the on-screen
             control will feed input into.
             </summary>
             <remarks>
             A device will be created from the device layout referenced by the control path (see
             <see cref="M:UnityEngine.InputSystem.InputControlPath.TryGetDeviceLayout(System.String)"/>). The path is then used to look up
             <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.control"/> on the device. The resulting control will be fed values from
             the on-screen control.
            
             Multiple on-screen controls sharing the same device layout will together create a single
             virtual device. If, for example, one component uses <c>"&lt;Gamepad&gt;/buttonSouth"</c>
             and another uses <c>"&lt;Gamepad&gt;/leftStick"</c> as the control path, a single
             <see cref="T:UnityEngine.InputSystem.Gamepad"/> will be created and the first component will feed data to
             <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/> and the second component will feed data to
             <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.control">
            <summary>
            The actual control that is fed input from the on-screen control.
            </summary>
            <remarks>
            This is only valid while the on-screen control is enabled. Otherwise, it is <c>null</c>. Also,
            if no <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.controlPath"/> has been set, this will remain <c>null</c> even if the component is enabled.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.controlPathInternal">
            <summary>
            Accessor for the <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.controlPath"/> of the component. Must be implemented by subclasses.
            </summary>
            <remarks>
            Moving the definition of how the control path is stored into subclasses allows them to
            apply their own <see cref="T:UnityEngine.InputSystem.Layouts.InputControlAttribute"/> attributes to them and thus set their
            own layout filters.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.OnScreen.OnScreenButton">
            <summary>
            A button that is visually represented on-screen and triggered by touch or other pointer
            input.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.OnScreen.OnScreenSupport">
            <summary>
            Support for various forms of on-screen controls.
            </summary>
            <remarks>
            On-screen input visually represents control elements either through (potentially) built-in
            mechanisms like <see cref="!:OnScreenKeyboard"/> or through manually arranged control setups
            in the form of <see cref="T:UnityEngine.InputSystem.OnScreen.OnScreenControl">OnScreenControls</see>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.OnScreen.OnScreenStick">
             <summary>
             A stick control displayed on screen and moved around by touch or other pointer
             input.
             </summary>
             <remarks>
             The <see cref="T:UnityEngine.InputSystem.OnScreen.OnScreenStick"/> works by simulating events from the device specified in the <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenControl.controlPath"/>
             property. Some parts of the Input System, such as the <see cref="T:UnityEngine.InputSystem.PlayerInput"/> component, can be set up to
             auto-switch to a new device when input from them is detected. When a device is switched, any currently running
             inputs from the previously active device are cancelled. In the case of <see cref="T:UnityEngine.InputSystem.OnScreen.OnScreenStick"/>, this can mean that the
             <see cref="M:UnityEngine.EventSystems.IPointerUpHandler.OnPointerUp(UnityEngine.EventSystems.PointerEventData)"/> method will be called and the stick will jump back to center, even though
             the pointer input has not physically been released.
            
             To avoid this situation, set the <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.useIsolatedInputActions"/> property to true. This will create a set of local
             Input Actions to drive the stick that are not cancelled when device switching occurs.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.OnScreen.OnScreenStick.OnPointerDown(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Callback to handle OnPointerDown UI events.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.OnScreen.OnScreenStick.OnDrag(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Callback to handle OnDrag UI events.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.OnScreen.OnScreenStick.OnPointerUp(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Callback to handle OnPointerUp UI events.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.movementRange">
            <summary>
            The distance from the onscreen control's center of origin, around which the control can move.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.dynamicOriginRange">
            <summary>
            Defines the circular region where the onscreen control may have it's origin placed.
            </summary>
            <remarks>
            This only applies if <see cref="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.behaviour"/> is set to <see cref="F:UnityEngine.InputSystem.OnScreen.OnScreenStick.Behaviour.ExactPositionWithDynamicOrigin"/>.
            When the first press is within this region, then the control will appear at that position and have it's origin of motion placed there.
            Otherwise, if pressed outside of this region the control will ignore it.
            This property defines the radius of the circular region. The center point being defined by the component position in the scene.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.useIsolatedInputActions">
             <summary>
             Prevents stick interactions from getting cancelled due to device switching.
             </summary>
             <remarks>
             This property is useful for scenarios where the active device switches automatically
             based on the most recently actuated device. A common situation where this happens is
             when using a <see cref="T:UnityEngine.InputSystem.PlayerInput"/> component with Auto-switch set to true. Imagine
             a mobile game where an on-screen stick simulates the left stick of a gamepad device.
             When the on-screen stick is moved, the Input System will see an input event from a gamepad
             and switch the active device to it. This causes any active actions to be cancelled, including
             the pointer action driving the on screen stick, which results in the stick jumping back to
             the center as though it had been released.
            
             In isolated mode, the actions driving the stick are not cancelled because they are
             unique Input Action instances that don't share state with any others.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.OnScreen.OnScreenStick.behaviour">
            <summary>Defines how the onscreen stick will move relative to it's origin and the press position.</summary>
        </member>
        <member name="T:UnityEngine.InputSystem.OnScreen.OnScreenStick.Behaviour">
            <summary>Defines how the onscreen stick will move relative to it's center of origin and the press position.</summary>
        </member>
        <member name="F:UnityEngine.InputSystem.OnScreen.OnScreenStick.Behaviour.RelativePositionWithStaticOrigin">
            <summary>The control's center of origin is fixed in the scene.
            The control will begin un-actuated at it's centered position and then move relative to the press motion.</summary>
        </member>
        <member name="F:UnityEngine.InputSystem.OnScreen.OnScreenStick.Behaviour.ExactPositionWithStaticOrigin">
            <summary>The control's center of origin is fixed in the scene.
            The control may begin from an actuated position to ensure it is always tracking the current press position.</summary>
        </member>
        <member name="F:UnityEngine.InputSystem.OnScreen.OnScreenStick.Behaviour.ExactPositionWithDynamicOrigin">
            <summary>The control's center of origin is determined by the initial press position.
            The control will begin unactuated at this center position and then track the current press position.</summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputManager">
             <summary>
             Hub of the input system.
             </summary>
             <remarks>
             Not exposed. Use <see cref="T:UnityEngine.InputSystem.InputSystem"/> as the public entry point to the system.
            
             Manages devices, layouts, and event processing.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputManager.runPlayerUpdatesInEditMode">
             <summary>
             If true, consider the editor to be in "perpetual play mode". Meaning, we ignore editor
             updates and just go and continuously process Dynamic/Fixed/BeforeRender regardless of
             whether we're in play mode or not.
            
             In this mode, we also ignore game view focus.
             </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.IsDeviceLayoutMarkedAsSupportedInSettings(UnityEngine.InputSystem.Utilities.InternedString)">
            <summary>
            Return true if the given device layout is supported by the game according to <see cref="P:UnityEngine.InputSystem.InputSettings.supportedDevices"/>.
            </summary>
            <param name="layoutName">Name of the device layout.</param>
            <returns>True if a device with the given layout should be created for the game, false otherwise.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.GetControls``1(System.String,UnityEngine.InputSystem.InputControlList{``0}@)">
            <summary>
            Adds to the given list all controls that match the given <see cref="T:UnityEngine.InputSystem.InputControlPath">path spec</see>
            and are assignable to the given type.
            </summary>
            <param name="path"></param>
            <param name="controls"></param>
            <typeparam name="TControl"></typeparam>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.InitializeDefaultState(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Initialize default state for given device.
             </summary>
             <param name="device">A newly added input device.</param>
             <remarks>
             For every device, one copy of its state is kept around which is initialized with the default
             values for the device. If the device has no control that has an explicitly specified control
             value, the buffer simply contains all zeroes.
            
             The default state buffer is initialized once when a device is added to the system and then
             migrated by <see cref="T:UnityEngine.InputSystem.LowLevel.InputStateBuffers"/> like other device state and removed when the device
             is removed from the system.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.ApplySettings">
            <summary>
            Apply the settings in <see cref="F:UnityEngine.InputSystem.InputManager.m_Settings"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.OnUpdate(UnityEngine.InputSystem.LowLevel.InputUpdateType,UnityEngine.InputSystem.LowLevel.InputEventBuffer@)">
             <summary>
             Process input events.
             </summary>
             <param name="updateType"></param>
             <param name="eventBuffer"></param>
             <remarks>
             This method is the core workhorse of the input system. It is called from <see cref="T:UnityEngineInternal.Input.NativeInputSystem"/>.
             Usually this happens in response to the player loop running and triggering updates at set points. However,
             updates can also be manually triggered through <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
            
             The method receives the event buffer used internally by the runtime to collect events.
            
             Note that update types do *NOT* say what the events we receive are for. The update type only indicates
             where in the Unity's application loop we got called from. Where the event data goes depends wholly on
             which buffers we activate in the update and write the event data into.
             </remarks>
             <exception cref="T:System.InvalidOperationException">Thrown if OnUpdate is called recursively.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.UpdateState(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputUpdateType,System.Void*,System.UInt32,System.UInt32,System.Double,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             This method is the workhorse for updating input state in the system. It runs all the logic of incorporating
             new state into devices and triggering whatever change monitors are attached to the state memory that gets
             touched.
             </summary>
             <remarks>
             This method can be invoked from outside the event processing loop and the given data does not have to come
             from an event.
            
             This method does NOT respect <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver"/>. This means that the device will
             NOT get a shot at intervening in the state write.
             </remarks>
             <param name="device">Device to update state on. <paramref name="stateOffsetInDevice"/> is relative to device's
             starting offset in memory.</param>
             <param name="eventPtr">Pointer to state event from which the state change was initiated. Null if the state
             change is not coming from an event.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.InputManager.SerializedState">
             <summary>
             State we take across domain reloads.
             </summary>
             <remarks>
             Most of the state we re-recreate in-between reloads and do not store
             in this structure. In particular, we do not preserve anything from
             the various RegisterXXX().
            
             WARNING
            
             Making changes to serialized data format will likely to break upgrading projects from older versions.
             That is until you restart the editor, then we recreate everything from clean state.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputManager.RestoreDevicesAfterDomainReload">
             <summary>
             Recreate devices based on the devices we had before a domain reload.
             </summary>
             <remarks>
             Note that device indices may change between domain reloads.
            
             We recreate devices using the layout information as it exists now as opposed to
             as it existed before the domain reload. This means we'll be picking up any changes that
             have happened to layouts as part of the reload (including layouts having been removed
             entirely).
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.DynamicBitfield">
            <summary>
            Struct replacement for System.Collections.Bitfield.
            </summary>
            <remarks>
            We don't want the extra heap object just for keeping the header
            state of the bitfield. This struct directly embeds the header
            into the owner. Also doesn't allocate any array while length is
            less than or equal to 64 bits.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Linux.LinuxSupport">
            <summary>
            A small helper class to aid in initializing and registering SDL devices and layout builders.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Linux.LinuxSupport.kInterfaceName">
            <summary>
            The current interface code sent with devices to identify as Linux SDL devices.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Linux.LinuxSupport.Initialize">
            <summary>
            Registers all initial templates and the generalized layout builder with the InputSystem.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Pointer">
             <summary>
             Base class for pointer-style devices moving on a 2D screen.
             </summary>
             <remarks>
             This class abstracts over general "pointing" behavior where a pointer is moved across a 2D
             surface. Operating at the <c>Pointer</c> level allows treating <see>Mouse</see>, <see>Pen</see>,
             and <see>Touchscreen</see> all as pointers with a set of shared behaviors.
            
             Note that a pointer may have "multi-point" ability as is the case with multi-touch where
             multiple touches represent multiple concurrent "pointers". However, for any pointer device
             with multiple pointers, only one pointer is considered "primary" and drives the pointer
             controls present on the base class.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Mouse"/>
             <seealso cref="T:UnityEngine.InputSystem.Pen"/>
             <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.position">
             <summary>
             The current pointer coordinates in window space.
             </summary>
             <value>Control representing the current position of the pointer on screen.</value>
             <remarks>
             Within player code, the coordinates are in the coordinate space of Unity's <c>Display</c>.
            
             Within editor code, the coordinates are in the coordinate space of the current <c>EditorWindow</c>
             This means that if you query the <see cref="T:UnityEngine.InputSystem.Mouse"/> <see cref="P:UnityEngine.InputSystem.Pointer.position"/> in <c>EditorWindow.OnGUI</c>, for example,
             the returned 2D vector will be in the coordinate space of your local GUI (same as
             <c>Event.mousePosition</c>).
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.delta">
             <summary>
             The current window-space motion delta of the pointer.
             </summary>
             <value>Control representing the motion delta of the pointer.</value>
             <remarks>
             Every time a pointer is moved, it generates a motion delta. This control represents
             this motion.
            
             Note that some pointers have the ability to generate motion deltas <em>without</em>
             actually changing the position of the pointer. This is the case for <see cref="T:UnityEngine.InputSystem.Mouse"/>
             which even when, for example, bumping up against the edges of the screen or when being
             locked in place, can generate motion. This means that activity on <c>delta</c> is not
             necessarily correlated with activity on <see cref="P:UnityEngine.InputSystem.Pointer.position"/>.
            
             Deltas have two special behaviors attached to them that makes them quite unique
             among input controls.
            
             For one, deltas will automatically reset to <c>(0,0)</c> between frames. If, for example,
             the current delta value is <c>(12,8)</c>, then after the next <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>,
             the delta is automatically set to <c>(0,0)</c>. More precisely, deltas will reset as part
             of <see cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>. This happens every time regardless of whether
             there are pending motion events for the pointer or not. But because it happens in
             <see cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/> (that is, <em>before</em> events are processed),
             subsequent motion deltas are incorporated normally.
            
             Note that the resetting is visible to <see cref="T:UnityEngine.InputSystem.InputAction"/>s. This means that when
             binding to a delta control from an action that is not using <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/>,
             you will see the action getting cancelled at the start of every frame. With a <c>PassThrough</c>
             actions, you will instead see it perform one extra time with a zero value.
            
             The other special behavior of deltas is accumulation. When receiving more than one
             motion update in a frame, deltas will not simply switch from one value to the other
             but instead accumulate them. For example, if two events are received for a pointer
             in a frame and one has a motion delta of <c>(1,1)</c> and the other has a motion delta
             of <c>(2,2)</c>, then once <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> has finished processing
             events, the value of the delta control will be <c>(3,3)</c> and not <c>(2,2)</c>.
            
             Note that just like resetting, accumulation is also visible to <see cref="T:UnityEngine.InputSystem.InputAction"/>s.
             This means that because the delta control changes value twice, the action will trigger
             twice but the value when it is triggered the second time will be <c>(3,3)</c> and
             not <c>(2,2)</c> even though that's the value received from the event.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.AccumulateValueInEvent(UnityEngine.InputSystem.InputControl{System.Single},System.Void*,UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.radius">
            <summary>
            Window-space radius of the pointer contact with the surface.
            </summary>
            <value>Control representing the horizontal and vertical extents of the pointer contact.</value>
            <remarks>
            Usually, only touch input has radius detection.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.radius"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.pressure">
             <summary>
             Normalized pressure with which the pointer is currently pressed while in contact with the pointer surface.
             </summary>
             <value>Control representing the pressure with which the pointer is pressed down.</value>
             <remarks>
             This is only meaningful for pointing devices that support pressure. Mice do not, pens usually do, and touch
             usually does on mobile platforms.
            
             Note that it is possible for the value to go above 1 even though it is considered normalized. The reason is
             that calibration on the system can put the maximum pressure point below the physically supported maximum value.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.press">
            <summary>
            Whether the pointer is pressed down.
            </summary>
            <remarks>
            What this means exactly depends on the nature of the pointer. For mice (<see cref="T:UnityEngine.InputSystem.Mouse"/>), it means
            that the left button is pressed. For pens (<see cref="T:UnityEngine.InputSystem.Pen"/>), it means that the pen tip is touching
            the screen/tablet surface. For touchscreens (<see cref="T:UnityEngine.InputSystem.Touchscreen"/>), it means that there is at least
            one finger touching the screen.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.displayIndex">
            <summary>
            The index of the display the Pointer is currently on. This is useful for multiple screen setups.
            This may not be supported on all platforms. When unsupported, this will always produce the index of the primary display i.e. zero.
            <see href="https://docs.unity3d.com/ScriptReference/Display.html"/>
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Pointer.current">
            <summary>
            The pointer that was added or used last by the user or <c>null</c> if there is no pointer
            device connected to the system.
            </summary>
            <value>Currently active <c>Pointer</c> or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Pointer.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Pointer.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Pointer.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Pointer.OnNextUpdate">
            <summary>
            Called whenever the input system advances by one frame.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Pointer.OnStateEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Called when the pointer receives a state event.
            </summary>
            <param name="eventPtr">The input event.</param>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSystem">
             <summary>
             This is the central hub for the input system.
             </summary>
             <remarks>
             This class has the central APIs for working with the input system. You
             can manage devices available in the system (<see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>,
             <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> and related APIs) or extend
             the input system with custom functionality (<see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>,
             <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction``1(System.String)"/>, <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>,
             <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>, and related APIs).
            
             To control haptics globally, you can use <see cref="M:UnityEngine.InputSystem.InputSystem.PauseHaptics"/>, <see cref="M:UnityEngine.InputSystem.InputSystem.ResumeHaptics"/>,
             and <see cref="M:UnityEngine.InputSystem.InputSystem.ResetHaptics"/>.
            
             To enable and disable individual devices (such as <see cref="T:UnityEngine.InputSystem.Sensor"/> devices),
             you can use <see cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/> and <see cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>.
            
             The input system is initialized as part of Unity starting up. It is generally safe
             to call the APIs here from any of Unity's script callbacks.
            
             Note that, like most Unity APIs, most of the properties and methods in this API can only
             be called on the main thread. However, select APIs like <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/> can be
             called from threads. Where this is the case, it is stated in the documentation.
             </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onLayoutChange">
             <summary>
             Event that is signalled when the layout setup in the system changes.
             </summary>
             <remarks>
             First parameter is the name of the layout that has changed and second parameter is the
             type of change that has occurred.
            
             <example>
             <code>
             InputSystem.onLayoutChange +=
                 (name, change) =>
                 {
                     switch (change)
                     {
                         case InputControlLayoutChange.Added:
                             Debug.Log($"New layout {name} has been added");
                             break;
                         case InputControlLayoutChange.Removed:
                             Debug.Log($"Layout {name} has been removed");
                             break;
                         case InputControlLayoutChange.Replaced:
                             Debug.Log($"Layout {name} has been updated");
                             break;
                     }
                 }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})">
             <summary>
             Register a control layout based on a type.
             </summary>
             <param name="type">Type to derive a control layout from. Must be derived from <see cref="T:UnityEngine.InputSystem.InputControl"/>.</param>
             <param name="name">Name to use for the layout. If null or empty, the short name of the type (<c>Type.Name</c>) will be used.</param>
             <param name="matches">Optional device matcher. If this is supplied, the layout will automatically
             be instantiated for newly discovered devices that match the description.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
             <remarks>
             When the layout is instantiated, the system will reflect on all public fields and properties of the type
             which have a value type derived from <see cref="T:UnityEngine.InputSystem.InputControl"/> or which are annotated with <see cref="T:UnityEngine.InputSystem.Layouts.InputControlAttribute"/>.
            
             The type can be annotated with <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute"/> for additional options
             but the attribute is not necessary for a type to be usable as a control layout. Note that if the type
             does have <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute"/> and has set <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.stateType"/>,
             the system will <em>not</em> reflect on properties and fields in the type but do that on the given
             state type instead.
            
             <example>
             <code>
             // InputControlLayoutAttribute attribute is only necessary if you want
             // to override default behavior that occurs when registering your device
             // as a layout.
             // The most common use of InputControlLayoutAttribute is to direct the system
             // to a custom "state struct" through the `stateType` property. See below for details.
             [InputControlLayout(displayName = "My Device", stateType = typeof(MyDeviceState))]
             #if UNITY_EDITOR
             [InitializeOnLoad]
             #endif
             public class MyDevice : InputDevice
             {
                 public ButtonControl button { get; private set; }
                 public AxisControl axis { get; private set; }
            
                 // Register the device.
                 static MyDevice()
                 {
                     // In case you want instance of your device to automatically be created
                     // when specific hardware is detected by the Unity runtime, you have to
                     // add one or more "device matchers" (InputDeviceMatcher) for the layout.
                     // These matchers are compared to an InputDeviceDescription received from
                     // the Unity runtime when a device is connected. You can add them either
                     // using InputSystem.RegisterLayoutMatcher() or by directly specifying a
                     // matcher when registering the layout.
                     InputSystem.RegisterLayout&lt;MyDevice&gt;(
                         // For the sake of demonstration, let's assume your device is a HID
                         // and you want to match by PID and VID.
                         matches: new InputDeviceMatcher()
                             .WithInterface("HID")
                             .WithCapability("PID", 1234)
                             .WithCapability("VID", 5678));
                 }
            
                 // This is only to trigger the static class constructor to automatically run
                 // in the player.
                 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
                 private static void InitializeInPlayer() {}
            
                 protected override void FinishSetup()
                 {
                     base.FinishSetup();
                     button = GetChildControl&lt;ButtonControl&gt;("button");
                     axis = GetChildControl&lt;AxisControl&gt;("axis");
                 }
             }
            
             // A "state struct" describes the memory format used by a device. Each device can
             // receive and store memory in its custom format. InputControls are then connected
             // the individual pieces of memory and read out values from them.
             [StructLayout(LayoutKind.Explicit, Size = 32)]
             public struct MyDeviceState : IInputStateTypeInfo
             {
                 // In the case of a HID (which we assume for the sake of this demonstration),
                 // the format will be "HID". In practice, the format will depend on how your
                 // particular device is connected and fed into the input system.
                 // The format is a simple FourCC code that "tags" state memory blocks for the
                 // device to give a base level of safety checks on memory operations.
                 public FourCC format => return new FourCC('H', 'I', 'D');
            
                 // InputControlAttributes on fields tell the input system to create controls
                 // for the public fields found in the struct.
            
                 // Assume a 16bit field of buttons. Create one button that is tied to
                 // bit #3 (zero-based). Note that buttons do not need to be stored as bits.
                 // They can also be stored as floats or shorts, for example.
                 [InputControl(name = "button", layout = "Button", bit = 3)]
                 public ushort buttons;
            
                 // Create a floating-point axis. The name, if not supplied, is taken from
                 // the field.
                 [InputControl(layout = "Axis")]
                 public short axis;
             }
             </code>
             </example>
            
             Note that if <paramref name="matches"/> is supplied, it will immediately be matched
             against the descriptions (<see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/>) of all available devices.
             If it matches any description where no layout matched before, a new device will immediately
             be created (except if suppressed by <see cref="P:UnityEngine.InputSystem.InputSettings.supportedDevices"/>). If it
             matches a description better (see <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.MatchPercentage(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>) than
             the currently used layout, the existing device will be a removed and a new device with
             the newly registered layout will be created.
            
             See <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/> or <see cref="T:UnityEngine.InputSystem.Gamepad"/> for examples of layouts.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})">
            <summary>
            Register a type as a control layout.
            </summary>
            <typeparam name="T">Type to derive a control layout from.</typeparam>
            <param name="name">Name to use for the layout. If null or empty, the short name of the type will be used.</param>
            <param name="matches">Optional device matcher. If this is supplied, the layout will automatically
            be instantiated for newly discovered devices that match the description.</param>
            <remarks>
            This method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/> with
            <c>typeof(T)</c>. See that method for details of the layout registration process.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})">
             <summary>
             Register a layout in JSON format.
             </summary>
             <param name="json">JSON data describing the layout.</param>
             <param name="name">Optional name of the layout. If null or empty, the name is taken from the "name"
             property of the JSON data. If it is supplied, it will override the "name" property if present. If neither
             is supplied, an <see cref="T:System.ArgumentException"/> is thrown.</param>
             <param name="matches">Optional device matcher. If this is supplied, the layout will automatically
             be instantiated for newly discovered devices that match the description.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is null or empty.</exception>
             <exception cref="T:System.ArgumentException">No name has been supplied either through <paramref name="name"/>
             or the "name" JSON property.</exception>
             <remarks>
             The JSON format makes it possible to create new device and control layouts completely
             in data. They have to ultimately be based on a layout backed by a C# type, however (e.g.
             <see cref="T:UnityEngine.InputSystem.Gamepad"/>).
            
             Note that most errors in layouts will only be detected when instantiated (i.e. when a device or control is
             being created from a layout). The JSON data will, however, be parsed once on registration to check for a
             device description in the layout. JSON format errors will thus be detected during registration.
            
             <example>
             <code>
             InputSystem.RegisterLayout(@"
                {
                    ""name"" : ""MyDevice"",
                    ""controls"" : [
                        {
                            ""name"" : ""myButton"",
                            ""layout"" : ""Button""
                        }
                    ]
                }
             );
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveLayout(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutOverride(System.String,System.String)">
             <summary>
             Register a layout that applies overrides to one or more other layouts.
             </summary>
             <param name="json">Layout in JSON format.</param>
             <param name="name">Optional name of the layout. If null or empty, the name is taken from the "name"
             property of the JSON data. If it is supplied, it will override the "name" property if present. If neither
             is supplied, an <see cref="T:System.ArgumentException"/> is thrown.</param>
             <remarks>
             Layout overrides are layout pieces that are applied on top of existing layouts.
             This can be used to modify any layout in the system non-destructively. The process works the
             same as extending an existing layout except that instead of creating a new layout
             by merging the derived layout and the base layout, the overrides are merged
             directly into the base layout.
            
             The layout merging logic used for overrides, is the same as the one used for
             derived layouts, i.e. <see cref="M:UnityEngine.InputSystem.Layouts.InputControlLayout.MergeLayout(UnityEngine.InputSystem.Layouts.InputControlLayout)"/>.
            
             Layouts used as overrides look the same as normal layouts and have the same format.
             The only difference is that they are explicitly registered as overrides.
            
             Note that unlike "normal" layouts, layout overrides have the ability to extend
             multiple base layouts. The changes from the override will simply be merged into
             each of the layouts it extends. Use the <c>extendMultiple</c> rather than the
             <c>extend</c> property in JSON to give a list of base layouts instead of a single
             one.
            
             <example>
             <code>
             // Override default button press points on the gamepad triggers.
             InputSystem.RegisterLayoutOverride(@"
                 {
                     ""name"" : ""CustomTriggerPressPoints"",
                     ""extend"" : ""Gamepad"",
                     ""controls"" : [
                         { ""name"" : ""leftTrigger"", ""parameters"" : ""pressPoint=0.25"" },
                         { ""name"" : ""rightTrigger"", ""parameters"" : ""pressPoint=0.25"" }
                     ]
                 }
             ");
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)">
             <summary>
             Add an additional device matcher to an existing layout.
             </summary>
             <param name="layoutName">Name of the device layout that should be instantiated if <paramref name="matcher"/>
             matches an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> of a discovered device.</param>
             <param name="matcher">Specification to match against <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> instances.</param>
             <remarks>
             Each device layout can have zero or more matchers associated with it. If any one of the
             matchers matches a given <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> (see <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.MatchPercentage(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>)
             better than any other matcher (for the same or any other layout), then the given layout
             will be used for the discovered device.
            
             Note that registering a matcher may immediately lead to devices being created or recreated.
             If <paramref name="matcher"/> matches any devices currently on the list of unsupported devices
             (see <see cref="M:UnityEngine.InputSystem.InputSystem.GetUnsupportedDevices"/>), new <see cref="T:UnityEngine.InputSystem.InputDevice"/>s will be created
             using the layout called <paramref name="layoutName"/>. Also, if <paramref name="matcher"/>
             matches the description of a device better than the matcher (if any) for the device's currently
             used layout, the device will be recreated using the given layout.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="layoutName"/> is <c>null</c> or empty/</exception>
             <exception cref="T:System.ArgumentException"><paramref name="matcher"/> is empty (<see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.empty"/>).</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryFindMatchingLayout(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher``1(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)">
            <summary>
            Add an additional device matcher to the layout registered for <typeparamref name="TDevice"/>.
            </summary>
            <param name="matcher">A device matcher.</param>
            <typeparam name="TDevice">Type that has been registered as a layout. See <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>.</typeparam>
            <remarks>
            Calling this method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
            with the name under which <typeparamref name="TDevice"/> has been registered.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="matcher"/> is empty (<see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.empty"/>)
            -or- <typeparamref name="TDevice"/> has not been registered as a layout.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})">
             <summary>
             Register a builder that delivers an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> instance on demand.
             </summary>
             <param name="buildMethod">Method to invoke to generate a layout when the layout is chosen.
             Should not cache the layout but rather return a fresh instance every time.</param>
             <param name="name">Name under which to register the layout. If a layout with the same
             name is already registered, the call to this method will replace the existing layout.</param>
             <param name="baseLayout">Name of the layout that the layout returned from <paramref name="buildMethod"/>
             will be based on. The system needs to know this in advance in order to update devices
             correctly if layout registrations in the system are changed.</param>
             <param name="matches">Optional matcher for an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/>. If supplied,
             it is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="buildMethod"/> is <c>null</c> -or-
             <paramref name="name"/> is <c>null</c> or empty.</exception>
             <remarks>
             Layout builders are most useful for procedurally building device layouts from metadata
             supplied by external systems. A good example is <see cref="N:UnityEngine.InputSystem.HID"/> where the "HID" standard
             includes a way for input devices to describe their various inputs and outputs in the form
             of a <see cref="T:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor"/>. While not sufficient to build a perfectly robust
             <see cref="T:UnityEngine.InputSystem.InputDevice"/>, these descriptions are usually enough to at least make the device
             work out-of-the-box to some extent.
            
             The builder method would usually use <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder"/> to build the
             actual layout.
            
             <example>
             <code>
             InputSystem.RegisterLayoutBuilder(
                 () =>
                 {
                     var builder = new InputControlLayout.Builder()
                         .WithType&lt;MyDevice&gt;();
                     builder.AddControl("button1").WithLayout("Button");
                     return builder.Build();
                 }, "MyCustomLayout"
             }
             </code>
             </example>
            
             Layout builders can be used in combination with <see cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/> to
             build layouts dynamically for devices as they are connected to the system.
            
             Be aware that the same builder <em>must</em> not build different layouts. Each
             layout registered in the system is considered to be immutable for as long as it
             is registered. So, if a layout builder is registered under the name "Custom", for
             example, then every time the builder is invoked, it must return the same identical
             <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterPrecompiledLayout``1(System.String)">
             <summary>
             Register a "baked" version of a device layout.
             </summary>
             <typeparam name="TDevice">C# class that represents the precompiled version of the device layout that the
             class is derived from.</typeparam>
             <param name="metadata">Metadata automatically generated for the precompiled layout.</param>
             <remarks>
             This method is used to register device implementations for which their layout has been "baked" into
             a C# class. To generate such a class, right-click a device layout in the input debugger and select
             "Generate Precompiled Layout". This generates a C# file containing a class that represents the precompiled
             version of the device layout. The class can be registered using this method.
            
             Note that registering a precompiled layout will not implicitly register the "normal" version of the layout.
             In other words, <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/> must be called before calling this method.
            
             <example>
             <code>
             // Register the non-precompiled, normal version of the layout.
             InputSystem.RegisterLayout&lt;MyDevice&gt;();
            
             // Register a precompiled version of the layout.
             InputSystem.RegisterPrecompiledLayout&lt;PrecompiledMyDevice&gt;(PrecompiledMyDevice.metadata);
            
             // This implicitly uses the precompiled version.
             InputSystem.AddDevice&lt;MyDevice&gt;();
             </code>
             </example>
            
             The main advantage of precompiled layouts is that instantiating them is many times faster than the default
             device creation path. By default, when creating an <see cref="T:UnityEngine.InputSystem.InputDevice"/>, the system will have to load
             the <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> for the device as well as any layouts used directly or indirectly by
             that layout. This in itself is a slow process that generates GC heap garbage and uses .NET reflection (which
             itself may add additional permanent data to the GC heap). In addition, interpreting the layouts to construct
             an <see cref="T:UnityEngine.InputSystem.InputDevice"/> and populate it with <see cref="T:UnityEngine.InputSystem.InputControl"/> children is not a fast process.
            
             A precompiled layout, however, has all necessary construction steps "baked" into the generated code. It will
             not use reflection and will generally generate little to no GC heap garbage.
            
             A precompiled layout derives from the C# device class whose layout is "baked". If, for example, you generate
             a precompiled version for <see cref="T:UnityEngine.InputSystem.Keyboard"/>, the resulting class will be derived from <see cref="T:UnityEngine.InputSystem.Keyboard"/>.
             When registering the precompiled layout. If someone afterwards creates a <see cref="T:UnityEngine.InputSystem.Keyboard"/>, the precompiled
             version will implicitly be instantiated and thus skips the default device creation path that will construct
             a <see cref="T:UnityEngine.InputSystem.Keyboard"/> device from an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> (it will thus not require the
             <see cref="T:UnityEngine.InputSystem.Keyboard"/> layout or any other layout it depends on to be loaded).
            
             Note that when layout overrides (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutOverride(System.String,System.String)"/>) or new versions of
             existing layouts are registered (e.g. if you replace the built-in "Button" layout by registering
             a new layout with that name), precompiled layouts affected by the change will automatically be
             <em>removed</em>. This causes the system to fall back to the default device creation path which can
             take runtime layout changes into account.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RemoveLayout(System.String)">
             <summary>
             Remove an already registered layout from the system.
             </summary>
             <param name="name">Name of the layout to remove. Note that layout names are case-insensitive.</param>
             <remarks>
             Note that removing a layout also removes all devices that directly or indirectly
             use the layout.
            
             This method can be used to remove both control or device layouts.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TryFindMatchingLayout(UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
             <summary>
             Try to match a description for an input device to a layout.
             </summary>
             <param name="deviceDescription">Description of an input device.</param>
             <returns>Name of the layout that has been matched to the given description or null if no
             matching layout was found.</returns>
             <remarks>
             This method performs the same matching process that is invoked if a device is reported
             by the Unity runtime or using <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>. The result
             depends on the matches (<see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>) registered for the device
             layout in the system.
            
             <example>
             <code>
             var layoutName = InputSystem.TryFindMatchingLayout(
                 new InputDeviceDescription
                 {
                     interface = "XInput",
                     product = "Xbox Wired Controller",
                     manufacturer = "Microsoft"
                 }
             );
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher``1(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListLayouts">
            <summary>
            Return a list with the names of all layouts that have been registered.
            </summary>
            <returns>A list of layout names.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListLayoutsBasedOn(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListLayoutsBasedOn(System.String)">
             <summary>
             List all the layouts that are based on the given layout.
             </summary>
             <param name="baseLayout">Name of a registered layout.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="baseLayout"/> is <c>null</c> or empty.</exception>
             <returns>The names of all registered layouts based on <paramref name="baseLayout"/>.</returns>
             <remarks>
             The list will not include layout overrides (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutOverride(System.String,System.String)"/>).
            
             <example>
             <code>
             // List all gamepad layouts in the system.
             Debug.Log(string.Join("\n", InputSystem.ListLayoutsBasedOn("Gamepad"));
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)">
             <summary>
             Load a registered layout.
             </summary>
             <param name="name">Name of the layout to load. Note that layout names are case-insensitive.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
             <returns>The constructed layout instance or <c>null</c> if no layout of the given name could be found.</returns>
             <remarks>
             The result of this method is what's called a "fully merged" layout, i.e. a layout with
             the information of all the base layouts as well as from all overrides merged into it. See
             <see cref="M:UnityEngine.InputSystem.Layouts.InputControlLayout.MergeLayout(UnityEngine.InputSystem.Layouts.InputControlLayout)"/> for details.
            
             What this means in practice is that all inherited controls and settings will be present
             on the layout.
            
             <example>
             // List all controls defined for gamepads.
             var gamepadLayout = InputSystem.LoadLayout("Gamepad");
             foreach (var control in gamepadLayout.controls)
             {
                 // There may be control elements that are not introducing new controls but rather
                 // change settings on controls added indirectly by other layouts referenced from
                 // Gamepad. These are not adding new controls so we skip them here.
                 if (control.isModifyingExistingControl)
                     continue;
            
                 Debug.Log($"Control: {control.name} ({control.layout])");
             }
             </example>
            
             However, note that controls which are added from other layouts referenced by the loaded layout
             will not necessarily be visible on it (they will only if referenced by a <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem"/>
             where <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isModifyingExistingControl"/> is <c>true</c>).
             For example, let's assume we have the following layout which adds a device with a single stick.
            
             <example>
             <code>
             InputSystem.RegisterLayout(@"
                 {
                     ""name"" : ""DeviceWithStick"",
                     ""controls"" : [
                         { ""name"" : ""stick"", ""layout"" : ""Stick"" }
                     ]
                 }
             ");
             </code>
             </example>
            
             If we load this layout, the <c>"stick"</c> control will be visible on the layout but the
             X and Y (as well as up/down/left/right) controls added by the <c>"Stick"</c> layout will
             not be.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.LoadLayout``1">
             <summary>
             Load the layout registered for the given type.
             </summary>
             <typeparam name="TControl">An InputControl type.</typeparam>
             <returns>The layout registered for <typeparamref name="TControl"/> or <c>null</c> if no
             such layout exists.</returns>
             <remarks>
             This method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/> with the name
             of the layout under which <typeparamref name="TControl"/> has been registered.
            
             <example>
             <code>
             // Load the InputControlLayout generated from StickControl.
             var stickLayout = InputSystem.LoadLayout&lt;StickControl&gt;();
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetNameOfBaseLayout(System.String)">
             <summary>
             Return the name of the layout that the layout registered as <paramref name="layoutName"/>
             is based on.
             </summary>
             <param name="layoutName">Name of a layout as registered with a method such as <see
             cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>. Case-insensitive.</param>
             <returns>Name of the immediate parent layout of <paramref name="layoutName"/> or <c>null</c> if no layout
             with the given name is registered or if it is not based on another layout or if it is a layout override.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="layoutName"/> is <c>null</c> or empty.</exception>
             <remarks>
             This method does not work for layout overrides (which can be based on multiple base layouts). To find
             out which layouts a specific override registered with <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutOverride(System.String,System.String)"/> is based on,
             load the layout with <see cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/> and inspect <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.baseLayouts"/>.
             This method will return <c>null</c> when <paramref name="layoutName"/> is the name of a layout override.
            
             One advantage of this method over calling <see cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/> and looking at <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.baseLayouts"/>
             is that this method does not have to actually load the layout but instead only performs a simple lookup.
            
             <example>
             <code>
             // Prints "Pointer".
             Debug.Log(InputSystem.GetNameOfBaseLayout("Mouse"));
            
             // Also works for control layouts. Prints "Axis".
             Debug.Log(InputSystem.GetNameOfBaseLayout("Button"));
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.baseLayouts"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.IsFirstLayoutBasedOnSecond(System.String,System.String)">
            <summary>
            Check whether the first layout is based on the second.
            </summary>
            <param name="firstLayoutName">Name of a registered <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.</param>
            <param name="secondLayoutName">Name of a registered <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.</param>
            <returns>True if <paramref name="firstLayoutName"/> is based on <paramref name="secondLayoutName"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="firstLayoutName"/> is <c>null</c> or empty -or-
            <paramref name="secondLayoutName"/> is <c>null</c> or empty.</exception>
            <remarks>
            This is
            <example>
            </example>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor(System.Type,System.String)">
             <summary>
             Register an <see cref="T:UnityEngine.InputSystem.InputProcessor`1"/> with the system.
             </summary>
             <param name="type">Type that implements <see cref="T:UnityEngine.InputSystem.InputProcessor"/>.</param>
             <param name="name">Name to use for the processor. If <c>null</c> or empty, name will be taken from the short name
             of <paramref name="type"/> (if it ends in "Processor", that suffix will be clipped from the name). Names
             are case-insensitive.</param>
             <remarks>
             Processors are used by both bindings (see <see cref="T:UnityEngine.InputSystem.InputBinding"/>) and by controls
             (see <see cref="T:UnityEngine.InputSystem.InputControl"/>) to post-process input values as they are being requested
             from calls such as <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/> or <see
             cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>.
            
             <example>
             <code>
             // Let's say that we want to define a processor that adds some random jitter to its input.
             // We have to pick a value type to operate on if we want to derive from InputProcessor&lt;T&gt;
             // so we go with float here.
             //
             // Also, as we will need to place our call to RegisterProcessor somewhere, we add attributes
             // to hook into Unity's initialization. This works differently in the editor and in the player,
             // so we use both [InitializeOnLoad] and [RuntimeInitializeOnLoadMethod].
             #if UNITY_EDITOR
             [InitializeOnLoad]
             #endif
             public class JitterProcessor : InputProcessor&lt;float&gt;
             {
                 // Add a parameter that defines the amount of jitter we apply.
                 // This will be editable in the Unity editor UI and can be set
                 // programmatically in code. For example:
                 //
                 //    myAction.AddBinding("&lt;Gamepad&gt;/rightTrigger",
                 //        processors: "jitter(amount=0.1)");
                 //
                 [Tooltip("Amount of jitter to apply. Will add a random value in the range [-amount..amount] "
                          + "to each input value.)]
                 public float amount;
            
                 // Process is called when an input value is read from a control. This is
                 // where we perform our jitter.
                 public override float Process(float value, InputControl control)
                 {
                     return float + Random.Range(-amount, amount);
                 }
            
                 // [InitializeOnLoad] will call the static class constructor which
                 // we use to call Register.
                 #if UNITY_EDITOR
                 static JitterProcessor()
                 {
                     Register();
                 }
                 #endif
            
                 // [RuntimeInitializeOnLoadMethod] will make sure that Register gets called
                 // in the player on startup.
                 // NOTE: This will also get called when going into play mode in the editor. In that
                 //       case we get two calls to Register instead of one. We don't bother with that
                 //       here. Calling RegisterProcessor twice here doesn't do any harm.
                 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
                 static void Register()
                 {
                     // We don't supply a name here. The input system will take "JitterProcessor"
                     // and automatically snip off the "Processor" suffix thus leaving us with
                     // a name of "Jitter" (all this is case-insensitive).
                     InputSystem.RegisterProcessor&lt;JitterProcessor&gt;();
                 }
             }
            
             // It doesn't really make sense in our case as the default parameter editor is just
             // fine (it will pick up the tooltip we defined above) but let's say we want to replace
             // the default float edit field we get on the "amount" parameter with a slider. We can
             // do so by defining a custom parameter editor.
             //
             // NOTE: We don't need to have a registration call here. The input system will automatically
             //       find our parameter editor based on the JitterProcessor type parameter we give to
             //       InputParameterEditor&lt;T&gt;.
             #if UNITY_EDITOR
             public class JitterProcessorEditor : InputParameterEditor&lt;JitterProcessor&gt;
             {
                 public override void OnGUI()
                 {
                     target.amount = EditorGUILayout.Slider(m_AmountLabel, target.amount, 0, 0.25f);
                 }
            
                 private GUIContent m_AmountLabel = new GUIContent("Amount",
                     "Amount of jitter to apply. Will add a random value in the range [-amount..amount] "
                         + "to each input value.);
             }
             #endif
             </code>
             </example>
            
             Note that it is allowed to register the same processor type multiple types with
             different names. When doing so, the first registration is considered as the "proper"
             name for the processor and all subsequent registrations will be considered aliases.
            
             See the <a href="../manual/Processors.html">manual</a> for more details.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputProcessor`1"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.processors"/>
             <seealso cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)">
             <summary>
             Register an <see cref="T:UnityEngine.InputSystem.InputProcessor`1"/> with the system.
             </summary>
             <typeparam name="T">Type that implements <see cref="T:UnityEngine.InputSystem.InputProcessor"/>.</typeparam>
             <param name="name">Name to use for the processor. If <c>null</c> or empty, name will be taken from the short name
             of <typeparamref name="T"/> (if it ends in "Processor", that suffix will be clipped from the name). Names
             are case-insensitive.</param>
             <remarks>
             Processors are used by both bindings (see <see cref="T:UnityEngine.InputSystem.InputBinding"/>) and by controls
             (see <see cref="T:UnityEngine.InputSystem.InputControl"/>) to post-process input values as they are being requested
             from calls such as <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/> or <see
             cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>.
            
             <example>
             <code>
             // Let's say that we want to define a processor that adds some random jitter to its input.
             // We have to pick a value type to operate on if we want to derive from InputProcessor&lt;T&gt;
             // so we go with float here.
             //
             // Also, as we will need to place our call to RegisterProcessor somewhere, we add attributes
             // to hook into Unity's initialization. This works differently in the editor and in the player,
             // so we use both [InitializeOnLoad] and [RuntimeInitializeOnLoadMethod].
             #if UNITY_EDITOR
             [InitializeOnLoad]
             #endif
             public class JitterProcessor : InputProcessor&lt;float&gt;
             {
                 // Add a parameter that defines the amount of jitter we apply.
                 // This will be editable in the Unity editor UI and can be set
                 // programmatically in code. For example:
                 //
                 //    myAction.AddBinding("&lt;Gamepad&gt;/rightTrigger",
                 //        processors: "jitter(amount=0.1)");
                 //
                 [Tooltip("Amount of jitter to apply. Will add a random value in the range [-amount..amount] "
                          + "to each input value.)]
                 public float amount;
            
                 // Process is called when an input value is read from a control. This is
                 // where we perform our jitter.
                 public override float Process(float value, InputControl control)
                 {
                     return float + Random.Range(-amount, amount);
                 }
            
                 // [InitializeOnLoad] will call the static class constructor which
                 // we use to call Register.
                 #if UNITY_EDITOR
                 static JitterProcessor()
                 {
                     Register();
                 }
                 #endif
            
                 // [RuntimeInitializeOnLoadMethod] will make sure that Register gets called
                 // in the player on startup.
                 // NOTE: This will also get called when going into play mode in the editor. In that
                 //       case we get two calls to Register instead of one. We don't bother with that
                 //       here. Calling RegisterProcessor twice here doesn't do any harm.
                 [RuntimeInitializeOnLoadMethod]
                 static void Register()
                 {
                     // We don't supply a name here. The input system will take "JitterProcessor"
                     // and automatically snip off the "Processor" suffix thus leaving us with
                     // a name of "Jitter" (all this is case-insensitive).
                     InputSystem.RegisterProcessor&lt;JitterProcessor&gt;();
                 }
             }
            
             // It doesn't really make sense in our case as the default parameter editor is just
             // fine (it will pick up the tooltip we defined above) but let's say we want to replace
             // the default float edit field we get on the "amount" parameter with a slider. We can
             // do so by defining a custom parameter editor.
             //
             // NOTE: We don't need to have a registration call here. The input system will automatically
             //       find our parameter editor based on the JitterProcessor type parameter we give to
             //       InputParameterEditor&lt;T&gt;.
             #if UNITY_EDITOR
             public class JitterProcessorEditor : InputParameterEditor&lt;JitterProcessor&gt;
             {
                 public override void OnGUI()
                 {
                     target.amount = EditorGUILayout.Slider(m_AmountLabel, target.amount, 0, 0.25f);
                 }
            
                 private GUIContent m_AmountLabel = new GUIContent("Amount",
                     "Amount of jitter to apply. Will add a random value in the range [-amount..amount] "
                         + "to each input value.);
             }
             #endif
             </code>
             </example>
            
             Note that it is allowed to register the same processor type multiple types with
             different names. When doing so, the first registration is considered as the "proper"
             name for the processor and all subsequent registrations will be considered aliases.
            
             See the <a href="../manual/Processors.html">manual</a> for more details.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputProcessor`1"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.processors"/>
             <seealso cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TryGetProcessor(System.String)">
            <summary>
            Return the processor type registered under the given name. If no such processor
            has been registered, return <c>null</c>.
            </summary>
            <param name="name">Name of processor. Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <returns>The given processor type or <c>null</c> if not found.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListProcessors">
            <summary>
            List the names of all processors have been registered.
            </summary>
            <returns>List of registered processors.</returns>
            <remarks>
            Note that the result will include both "proper" names and aliases registered
            for processors. If, for example, a given type <c>JitterProcessor</c> has been registered
            under both "Jitter" and "Randomize", it will appear in the list with both those names.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetProcessor(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.devices">
             <summary>
             The list of currently connected devices.
             </summary>
             <value>Currently connected devices.</value>
             <remarks>
             Note that accessing this property does not allocate. It gives read-only access
             directly to the system's internal array of devices.
            
             The value returned by this property should not be held on to. When the device
             setup in the system changes, any value previously returned by this property
             may become invalid. Query the property directly whenever you need it.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices">
             <summary>
             Devices that have been disconnected but are retained by the input system in case
             they are plugged back in.
             </summary>
             <value>Devices that have been retained by the input system in case they are plugged
             back in.</value>
             <remarks>
             During gameplay it is undesirable to have the system allocate and release managed memory
             as devices are unplugged and plugged back in as it would ultimately lead to GC spikes
             during gameplay. To avoid that, input devices that have been reported by the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">
             runtime</see> and are removed through <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceRemoveEvent">events</see> are retained
             by the system and then reused if the device is plugged back in.
            
             Note that the devices moved to disconnected status will still see a <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Removed"/>
             notification and a <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Added"/> notification when plugged back in.
            
             To determine if a newly discovered device is one we have seen before, the system uses a
             simple approach of comparing <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription">device descriptions</see>.
             Note that there can be errors and a device may be incorrectly classified as <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Reconnected"/>
             when in fact it is a different device from before. The problem is that based on information
             made available by platforms, it can be inherently difficult to determine whether a device is
             indeed the very same one.
            
             For example, it is often not possible to determine with 100% certainty whether an identical looking device
             to one we've previously seen on a different USB port is indeed the very same device. OSs will usually
             reattach a USB device to its previous instance if it is plugged into the same USB port but create a
             new instance of the same device is plugged into a different port.
            
             For devices that do relay their <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.serial">serials</see> the matching
             is reliable.
            
             The list can be purged by calling <see cref="M:UnityEngine.InputSystem.InputSystem.FlushDisconnectedDevices"/>. Doing so, will release
             all reference we hold to the devices or any controls inside of them and allow the devices to be
             reclaimed by the garbage collector.
            
             Note that if you call <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/> explicitly, the given device is not retained
             by the input system and will not appear on this list.
            
             Also note that devices on this list will be lost when domain reloads happen in the editor (i.e. on
             script recompilation and when entering play mode).
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FlushDisconnectedDevices"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onDeviceChange">
             <summary>
             Event that is signalled when the device setup in the system changes.
             </summary>
             <value>Callback when device setup ni system changes.</value>
             <remarks>
             This can be used to detect when devices are added or removed as well as
             detecting when existing devices change their configuration.
            
             <example>
             <code>
             InputSystem.onDeviceChange +=
                 (device, change) =>
                 {
                     switch (change)
                     {
                         case InputDeviceChange.Added:
                             Debug.Log("Device added: " + device);
                             break;
                         case InputDeviceChange.Removed:
                             Debug.Log("Device removed: " + device);
                             break;
                         case InputDeviceChange.ConfigurationChanged:
                             Debug.Log("Device configuration changed: " + device);
                             break;
                     }
                 };
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException">Delegate reference is <c>null</c>.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onDeviceCommand">
             <summary>
             Event that is signalled when an <see cref="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand"/> is sent to
             an <see cref="T:UnityEngine.InputSystem.InputDevice"/>.
             </summary>
             <value>Event that gets signalled on <see cref="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand"/>s.</value>
             <remarks>
             This can be used to intercept commands and optionally handle them without them reaching
             the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime"/>.
            
             The first delegate in the list that returns a result other than <c>null</c> is considered
             to have handled the command. If a command is handled by a delegate in the list, it will
             not be sent on to the runtime.
             </remarks>
             <exception cref="T:System.ArgumentNullException">Delegate reference is <c>null</c>.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)"/>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.DeviceCommand(System.Int32,UnityEngine.InputSystem.LowLevel.InputDeviceCommand*)"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice">
             <summary>
             Event that is signalled when the system is trying to match a layout to
             a device it has discovered.
             </summary>
             <remarks>
             This event allows customizing the layout discovery process and to generate
             layouts on the fly, if need be. When a device is reported from the Unity
             runtime or through <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>, it is
             reported in the form of an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/>. The system
             will take that description and run it through all the <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>s
             that have been registered for layouts (<see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher``1(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>).
             Based on that, it will come up with either no matching layout or with a single
             layout that has the highest matching score according to <see
             cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.MatchPercentage(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/> (or, in case multiple layouts have
             the same score, the first one to achieve that score -- which is quasi-non-deterministic).
            
             It will then take this layout name (which, again, may be empty) and invoke this
             event here passing it not only the layout name but also information such as the
             <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> for the device. Each of the callbacks hooked
             into the event will be run in turn. The <em>first</em> one to return a string
             that is not <c>null</c> and not empty will cause a switch from the layout the
             system has chosen to the layout that has been returned by the callback. The remaining
             layouts after that will then be invoked with that newly selected name but will not
             be able to change the name anymore.
            
             If none of the callbacks returns a string that is not <c>null</c> or empty,
             the system will stick with the layout that it had initially selected.
            
             Once all callbacks have been run, the system will either have a final layout
             name or not. If it does, a device is created using that layout. If it does not,
             no device is created.
            
             One thing this allows is to generate callbacks on the fly. Let's say that if
             an input device is reported with the "Custom" interface, we want to generate
             a layout for it on the fly. For details about how to build layouts dynamically
             from code, see <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder"/> and <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>.
            
             <example>
             <code>
             InputSystem.onFindLayoutForDevice +=
                 (deviceId, description, matchedLayout, runtime) =>
                 {
                     // If the system does have a matching layout, we do nothing.
                     // This could be the case, for example, if we already generated
                     // a layout for the device or if someone explicitly registered
                     // a layout.
                     if (!string.IsNullOrEmpty(matchedLayout))
                         return null; // Tell system we did nothing.
            
                     // See if the reported device uses the "Custom" interface. We
                     // are only interested in those.
                     if (description.interfaceName != "Custom")
                         return null; // Tell system we did nothing.
            
                     // So now we know that we want to build a layout on the fly
                     // for this device. What we do is to register what's called a
                     // layout builder. These can use C# code to build an InputControlLayout
                     // on the fly.
            
                     // First we need to come up with a sufficiently unique name for the layout
                     // under which we register the builder. This will usually involve some
                     // information from the InputDeviceDescription we have been supplied with.
                     // Let's say we can sufficiently tell devices on our interface apart by
                     // product name alone. So we just do this:
                     var layoutName = "Custom" + description.product;
            
                     // We also need an InputDeviceMatcher that in the future will automatically
                     // select our newly registered layout whenever a new device of the same type
                     // is connected. We can get one simply like so:
                     var matcher = InputDeviceMatcher.FromDescription(description);
            
                     // With these pieces in place, we can register our builder which
                     // mainly consists of a delegate that will get invoked when an instance
                     // of InputControlLayout is needed for the layout.
                     InputSystem.RegisterLayoutBuilder(
                         () =>
                         {
                             // Here is where we do the actual building. In practice,
                             // this would probably look at the 'capabilities' property
                             // of the InputDeviceDescription we got and create a tailor-made
                             // layout. But what you put in the layout here really depends on
                             // the specific use case you have.
                             //
                             // We just add some preset things here which should still sufficiently
                             // serve as a demonstration.
                             //
                             // Note that we can base our layout here on whatever other layout
                             // in the system. We could extend Gamepad, for example. If we don't
                             // choose a base layout, the system automatically implies InputDevice.
            
                             var builder = new InputControlLayout.Builder()
                                 .WithDisplayName(description.product);
            
                             // Add controls.
                             builder.AddControl("stick")
                                 .WithLayout("Stick");
            
                             return builder.Build();
                         },
                         layoutName,
                         matches: matcher);
            
                     // So, we want the system to use our layout for the device that has just
                     // been connected. We return it from this callback to do that.
                     return layoutName;
                 };
             </code>
             </example>
            
             Note that it may appear like one could simply use <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
             like below instead of going through <c>onFindLayoutForDevice</c>.
            
             <example>
             <code>
             InputSystem.RegisterLayoutBuilder(
                 () =>
                 {
                     // Layout building code from above...
                 },
                 "CustomLayout",
                 matches: new InputDeviceMatcher().WithInterface("Custom"));
             </code>
             </example>
            
             However, the difference here is that all devices using the "Custom" interface will
             end up with the same single layout -- which has to be identical. By hooking into
             <c>onFindLayoutForDevice</c>, it is possible to register a new layout for every new
             type of device that is discovered and thus build a multitude of different layouts.
            
             It is best to register for this callback during startup. One way to do it is to
             use <c>InitializeOnLoadAttribute</c> and <c>RuntimeInitializeOnLoadMethod</c>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.pollingFrequency">
             <summary>
             Frequency at which devices that need polling are being queried in the background.
             </summary>
             <value>Polled device sampling frequency in Hertz.</value>
             <remarks>
             Input data is gathered from platform APIs either as events or polled periodically.
            
             In the former case, where we get input as events, the platform is responsible for monitoring
             input devices and sending their state changes which the Unity runtime receives
             and queues as <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s. This form of input collection usually happens on a
             system-specific thread (which may be Unity's main thread) as part of how the Unity player
             loop operates. In most cases, this means that this form of input will invariably get picked up
             once per frame.
            
             In the latter case, where input has to be explicitly polled from the system, the Unity runtime
             will periodically sample the state of input devices and send it off as input events. Wherever
             possible, this happens in the background at a fixed frequency on a dedicated thread. The
             <c>pollingFrequency</c> property controls the rate at which this sampling happens.
            
             The unit is Hertz. A value of 120, for example, means that devices are sampled 120 times
             per second.
            
             The default polling frequency is 60 Hz.
            
             For devices that are polled, the frequency setting will directly translate to changes in the
             <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> patterns. At 60 Hz, for example, timestamps for a specific,
             polled device will be spaced at roughly 1/60th of a second apart.
            
             Note that it depends on the platform which devices are polled (if any). On Win32, for example,
             only XInput gamepads are polled.
            
             Also note that the polling frequency applies to all devices that are polled. It is not possible
             to set polling frequency on a per-device basis.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDevice(System.String,System.String,System.String)">
             <summary>
             Add a new device by instantiating the given device layout.
             </summary>
             <param name="layout">Name of the layout to instantiate. Must be a device layout. Note that
             layout names are case-insensitive.</param>
             <param name="name">Name to assign to the device. If null, the layout's display name (<see
             cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.displayName"/> is used instead. Note that device names are made
             unique automatically by the system by appending numbers to them (e.g. "gamepad", "gamepad1",
             "gamepad2", etc.).</param>
             <param name="variants">Semicolon-separated list of layout variants to use for the device.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="layout"/> is <c>null</c> or empty.</exception>
             <returns>The newly created input device.</returns>
             <remarks>
             The device will be added to the <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/> list and a notification on
             <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> will be triggered.
            
             Note that adding a device to the system will allocate and also create garbage on the GC heap.
            
             <example>
             <code>
             // This is one way to instantiate the "Gamepad" layout.
             InputSystem.AddDevice("Gamepad");
            
             // In this case, because the "Gamepad" layout is based on the Gamepad
             // class, we can also do this instead:
             InputSystem.AddDevice&lt;Gamepad&gt;();
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.Added"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout(System.Type,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)">
             <summary>
             Add a new device by instantiating the layout registered for type <typeparamref name="TDevice"/>.
             </summary>
             <param name="name">Name to assign to the device. If null, the layout's display name (<see
             cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.displayName"/> is used instead. Note that device names are made
             unique automatically by the system by appending numbers to them (e.g. "gamepad", "gamepad1",
             "gamepad2", etc.).</param>
             <typeparam name="TDevice">Type of device to add.</typeparam>
             <returns>The newly added device.</returns>
             <exception cref="T:System.InvalidOperationException">Instantiating the layout for <typeparamref name="TDevice"/>
             did not produce a device of type <typeparamref name="TDevice"/>.</exception>
             <remarks>
             The device will be added to the <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/> list and a notification on
             <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> will be triggered.
            
             Note that adding a device to the system will allocate and also create garbage on the GC heap.
            
             <example>
             <code>
             // Add a gamepad.
             InputSystem.AddDevice&lt;Gamepad&gt;();
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.Added"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
             <summary>
             Tell the input system that a new device has become available.
             </summary>
             <param name="description">Description of the input device.</param>
             <returns>The newly created device that has been added to <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.</returns>
             <exception cref="T:System.ArgumentException">The given <paramref name="description"/> is empty -or-
             no layout can be found that matches the given device <paramref name="description"/>.</exception>
             <remarks>
             This method is different from methods such as <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(System.String,System.String,System.String)"/>
             or <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/> in that it employs the usual matching process the
             same way that it happens when the Unity runtime reports an input device.
            
             In particular, the same procedure described in the documentation for <see cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>
             is employed where all registered <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>s are matched against the
             supplied device description and the most suitable match determines the layout to use. This in
             turn is run through <see cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/> to determine the final layout to use.
            
             If no suitable layout can be found, the method throws <c>ArgumentException</c>.
             <example>
             <code>
             InputSystem.AddDevice(
                 new InputDeviceDescription
                 {
                     interfaceName = "Custom",
                     product = "Product"
                 });
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Add the given device back to the system.
             </summary>
             <param name="device">An input device. If the device is currently already added to
             the system (i.e. is in <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>), the method will do nothing.</param>
             <exception cref="T:System.ArgumentNullException"></exception>
             <remarks>
             This can be used when a device has been manually removed with <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>.
            
             The device will be added to the <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/> list and a notification on
             <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> will be triggered.
            
             It may be tempting to do the following but this will not work:
            
             <example>
             <code>
             // This will *NOT* work.
             var device = new Gamepad();
             InputSystem.AddDevice(device);
             </code>
             </example>
            
             <see cref="T:UnityEngine.InputSystem.InputDevice"/>s, like <see cref="T:UnityEngine.InputSystem.InputControl"/>s in general, cannot
             simply be instantiated with <c>new</c> but must be created by the input system
             instead.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Remove a device from the system such that it no longer receives input and is no longer part of the
             set of devices in <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.
             </summary>
             <param name="device">Device to remove. If the device has already been removed (i.e. if <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>
             is false), the method does nothing.</param>
             <remarks>
             Actions that are bound to controls on the device will automatically unbind when the device
             is removed.
            
             When a device is removed, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Removed"/>.
             The device will be removed from <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/> as well as from any device-specific getters such as
             <see cref="P:UnityEngine.InputSystem.Gamepad.all"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.added"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.FlushDisconnectedDevices">
            <summary>
            Purge all disconnected devices from <see cref="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices"/>.
            </summary>
            <remarks>
            This will release all references held on to for these devices or any of their controls and will
            allow the devices to be reclaimed by the garbage collector.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.String)">
            <summary>
            Return the device with given name or layout <param name="nameOrLayout"/>.
            Returns null if no such device currently exists.
            </summary>
            <param name="nameOrLayout">Unique device name or layout to search for.</param>
            <returns>The device matching the given search criteria or null.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.Type)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice``1"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDevice``1">
            <summary>
            Return the most recently used device that is assignable to the given type <typeparamref name="TDevice"/>.
            Returns null if no such device currently exists.
            </summary>
            <typeparam name="TDevice">Type of device to look for.</typeparam>
            <returns>The device that is assignable to the given type or null.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.Type)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.Type)">
            <summary>
            Return the most recently used device that is assignable to the given type <param name="type"/>.
            Returns null if no such device currently exists.
            </summary>
            <param name="type">Type of the device</param>
            <returns>The device that is assignable to the given type or null.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDevice``1(UnityEngine.InputSystem.Utilities.InternedString)">
             <summary>
             Return the device of the given type <typeparamref name="TDevice"/> that has the
             given usage assigned. Returns null if no such device currently exists.
             </summary>
             <param name="usage">Usage of the device, e.g. "LeftHand".</param>
             <typeparam name="TDevice">Type of device to look for.</typeparam>
             <returns>The device with the given type and usage or null.</returns>
             <remarks>
             Devices usages are most commonly employed to "tag" devices for a specific role.
             A common scenario, for example, is to distinguish which hand a specific <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
             is associated with. However, arbitrary usages can be assigned to devices.
             <example>
             <code>
             // Get the left hand XRController.
             var leftHand = InputSystem.GetDevice&lt;XRController&gt;(CommonUsages.leftHand);
            
             // Mark gamepad #2 as being for player 1.
             InputSystem.SetDeviceUsage(Gamepad.all[1], "Player1");
             // And later look it up.
             var player1Gamepad = InputSystem.GetDevice&lt;Gamepad&gt;(new InternedString("Player1"));
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDevice``1(System.String)">
            <summary>
            Return the device of the given type <typeparamref name="TDevice"/> that has the
            given usage assigned. Returns null if no such device currently exists.
            </summary>
            <param name="usage">Usage of the device, e.g. "LeftHand".</param>
            <typeparam name="TDevice">Type of device to look for.</typeparam>
            <returns>The device with the given type and usage or null.</returns>
            <remarks>
            Devices usages are most commonly employed to "tag" devices for a specific role.
            A common scenario, for example, is to distinguish which hand a specific <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
            is associated with. However, arbitrary usages can be assigned to devices.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.GetDevice``1(UnityEngine.InputSystem.Utilities.InternedString)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetDeviceById(System.Int32)">
            <summary>
            Look up a device by its unique ID.
            </summary>
            <param name="deviceId">Unique ID of device. Such as given by <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>.</param>
            <returns>The device for the given ID or null if no device with the given ID exists (or no longer exists).</returns>
            <remarks>
            Device IDs are not reused in a given session of the application (or Unity editor).
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>
            <seealso cref="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.AllocateDeviceId"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetUnsupportedDevices">
            <summary>
            Return the list of devices that have been reported by the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">runtime</see>
            but could not be matched to any known <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout">layout</see>.
            </summary>
            <returns>A list of descriptions of devices that could not be recognized.</returns>
            <remarks>
            If new layouts are added to the system or if additional <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher">matches</see>
            are added to existing layouts, devices in this list may appear or disappear.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.GetUnsupportedDevices(System.Collections.Generic.List{UnityEngine.InputSystem.Layouts.InputDeviceDescription})">
            <summary>
            Populate a list of devices that have been reported by the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">runtime</see>
            but could not be matched to any known <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout">layout</see>.
            </summary>
            <param name="descriptions">A list to be populated with descriptions of devices that could not be recognized.</param>
            <returns>The number of devices that could not be recognized.</returns>
            <remarks>
            If new layouts are added to the system or if additional <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher">matches</see>
            are added to existing layouts, devices in this list may appear or disappear.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             (Re-)enable the given device.
             </summary>
             <param name="device">Device to enable. If already enabled, the method will do nothing.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <remarks>
             This can be used after a device has been disabled with <see cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/> or
             with devices that start out in disabled state (usually the case for all <see cref="T:UnityEngine.InputSystem.Sensor"/>
             devices).
            
             When enabled, a device will receive input when available.
            
             <example>
             <code>
             // Enable the gyroscope, if present.
             if (Gyroscope.current != null)
                 InputSystem.EnableDevice(Gyroscope.current);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)">
             <summary>
             Disable the given device, i.e. "mute" it.
             </summary>
             <param name="device">Device to disable. If already disabled, the method will do nothing.</param>
             <param name="keepSendingEvents">If true, no <see cref="T:UnityEngine.InputSystem.LowLevel.DisableDeviceCommand"/> will be sent
             for the device. This means that the backend sending input events will not be notified about the device
             being disabled and will thus keep sending events. This can be useful when input is being rerouted from
             one device to another. For example, <see cref="T:UnityEngine.InputSystem.EnhancedTouch.TouchSimulation"/> uses this to disable the <see cref="T:UnityEngine.InputSystem.Mouse"/>
             while redirecting its events to input on a <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.<br/><br/>This parameter is false by default.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <remarks>
             A disabled device will not receive input and will remain in its default state. It will remain
             present in the system but without actually feeding input into it.
            
             Disabling devices is most useful for <see cref="T:UnityEngine.InputSystem.Sensor"/> devices on battery-powered platforms
             where having a sensor enabled will increase energy consumption. Sensors will usually start
             out in disabled state and can be enabled, when needed, with <see cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/> and
             disabled again wth this method.
            
             However, disabling a device can be useful in other situations, too. For example, when simulating
             input (say, mouse input) locally from a remote source, it can be desirable to turn off the respective
             local device.
            
             To remove a device altogether, use <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/> instead. This will not only silence
             input but remove the <see cref="T:UnityEngine.InputSystem.InputDevice"/> instance from the system altogether.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TrySyncDevice(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Issue a <see cref="T:UnityEngine.InputSystem.LowLevel.RequestSyncCommand"/> on <paramref name="device"/>. This requests the device to
            send its current state as an event. If successful, the device will be updated in the next <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
            </summary>
            <param name="device">An <see cref="T:UnityEngine.InputSystem.InputDevice"/> that is currently part of <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.</param>
            <returns>True if the request succeeded, false if it fails.</returns>
            <remarks>
            It depends on the backend/platform implementation whether explicit synchronization is supported. If it is, the method
            will return true. If it is not, the method will return false and the request is ignored.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="device"/> has not been <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>.</exception>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.RequestSyncCommand"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)">
             <summary>
             Reset the state of the given device.
             </summary>
             <param name="device">Device to reset. Must be <see cref="P:UnityEngine.InputSystem.InputDevice.added"/> to the system.</param>
             <param name="alsoResetDontResetControls">If true, also reset controls that are marked as <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset"/>.
             Leads to <see cref="F:UnityEngine.InputSystem.InputDeviceChange.HardReset"/>.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <exception cref="T:System.InvalidOperationException"><paramref name="device"/> has not been <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>.</exception>
             <remarks>
             There are two different kinds of resets performed by the input system: a "soft" reset and a "hard" reset.
            
             A "hard" reset resets all controls on the device to their default state and also sends a <see cref="T:UnityEngine.InputSystem.LowLevel.RequestResetCommand"/>
             to the backend, instructing to also reset its own internal state (if any) to the default.
            
             A "soft" reset will reset only controls that are not marked as <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy"/> and not marked as
             <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset"/>. It will also not set a <see cref="T:UnityEngine.InputSystem.LowLevel.RequestResetCommand"/> to the backend,
             i.e. the reset will be internal to the input system only (and thus can be partial in nature).
            
             By default, the method will perform a "soft" reset if <paramref name="device"/> has <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy"/>
             or <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset"/> controls. If it does not, it will perform a "hard" reset.
            
             A "hard" reset can be forced by setting <paramref name="alsoResetDontResetControls"/> to true.
            
             <example>
             <code>
             // "Soft" reset the mouse. This will leave controls such as the mouse position intact
             // but will reset button press states.
             InputSystem.ResetDevice(Mouse.current);
            
             // "Hard" reset the mouse. This will wipe everything and reset the mouse to its default
             // state.
             InputSystem.ResetDevice(Mouse.current, alsoResetDontResetControls: true);
             </code>
             </example>
            
             Resetting a device will trigger a <see cref="F:UnityEngine.InputSystem.InputDeviceChange.SoftReset"/> or <see cref="F:UnityEngine.InputSystem.InputDeviceChange.HardReset"/>
             (based on the value of <paramref name="alsoResetDontResetControls"/>) notification on <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>.
             Also, all <see cref="T:UnityEngine.InputSystem.InputAction"/>s currently in progress from controls on <paramref name="device"/> will be cancelled
             (see <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>) in a way that guarantees for them to not get triggered. That is, a reset is
             semantically different from simply sending an event with default state. Using the latter, a button may be considered as
             going from pressed to released whereas with a device reset, the change back to unpressed state will not be considered
             a button release (and thus not trigger interactions that are waiting for a button release).
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.TrySyncDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.HardReset"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.SoftReset"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.DeviceResetEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.PauseHaptics">
            <summary>
            Pause haptic effect playback on all devices.
            </summary>
            <remarks>
            Calls <see cref="M:UnityEngine.InputSystem.Haptics.IHaptics.PauseHaptics"/> on all <see cref="T:UnityEngine.InputSystem.InputDevice">input devices</see>
            that implement the interface.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResumeHaptics"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetHaptics"/>
            <example>
            <code>
            // When going into the menu from gameplay, pause haptics.
            gameplayControls.backAction.onPerformed +=
                ctx =>
                {
                    gameplayControls.Disable();
                    menuControls.Enable();
                    InputSystem.PauseHaptics();
                };
            </code>
            </example>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ResumeHaptics">
            <summary>
            Resume haptic effect playback on all devices.
            </summary>
            <remarks>
            Calls <see cref="M:UnityEngine.InputSystem.Haptics.IHaptics.ResumeHaptics"/> on all <see cref="T:UnityEngine.InputSystem.InputDevice">input devices</see>
            that implement the interface.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.PauseHaptics"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ResetHaptics">
             <summary>
             Stop haptic effect playback on all devices.
             </summary>
             <remarks>
             Will reset haptics effects on all devices to their default state.
            
             Calls <see cref="M:UnityEngine.InputSystem.Haptics.IHaptics.ResetHaptics"/> on all <see cref="T:UnityEngine.InputSystem.InputDevice">input devices</see>
             that implement the interface.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)">
             <summary>
             Set the usage tag of the given device to <paramref name="usage"/>.
             </summary>
             <param name="device">Device to set the usage on.</param>
             <param name="usage">New usage for the device.</param>
             <remarks>
             Usages allow to "tag" a specific device such that the tag can then be used in lookups
             and bindings. A common use is for identifying the handedness of an <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
             but the usages can be arbitrary strings.
            
             This method either sets the usages of the device to a single string (meaning it will
             clear whatever, if any usages, the device has when the method is called) or,
             if <paramref name="usage"/> is null or empty, resets the usages of the device
             to be empty. To add to a device's set of usages, call <see cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>.
             To remove usages from a device, call <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             <example>
             <code>
             // Tag a gamepad to be associated with player #1.
             InputSystem.SetDeviceUsage(myGamepad, "Player1");
            
             // Create an action that binds to player #1's gamepad specifically.
             var action = new InputAction(binding: "&lt;Gamepad&gt;{Player1}/buttonSouth");
            
             // Move the tag from one gamepad to another.
             InputSystem.SetDeviceUsage(myGamepad, null); // Clears usages on 'myGamepad'.
             InputSystem.SetDeviceUsage(otherGamepad, "Player1");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)">
             <summary>
             Set the usage tag of the given device to <paramref name="usage"/>.
             </summary>
             <param name="device">Device to set the usage on.</param>
             <param name="usage">New usage for the device.</param>
             <remarks>
             Usages allow to "tag" a specific device such that the tag can then be used in lookups
             and bindings. A common use is for identifying the handedness of an <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
             but the usages can be arbitrary strings.
            
             This method either sets the usages of the device to a single string (meaning it will
             clear whatever, if any usages, the device has when the method is called) or,
             if <paramref name="usage"/> is null or empty, resets the usages of the device
             to be empty. To add to a device's set of usages, call <see cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>.
             To remove usages from a device, call <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             If the set of usages on the device changes as a result of calling this method, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>.
            
             <example>
             <code>
             // Tag a gamepad to be associated with player #1.
             InputSystem.SetDeviceUsage(myGamepad, new InternedString("Player1"));
            
             // Create an action that binds to player #1's gamepad specifically.
             var action = new InputAction(binding: "&lt;Gamepad&gt;{Player1}/buttonSouth");
            
             // Move the tag from one gamepad to another.
             InputSystem.SetDeviceUsage(myGamepad, null); // Clears usages on 'myGamepad'.
             InputSystem.SetDeviceUsage(otherGamepad, new InternedString("Player1"));
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)">
             <summary>
             Add a usage tag to the given device.
             </summary>
             <param name="device">Device to add the usage to.</param>
             <param name="usage">New usage to add to the device.</param>
             <remarks>
             Usages allow to "tag" a specific device such that the tag can then be used in lookups
             and bindings. A common use is for identifying the handedness of an <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
             but the usages can be arbitrary strings.
            
             This method adds a new usage to the device's set of usages. If the device already has
             the given usage, the method does nothing. To instead set the device's usages to a single
             one, use <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>. To remove usages from a device,
             call <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             If the set of usages on the device changes as a result of calling this method, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="usage"/> is null or empty.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)">
             <summary>
             Add a usage tag to the given device.
             </summary>
             <param name="device">Device to add the usage to.</param>
             <param name="usage">New usage to add to the device.</param>
             <remarks>
             Usages allow to "tag" a specific device such that the tag can then be used in lookups
             and bindings. A common use is for identifying the handedness of an <see cref="T:UnityEngine.InputSystem.XR.XRController"/>
             but the usages can be arbitrary strings.
            
             This method adds a new usage to the device's set of usages. If the device already has
             the given usage, the method does nothing. To instead set the device's usages to a single
             one, use <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>. To remove usages from a device,
             call <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             If the set of usages on the device changes as a result of calling this method, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="usage"/> is empty.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)">
             <summary>
             Remove a usage tag from the given device.
             </summary>
             <param name="device">Device to remove the usage from.</param>
             <param name="usage">Usage to remove from the device.</param>
             <remarks>
             This method removes an existing usage from the given device. If the device does not
             have the given usage tag, the method does nothing. Use <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             or <see cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/> to add usages to a device.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             If the set of usages on the device changes as a result of calling this method, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="usage"/> is null or empty.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)">
             <summary>
             Remove a usage tag from the given device.
             </summary>
             <param name="device">Device to remove the usage from.</param>
             <param name="usage">Usage to remove from the device.</param>
             <remarks>
             This method removes an existing usage from the given device. If the device does not
             have the given usage tag, the method does nothing. Use <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             or <see cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/> to add usages to a device.
            
             The set of usages a device has can be queried with <see cref="P:UnityEngine.InputSystem.InputControl.usages"/> (a device
             is an <see cref="T:UnityEngine.InputSystem.InputControl"/> and thus, like controls, has an associated set of usages).
            
             If the set of usages on the device changes as a result of calling this method, <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             will be triggered with <see cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="usage"/> is empty.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Utilities.InternedString)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
             <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.FindControl(System.String)">
             <summary>
             Find the first control that matches the given control path.
             </summary>
             <param name="path">Path of a control, e.g. <c>"&lt;Gamepad&gt;/buttonSouth"</c>. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/>
             for details.</param>
             <returns>The first control that matches the given path or <c>null</c> if no control matches.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c> or empty.</exception>
             <remarks>
             If multiple controls match the given path, which result is considered the first is indeterminate.
            
             <example>
             <code>
             // Add gamepad.
             InputSystem.AddDevice&lt;Gamepad&gt;();
            
             // Look up various controls on it.
             var aButton = InputSystem.FindControl("&lt;Gamepad&gt;/buttonSouth");
             var leftStickX = InputSystem.FindControl("*/leftStick/x");
             var bButton = InputSystem.FindControl"*/{back}");
            
             // This one returns the gamepad itself as devices are also controls.
             var gamepad = InputSystem.FindControl("&lt;Gamepad&gt;");
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.path"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.FindControls(System.String)">
             <summary>
             Find all controls that match the given <see cref="T:UnityEngine.InputSystem.InputControlPath">control path</see>.
             </summary>
             <param name="path">Control path to search for</param>
             <returns>List of <see cref="T:UnityEngine.InputSystem.InputControl"/> which matched the given search criteria</returns>
             <example>
             <code>
             // Find all gamepads (literally: that use the "Gamepad" layout).
             InputSystem.FindControls("&lt;Gamepad&gt;");
            
             // Find all sticks on all gamepads.
             InputSystem.FindControls("&lt;Gamepad&gt;/*stick");
            
             // Same but filter stick by type rather than by name.
             InputSystem.FindControls&lt;StickControl&gt;("&lt;Gamepad&gt;/*");
             </code>
             </example>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String,UnityEngine.InputSystem.InputControlList{``0}@)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String)">
            <summary>
            Find all controls that match the given <see cref="T:UnityEngine.InputSystem.InputControlPath">control path</see>.
            </summary>
            <param name="path">Control path to search for</param>
            <typeparam name="TControl">Type of control <see cref="T:UnityEngine.InputSystem.InputControl"/>.</typeparam>
            <returns>Generic list of <see cref="T:UnityEngine.InputSystem.InputControl"/> which matched the given search criteria</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String,UnityEngine.InputSystem.InputControlList{``0}@)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String,UnityEngine.InputSystem.InputControlList{``0}@)">
            <summary>
            Populate a list with all controls that match the given <see cref="T:UnityEngine.InputSystem.InputControlPath">control path</see>.
            </summary>
            <param name="path">Control path to search for</param>
            <param name="controls">Generic list of <see cref="T:UnityEngine.InputSystem.InputControl"/> to populate with the search results</param>
            <typeparam name="TControl">Type of control <see cref="T:UnityEngine.InputSystem.InputControl"/>.</typeparam>
            <returns>Count of controls which matched the given search criteria</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls``1(System.String,UnityEngine.InputSystem.InputControlList{``0}@)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.onEvent">
             <summary>
             Called during <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> for each event that is processed.
             </summary>
             <remarks>
             Every time the input system updates (see <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>
             or <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> for details about when and how this happens),
             it flushes all events from the internal event buffer.
            
             As the Input System reads events from the buffer one by one, it will trigger this
             callback for each event which originates from a recognized device, before then proceeding
             to process the event. If any of the callbacks sets <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.handled"/>
             to true, the event will be skipped and ignored.
            
             Note that a device that is disabled (see <see cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>) may still get
             this event signalled for it. A <see cref="T:UnityEngine.InputSystem.LowLevel.DisableDeviceCommand"/> will usually be sent to
             backends when a device is disabled but a backend may or may not respond to the command and
             thus may or may not keep sending events for the device.
            
             Note that the Input System does NOT sort events by timestamps (<see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>).
             Instead, they are consumed in the order they are produced. This means that they
             will also surface on this callback in that order.
            
             <example>
             <code>
             // Treat left+right mouse button as middle mouse button.
             // (Note: This example is more for demonstrative purposes; it isn't necessarily a good use case)
             InputSystem.onEvent +=
                (eventPtr, device) =>
                {
                    // Only deal with state events.
                    if (!eventPtr.IsA&lt;StateEvent&gt;())
                        return;
            
                    if (!(device is Mouse mouse))
                        return;
            
                    mouse.leftButton.ReadValueFromEvent(eventPtr, out var lmbDown);
                    mouse.rightButton.ReadValueFromEvent(eventPtr, out var rmbDown);
            
                    if (lmbDown > 0 &amp;&amp; rmbDown > 0)
                        mouse.middleButton.WriteValueIntoEvent(1f, eventPtr);
                };
             </code>
             </example>
            
             The property returns an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventListener"/> struct that, beyond adding and removing
             callbacks, can be used to flexibly listen in on the event stream.
            
             <example>
             <code>
             // Listen for mouse events.
             InputSystem.onEvent
                 .ForDevice(Mouse.current)
                 .Call(e => Debug.Log("Mouse event"));
             </code>
             </example>
            
             If you are looking for a way to capture events, <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventTrace"/> may be of
             interest and an alternative to directly hooking into this event.
            
             If you are looking to monitor changes to specific input controls, state change monitors
             (see <see cref="M:UnityEngine.InputSystem.LowLevel.InputState.AddChangeMonitor(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor,System.Int64,System.UInt32)"/>
             are usually a more efficient and convenient way to set this up.
             </remarks>
             <exception cref="T:System.ArgumentNullException">Delegate reference is <c>null</c>.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.onAnyButtonPress">
             <summary>
             Listen through <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/> for a button to be pressed.
             </summary>
             <remarks>
             The listener will get triggered whenever a <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/> on any device in the list of <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
             goes from not being pressed to being pressed.
            
             <example>
             <code>
             // Response to the first button press. Calls our delegate
             // and then immediately stops listening.
             InputSystem.onAnyButtonPress
                 .CallOnce(ctrl => Debug.Log($"Button {ctrl} was pressed"));
             </code>
             </example>
            
             Note that the listener will get triggered from the first button that was found in a pressed state in a
             given <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>. If multiple buttons are pressed in an event, the listener will not
             get triggered multiple times. To get all button presses in an event, use <see cref="M:UnityEngine.InputSystem.InputControlExtensions.GetAllButtonPresses(UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single,System.Boolean)"/>
             and instead listen directly through <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>.
            
             <example>
             <code>
             InputSystem.onEvent
                 .Where(e => e.HasButtonPress())
                 .CallOnce(eventPtr =>
                 {
                     foreach (var button in l.eventPtr.GetAllButtonPresses())
                         Debug.Log($"Button {button} was pressed");
                 });
             </code>
             </example>
            
             There is a certain overhead to listening for button presses so it is best to have listeners
             installed only while the information is actually needed.
            
             <example>
             <code>
             // Script that will spawn a new player when a button on a device is pressed.
             public class JoinPlayerOnPress : MonoBehaviour
             {
                 // We instantiate this GameObject to create a new player object.
                 // Expected to have a PlayerInput component in its hierarchy.
                 public GameObject playerPrefab;
            
                 // We want to remove the event listener we install through InputSystem.onAnyButtonPress
                 // after we're done so remember it here.
                 private IDisposable m_EventListener;
            
                 // When enabled, we install our button press listener.
                 void OnEnable()
                 {
                     // Start listening.
                     m_EventListener =
                         InputSystem.onAnyButtonPress
                             .Call(OnButtonPressed)
                 }
            
                 // When disabled, we remove our button press listener.
                 void OnDisable()
                 {
                     m_EventListener.Dispose();
                 }
            
                 void OnButtonPressed(InputControl button)
                 {
                     var device = button.device;
            
                     // Ignore presses on devices that are already used by a player.
                     if (PlayerInput.FindFirstPairedToDevice(device) != null)
                         return;
            
                     // Create a new player.
                     var player = PlayerInput.Instantiate(playerPrefab, pairWithDevice: device);
            
                     // If the player did not end up with a valid input setup,
                     // unjoin the player.
                     if (player.hasMissingRequiredDevices)
                         Destroy(player);
            
                     // If we only want to join a single player, could uninstall our listener here
                     // or use CallOnce() instead of Call() when we set it up.
                 }
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Add an event to the internal event queue.
             </summary>
             <param name="eventPtr">Event to add to the internal event buffer.</param>
             <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not
             valid (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid"/>).</exception>
             <exception cref="T:System.InvalidOperationException">The method was called from
             within event processing more than 1000 times. To avoid deadlocking, this
             results in an exception being thrown.</exception>
             <remarks>
             The event will be copied in full to the internal event buffer meaning that
             you can release memory for the event after it has been queued. The internal event
             buffer is flushed on the next input system update (see <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>).
             Note that if input is process in <c>FixedUpdate()</c> (see <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>),
             then the event may not get processed until its <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> timestamp
             is within the update window of the input system.
            
             As part of queuing, the event will receive its own unique ID (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId"/>).
             Note that this ID will be written into the memory buffer referenced by <paramref cref="!:eventPtr"/>
             meaning that after calling <c>QueueEvent</c>, you will see the event ID with which the event
             was queued.
            
             Events that are queued during event processing will get processed in the same update.
             This happens, for example, when queuing input from within <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/> or from
             action callbacks such as <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>.
            
             The total size of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s processed in a single update is limited by
             <see cref="P:UnityEngine.InputSystem.InputSettings.maxEventBytesPerUpdate"/>. This also prevents deadlocks when
             each processing of an event leads to one or more additional events getting queued.
            
             <example>
             <code>
             // Queue an input event on the first gamepad.
             var gamepad = Gamepad.all[0];
             using (StateEvent.From(gamepad, out var eventPtr))
             {
                 gamepad.leftStick.WriteValueIntoEvent(new Vector2(0.123f, 0.234f), eventPtr);
                 InputSystem.QueueEvent(eventPtr);
             }
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueEvent``1(``0@)">
             <summary>
             Add an event to the internal event queue.
             </summary>
             <typeparam name="TEvent">Type of event to look enqueue.</typeparam>
             <param name="inputEvent">Event to add to the internal event buffer.</param>
             <remarks>
             The event will be copied in full to the internal event buffer. The internal event
             buffer is flushed on the next input system update (see <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>).
             Note that if input is process in <c>FixedUpdate()</c> (see <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>),
             then the event may not get processed until its <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> timestamp
             is within the update window of the input system.
            
             As part of queuing, the event will receive its own unique ID (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId"/>).
             Note that this ID will be written into <paramref name="inputEvent"/>
             meaning that after calling this method, you will see the event ID with which the event
             was queued.
            
             <example>
             <code>
             // Queue a disconnect event on the first gamepad.
             var inputEvent = DeviceRemoveEvent(Gamepad.all[0].deviceId);
             InputSystem.QueueEvent(inputEvent);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueStateEvent``1(UnityEngine.InputSystem.InputDevice,``0,System.Double)">
             <summary>
             Queue a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> to update the input state of the given device.
             </summary>
             <param name="device">Device whose input state to update</param>
             <param name="state"></param>
             <param name="time">Timestamp for the event. If not supplied, the current time is used. Note
             that if the given time is in the future and events processed in
             <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">FixedUpdate</a> (see <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>),
             the event will only get processed once the actual time has caught up with the given time.</param>
             <typeparam name="TState">Type of input state, such as <see cref="T:UnityEngine.InputSystem.LowLevel.MouseState"/>. Must match the expected
             type of state of <paramref name="device"/>.</typeparam>
             <remarks>
             The given state must match exactly what is expected by the given device. If unsure, an alternative
             is to grab the state as an event directly from the device using <see
             cref="M:UnityEngine.InputSystem.LowLevel.StateEvent.From(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.LowLevel.InputEventPtr@,Unity.Collections.Allocator)"/> which can then
             be queued using <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>.
            
             <example>
             <code>
             // Allocates temporary, unmanaged memory for the event.
             // using statement automatically disposes the memory once we have queued the event.
             using (StateEvent.From(Mouse.current, out var eventPtr))
             {
                 // Use controls on mouse to write values into event.
                 Mouse.current.position.WriteValueIntoEvent(new Vector(123, 234), eventPtr);
            
                 // Queue event.
                 InputSystem.QueueEvent(eventPtr);
             }
             </code>
             </example>
            
             The event will only be queued and not processed right away. This means that the state of
             <paramref name="device"/> will not change immediately as a result of calling this method. Instead,
             the event will be processed as part of the next input update.
            
             Note that this method updates the complete input state of the device including all of its
             controls. To update just part of the state of a device, you can use <see cref="M:UnityEngine.InputSystem.InputSystem.QueueDeltaStateEvent``1(UnityEngine.InputSystem.InputControl,``0,System.Double)"/>
             (however, note that there are some restrictions; see documentation).
             <example>
             <code>
             InputSystem.QueueStateEvent(Mouse.current, new MouseState { position = new Vector(123, 234) });
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.InvalidOperationException"><paramref name="device"/> has not been added to the system
             (<see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.InputDevice)"/>) and thus cannot receive events.</exception>
             <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueDeltaStateEvent``1(UnityEngine.InputSystem.InputControl,``0,System.Double)">
            <summary>
            Queue a <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> to update part of the input state of the given device.
            </summary>
            <param name="control">Control on a device to update state of.</param>
            <param name="delta">New state for the control. Type of state must match the state of the control.</param>
            <param name="time"></param>
            <typeparam name="TDelta"></typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueConfigChangeEvent(UnityEngine.InputSystem.InputDevice,System.Double)">
             <summary>
             Queue a <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/> that signals that the configuration of the given device has changed
             and that cached configuration will thus have to be refreshed.
             </summary>
             <param name="device">Device whose configuration has changed.</param>
             <param name="time">Timestamp for the event. If not supplied, the current time will be used.</param>
             <remarks>
             All state of an input device that is not input or output state is considered its "configuration".
            
             A simple example is keyboard layouts. A <see cref="T:UnityEngine.InputSystem.Keyboard"/> will typically have an associated
             keyboard layout that dictates the function of each key and which can be changed by the user at the
             system level. In the input system, the current keyboard layout can be queried via <see cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>.
             When the layout changes at the system level, the input backend sends a configuration change event
             to signal that the configuration of the keyboard has changed and that cached data may be outdated.
             In response, <see cref="T:UnityEngine.InputSystem.Keyboard"/> will flush out cached information such as the name of the keyboard
             layout and display names (<see cref="P:UnityEngine.InputSystem.InputControl.displayName"/>) of individual keys which causes them
             to be fetched again from the backend the next time they are accessed.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.InvalidOperationException"><paramref name="device"/> has not been added
             (<see cref="P:UnityEngine.InputSystem.InputDevice.added"/>; <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.InputDevice)"/>) and thus cannot
             receive events.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.QueueTextEvent(UnityEngine.InputSystem.InputDevice,System.Char,System.Double)">
             <summary>
             Queue a <see cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/> on the given device.
             </summary>
             <param name="device">Device to queue the event on.</param>
             <param name="character">Text character to input through the event.</param>
             <param name="time">Optional event time stamp. If not supplied, the current time will be used.</param>
             <remarks>
             Text input is sent to devices character by character. This allows sending strings of arbitrary
             length without necessary incurring GC overhead.
            
             For the event to have any effect on <paramref name="device"/>, the device must
             implement <see cref="T:UnityEngine.InputSystem.LowLevel.ITextInputReceiver"/>. It will see <see cref="M:UnityEngine.InputSystem.LowLevel.ITextInputReceiver.OnTextInput(System.Char)"/>
             being called when the event is processed.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
             <exception cref="T:System.InvalidOperationException"><paramref name="device"/> is a device that has not been
             added to the system.</exception>
             <seealso cref="E:UnityEngine.InputSystem.Keyboard.onTextInput"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.Update">
             <summary>
             Run a single update of input state.
             </summary>
             <remarks>
             Except in tests and when using <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsManually"/>, this method should not
             normally be called. The input system will automatically update as part of the player loop as
             determined by <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>. Calling this method is equivalent to
             inserting extra frames, i.e. it will advance the entire state of the input system by one complete
             frame.
            
             When using <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Manual"/>, this method MUST be called for input to update in the
             player. Not calling the method as part of the player loop may result in excessive memory
             consumption and/or potential loss of input.
            
             Each update will flush out buffered input events and cause them to be processed. This in turn
             will update the state of input devices (<see cref="T:UnityEngine.InputSystem.InputDevice"/>) and trigger actions (<see cref="T:UnityEngine.InputSystem.InputAction"/>)
             that monitor affected device state.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputUpdateType"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate">
             <summary>
             Event that is fired before the input system updates.
             </summary>
             <remarks>
             The input system updates in sync with player loop and editor updates. Input updates
             are run right before the respective script update. For example, an input update for
             <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Dynamic"/> is run before <c>MonoBehaviour.Update</c> methods
             are executed.
            
             The update callback itself is triggered before the input system runs its own update and
             before it flushes out its event queue. This means that events queued from a callback will
             be fed right into the upcoming update.
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onAfterUpdate"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onAfterUpdate">
            <summary>
            Event that is fired after the input system has completed an update and processed all pending events.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onBeforeUpdate"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.settings">
            <summary>
            The current configuration of the input system.
            </summary>
            <value>Global configuration object for the input system.</value>
            <remarks>
            The input system can be configured on a per-project basis. Settings can either be created and
            installed on the fly or persisted as assets in the project.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Value is null when setting the property.</exception>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onSettingsChange">
            <summary>
            Event that is triggered if any of the properties in <see cref="P:UnityEngine.InputSystem.InputSystem.settings"/> changes or if
            <see cref="P:UnityEngine.InputSystem.InputSystem.settings"/> is replaced entirely with a new <see cref="T:UnityEngine.InputSystem.InputSettings"/> object.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.settings"/>
            <seealso cref="T:UnityEngine.InputSystem.InputSettings"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputSystem.onActionChange">
             <summary>
             Event that is signalled when the state of enabled actions in the system changes or
             when actions are triggered.
             </summary>
             <remarks>
             The object received by the callback is either an <see cref="T:UnityEngine.InputSystem.InputAction"/>,
             <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, or <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> depending on whether the
             <see cref="T:UnityEngine.InputSystem.InputActionChange"/> affects a single action, an entire action map, or an
             entire action asset.
            
             For <see cref="F:UnityEngine.InputSystem.InputActionChange.BoundControlsAboutToChange"/> and <see cref="F:UnityEngine.InputSystem.InputActionChange.BoundControlsChanged"/>,
             the given object is an <see cref="T:UnityEngine.InputSystem.InputAction"/> if the action is not part of an action map,
             an <see cref="T:UnityEngine.InputSystem.InputActionMap"/> if the actions are part of a map but not part of an asset, and an
             <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> if the actions are part of an asset. In other words, the notification is
             sent for the topmost object in the hierarchy.
             </remarks>
             <example>
             <code>
             InputSystem.onActionChange +=
                 (obj, change) =>
                 {
                     if (change == InputActionChange.ActionPerformed)
                     {
                         var action = (InputAction)obj;
                         var control = action.activeControl;
                         //...
                     }
                     else if (change == InputActionChange.ActionMapEnabled)
                     {
                         var actionMap = (InputActionMap)obj;
                         //...
                     }
                     else if (change == InputActionChange.BoundControlsChanged)
                     {
                         // This is one way to deal with the fact that obj may be an InputAction
                         // InputActionMap, or InputActionAsset and may be part of an InputActionAsset or not.
                         var action = obj as InputAction;
                         var actionMap = action?.actionMap ?? obj as InputActionMap;
                         var actionAsset = actionMap?.asset ?? obj as InputActionAsset;
            
                         // Note that if bound controls are changed on any map in an asset, there *will*
                         // be a BoundControlsChanged notification for the entire asset.
            
                         //...
                     }
                 };
             </code>
             </example>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.controls"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)">
             <summary>
             Register a new type of interaction with the system.
             </summary>
             <param name="type">Type that implements the interaction. Must support <see cref="T:UnityEngine.InputSystem.InputInteraction"/>.</param>
             <param name="name">Name to register the interaction with. This is used in bindings to refer to the interaction
             (e.g. an interactions called "Tap" can be added to a binding by listing it in its <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
             property). If no name is supplied, the short name of <paramref name="type"/> is used (with "Interaction" clipped off
             the name if the type name ends in that).</param>
             <example>
             <code>
             // Interaction that is performed when control resets to default state.
             public class ResetInteraction : InputInteraction
             {
                 public void Process(ref InputInteractionContext context)
                 {
                     if (context.isWaiting &amp;&amp; !context.controlHasDefaultValue)
                         context.Started();
                     else if (context.isStarted &amp;&amp; context.controlHasDefaultValue)
                         context.Performed();
                 }
             }
            
             // Make interaction globally available on bindings.
             // "Interaction" suffix in type name will get dropped automatically.
             InputSystem.RegisterInteraction(typeof(ResetInteraction));
            
             // Set up action with binding that has the 'reset' interaction applied to it.
             var action = new InputAction(binding: "/&lt;Gamepad>/buttonSouth", interactions: "reset");
             </code>
             </example>
             <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetInteraction(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListInteractions"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction``1(System.String)">
            <summary>
            Register a new type of interaction with the system.
            </summary>
            <typeparam name="T">Type that implements the interaction. Must support <see cref="T:UnityEngine.InputSystem.InputInteraction"/>.</typeparam>
            <param name="name">Name to register the interaction with. This is used in bindings to refer to the interaction
            (e.g. an interactions called "Tap" can be added to a binding by listing it in its <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
            property). If no name is supplied, the short name of <typeparamref name="T"/> is used (with "Interaction" clipped off
            the name if the type name ends in that).</param>
            <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetInteraction(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListInteractions"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TryGetInteraction(System.String)">
            <summary>
            Search for a registered interaction type with the given name.
            </summary>
            <param name="name">Name of the registered interaction to search for.</param>
            <returns>The type of the interaction, if one was previously registered with the give name, otherwise null.</returns>
            <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListInteractions"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListInteractions">
            <summary>
            Gets the names of of all currently registered interactions.
            </summary>
            <returns>A list of currently registered interaction names.</returns>
            <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetInteraction(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)">
            <summary>
            Register a new type of binding composite with the system.
            </summary>
            <param name="type">Type that implements the binding composite. Must support <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>.</param>
            <param name="name">Name to register the binding composite with. This is used in bindings to refer to the composite.</param>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetBindingComposite(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)">
            <summary>
            Register a new type of binding composite with the system.
            </summary>
            <typeparam name="T">Type that implements the binding composite. Must support <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>.</typeparam>
            <param name="name">Name to register the binding composite with. This is used in bindings to refer to the composite.</param>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.TryGetBindingComposite(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TryGetBindingComposite(System.String)">
            <summary>
            Search for a registered binding composite type with the given name.
            </summary>
            <param name="name">Name of the registered binding composite to search for.</param>
            <returns>The type of the binding composite, if one was previously registered with the give name, otherwise null.</returns>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.DisableAllEnabledActions">
            <summary>
            Disable all actions (and implicitly all action sets) that are currently enabled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListEnabledActions"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListEnabledActions">
            <summary>
            Return a list of all the actions that are currently enabled in the system.
            </summary>
            <returns>A new list instance containing all currently enabled actions.</returns>
            <remarks>
            To avoid allocations, use <see cref="M:UnityEngine.InputSystem.InputSystem.ListEnabledActions(System.Collections.Generic.List{UnityEngine.InputSystem.InputAction})"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.ListEnabledActions(System.Collections.Generic.List{UnityEngine.InputSystem.InputAction})">
            <summary>
            Add all actions that are currently enabled in the system to the given list.
            </summary>
            <param name="actions">List to add actions to.</param>
            <returns>The number of actions added to the list.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actions"/> is null.</exception>
            <remarks>
            If the capacity of the given list is large enough, this method will not allocate memory.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.remoting">
            <summary>
            The local InputRemoting instance which can mirror local input to a remote
            input system or can make input in a remote system available locally.
            </summary>
            <remarks>
            In the editor, this is always initialized. In players, this will be null
            if remoting is disabled (which it is by default in release players).
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.version">
            <summary>
            The current version of the input system package.
            </summary>
            <value>Current version of the input system.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSystem.metrics">
            <summary>
            Get various up-to-date metrics about the input system.
            </summary>
            <value>Up-to-date metrics on input system activity.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.TrackDirtyInputActionAsset(UnityEngine.InputSystem.InputActionAsset)">
             <summary>
             Keep track of InputActionAsset assets that you want to re-load on exiting Play mode. This is useful because
             some user actions, such as adding a new input binding at runtime, change the in-memory representation of the
             input action asset and those changes survive when exiting Play mode. If you re-open an Input
             Action Asset in the Editor that has been changed this way, you see the new bindings that have been added
             during Play mode which you might not typically want to happen.
            
             You can avoid this by force re-loading from disk any asset that has been marked as dirty.
             </summary>
             <param name="asset"></param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.Reset(System.Boolean,UnityEngine.InputSystem.LowLevel.IInputRuntime)">
            <summary>
            Return the input system to its default state.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.Destroy">
            <summary>
            Destroy the current setup of the input system.
            </summary>
            <remarks>
            NOTE: This also de-allocates data we're keeping in unmanaged memory!
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSystem.State">
            <summary>
            Snapshot of the state used by the input system.
            </summary>
            <remarks>
            Can be taken across domain reloads.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.SaveAndReset(System.Boolean,UnityEngine.InputSystem.LowLevel.IInputRuntime)">
            <summary>
            Push the current state of the input system onto a stack and
            reset the system to its default state.
            </summary>
            <remarks>
            The save stack is not able to survive domain reloads. It is intended solely
            for use in tests.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSystem.Restore">
            <summary>
            Restore the state of the system from the last state pushed with <see cref="M:UnityEngine.InputSystem.InputSystem.SaveAndReset(System.Boolean,UnityEngine.InputSystem.LowLevel.IInputRuntime)"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerJoinBehavior">
            <summary>
            Determines how <see cref="T:UnityEngine.InputSystem.PlayerInputManager"/> joins new players.
            </summary>
            <remarks>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.PlayerInputManager"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInputManager.joinBehavior"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerJoinBehavior.JoinPlayersWhenButtonIsPressed">
            <summary>
            Listen for button presses on devices that are not paired to any player. If they occur
            and joining is allowed, join a new player using the device the button was pressed on.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerJoinBehavior.JoinPlayersManually">
            <summary>
            Do not join players automatically. Call <see cref="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayerFromUI"/> or <see cref="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayerFromAction(UnityEngine.InputSystem.InputAction.CallbackContext)"/>
            explicitly in order to join new players. Alternatively, just create GameObjects with <see cref="T:UnityEngine.InputSystem.PlayerInput"/>
            components directly and they will be joined automatically.
            </summary>
            <remarks>
            This behavior also allows implementing more sophisticated device pairing mechanisms when multiple devices
            are involved. While initial engagement required by <see cref="F:UnityEngine.InputSystem.PlayerJoinBehavior.JoinPlayersWhenButtonIsPressed"/> or
            <see cref="F:UnityEngine.InputSystem.PlayerJoinBehavior.JoinPlayersWhenJoinActionIsTriggered"/> allows pairing a single device reliably to a player,
            additional devices that may be required by a control scheme will still get paired automatically out of the
            pool of available devices. This means that, for example, if a given player joins by clicking a mouse button
            ...
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControl">
             <summary>
             A typed and named source of input values in a hierarchy of controls.
             </summary>
             <remarks>
             Controls can have children which in turn may have children. At the root of the child
             hierarchy is always an <see cref="T:UnityEngine.InputSystem.InputDevice"/> (which themselves are InputControls).
            
             Controls can be looked up by their <see cref="P:UnityEngine.InputSystem.InputControl.path"/> (see <see cref="M:UnityEngine.InputSystem.InputControlPath.TryFindControl(UnityEngine.InputSystem.InputControl,System.String,System.Int32)"/>).
            
             Each control must have a unique <see cref="P:UnityEngine.InputSystem.InputControl.name"/> within the <see cref="P:UnityEngine.InputSystem.InputControl.children"/> of
             its <see cref="P:UnityEngine.InputSystem.InputControl.parent"/>. Multiple names can be assigned to controls using aliases (see
             <see cref="P:UnityEngine.InputSystem.InputControl.aliases"/>). Name lookup is case-insensitive.
            
             For display purposes, a control may have a separate <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/>. This name
             will usually correspond to what the control is caused on the actual underlying hardware.
             For example, on an Xbox gamepad, the control with the name "buttonSouth" will have a display
             name of "A". Controls that have very long display names may also have a <see cref="P:UnityEngine.InputSystem.InputControl.shortDisplayName"/>.
             This is the case for the "Left Button" on the <see cref="T:UnityEngine.InputSystem.Mouse"/>, for example, which is
             commonly abbreviated "LMB".
            
             In addition to names, a control may have usages associated with it (see <see cref="P:UnityEngine.InputSystem.InputControl.usages"/>).
             A usage indicates how a control is meant to be used. For example, a button can be assigned
             the "PrimaryAction" usage to indicate it is the primary action button the device. Within a
             device, usages have to be unique. See <see cref="T:UnityEngine.InputSystem.CommonUsages"/> for a list of standardized usages.
            
             Controls do not actually store values. Instead, every control receives an <see cref="T:UnityEngine.InputSystem.LowLevel.InputStateBlock"/>
             which, after the control's device has been added to the system, is used to read out values
             from the device's backing store. This backing store is referred to as "state" in the API
             as opposed to "values" which represent the data resulting from reading state. The format that
             each control stores state in is specific to the control. It can vary not only between controls
             of different types but also between controls of the same type. An <see cref="T:UnityEngine.InputSystem.Controls.AxisControl"/>,
             for example, can be stored as a float or as a byte or in a number of other formats. <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
             identifies both where the control stores its state as well as the format it stores it in.
            
             Controls are generally not created directly but are created internally by the input system
             from data known as "layouts" (see <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>). Each such layout describes
             the setup of a specific hierarchy of controls. The system internally maintains a registry of
             layouts and produces devices and controls from them as needed. The layout that a control has
             been created from can be queried using <see cref="P:UnityEngine.InputSystem.InputControl.layout"/>. For most purposes, the intricacies
             of the control layout mechanisms can be ignored and it is sufficient to know the names of a
             small set of common device layouts such as "Keyboard", "Mouse", "Gamepad", and "Touchscreen".
            
             Each control has a single, fixed value type. The type can be queried at runtime using
             <see cref="P:UnityEngine.InputSystem.InputControl.valueType"/>. Most types of controls are derived from <see cref="T:UnityEngine.InputSystem.InputControl`1"/>
             which has APIs specific to the type of value of the control (e.g. <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>.
            
             The following example demonstrates various common operations performed on input controls:
            
             <example>
             <code>
             // Look up dpad/up control on current gamepad.
             var dpadUpControl = Gamepad.current["dpad/up"];
            
             // Look up the back button on the current gamepad.
             var backButton = Gamepad.current["{Back}"];
            
             // Look up all dpad/up controls on all gamepads in the system.
             using (var controls = InputSystem.FindControls("&lt;Gamepad&gt;/dpad/up"))
                 Debug.Log($"Found {controls.Count} controls");
            
             // Display the value of all controls on the current gamepad.
             foreach (var control in Gamepad.current.allControls)
                 Debug.Log(controls.ReadValueAsObject());
            
             // Track the value of the left stick on the current gamepad over time.
             var leftStickHistory = new InputStateHistory(Gamepad.current.leftStick);
             leftStickHistory.Enable();
             </code>
             </example>
             <example>
             </example>
             </remarks>
             <see cref="T:UnityEngine.InputSystem.InputControl`1"/>
             <seealso cref="T:UnityEngine.InputSystem.InputDevice"/>
             <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputStateBlock"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.name">
             <summary>
             The name of the control, i.e. the final name part in its path.
             </summary>
             <remarks>
             Names of controls must be unique within the context of their parent.
            
             Note that this is the name of the control as assigned internally (like "buttonSouth")
             and not necessarily a good display name. Use <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/> for
             getting more readable names for display purposes (where available).
            
             Lookup of names is case-insensitive.
            
             This is set from the name of the control in the layout.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.path"/>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.aliases"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.name"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.name"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.displayName">
             <summary>
             The text to display as the name of the control.
             </summary>
             <remarks>
             Note that the display name of a control may change over time. For example, when changing
             from a QWERTY keyboard layout to an AZERTY keyboard layout, the "q" key (which will keep
             that <see cref="P:UnityEngine.InputSystem.InputControl.name"/>) will change its display name from "q" to "a".
            
             By default, a control's display name will come from its layout. If it is not assigned
             a display name there, the display name will default to <see cref="P:UnityEngine.InputSystem.InputControl.name"/>. However, specific
             controls may override this behavior. <see cref="T:UnityEngine.InputSystem.Controls.KeyControl"/>, for example, will set the
             display name to the actual key name corresponding to the current keyboard layout.
            
             For nested controls, the display name will include the display names of all parent controls,
             i.e. the display name will fully identify the control on the device. For example, the display
             name for the left D-Pad button on a gamepad is "D-Pad Left" and not just "Left".
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.shortDisplayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.shortDisplayName">
             <summary>
             An alternate, abbreviated <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/> (for example "LMB" instead of "Left Button").
             </summary>
             <remarks>
             If the control has no abbreviated version, this will be null. Note that this behavior is different
             from <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/> which will fall back to <see cref="P:UnityEngine.InputSystem.InputControl.name"/> if no display name has
             been assigned to the control.
            
             For nested controls, the short display name will include the short display names of all parent controls,
             that is, the display name will fully identify the control on the device. For example, the display
             name for the left D-Pad button on a gamepad is "D-Pad \u2190" and not just "\u2190". Note that if a parent
             control has no short name, its long name will be used instead.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.displayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.path">
             <summary>
             Full path all the way from the root.
             </summary>
             <remarks>
             This will always be the "effective" path of the control, i.e. it will not contain
             elements such as usages (<c>"{Back}"</c>) and other elements that can be part of
             control paths used for matching. Instead, this property will always be a simple
             linear ordering of names leading from the device at the top to the control with each
             element being separated by a forward slash (<c>/</c>).
            
             Allocates on first hit. Paths are not created until someone asks for them.
            
             <example>
             Example: "/gamepad/leftStick/x"
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.layout">
            <summary>
            Layout the control is based on.
            </summary>
            <remarks>
            This is the layout name rather than a reference to an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> as
            we only create layout instances during device creation and treat them
            as temporaries in general so as to not waste heap space during normal operation.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.variants">
            <summary>
            Semicolon-separated list of variants of the control layout or "default".
            </summary>
            <example>
            "Lefty" when using the "Lefty" gamepad layout.
            </example>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.device">
            <summary>
            The device that this control is a part of.
            </summary>
            <remarks>
            This is the root of the control hierarchy. For the device at the root, this
            will point to itself.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.allControls"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.parent">
            <summary>
            The immediate parent of the control or null if the control has no parent
            (which, once fully constructed) will only be the case for InputDevices).
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.children"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.children">
            <summary>
            List of immediate children.
            </summary>
            <remarks>
            Does not allocate.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.parent"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.usages">
             <summary>
             List of usage tags associated with the control.
             </summary>
             <remarks>
             Usages apply "semantics" to a control. Whereas the name of a control identifies a particular
             "endpoint" within the control hierarchy, the usages of a control identify particular roles
             of specific control. A simple example is <see cref="F:UnityEngine.InputSystem.CommonUsages.Back"/> which identifies a
             control generally used to move backwards in the navigation history of a UI. On a keyboard,
             it is the escape key that generally fulfills this role whereas on a gamepad, it is generally
             the "B" / "Circle" button. Some devices may not have a control that generally fulfills this
             function and thus may not have any control with the "Back" usage.
            
             By looking up controls by usage rather than by name, it is possible to locate the correct
             control to use for certain standardized situation without having to know the particulars of
             the device or platform.
            
             <example>
             <code>
             // Bind to any control which is tagged with the "Back" usage on any device.
             var backAction = new InputAction(binding: "*/{Back}");
             </code>
             </example>
            
             Note that usages on devices work slightly differently than usages of controls on devices.
             They are also queried through this property but unlike the usages of controls, the set of
             usages of a device can be changed dynamically as the role of the device changes. For details,
             see <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>. Controls, on the other hand,
             can currently only be assigned usages through layouts (<see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usage"/>
             or <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usages"/>).
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usage"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usages"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RemoveDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
             <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.noisy">
             <summary>
             Whether the control is considered noisy.
             </summary>
             <value>True if the control produces noisy input.</value>
             <remarks>
             A control is considered "noisy" if it produces different values without necessarily requiring user
             interaction. A good example are sensors (see <see cref="T:UnityEngine.InputSystem.Sensor"/>). For example, the PS4 controller
             which has a gyroscope sensor built into the device. Whereas sticks and buttons on the device require
             user interaction to produce non-default values, the gyro will produce varying values even if the
             device just sits there without user interaction.
            
             The value of this property is determined by the layout (<see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>) that the
             control has been built from.
            
             Note that for devices (<see cref="T:UnityEngine.InputSystem.InputDevice"/>) this property is true if any control on the device
             is marked as noisy.
            
             The primary effect of being noise is on <see cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/> and
             on interactive rebinding (see <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation"/>).
             However, being noisy also affects automatic resetting of controls that happens when the application
             loses focus. While other controls are reset to their default value (except if <c>Application.runInBackground</c>
             is true and the device the control belongs to is marked as <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>),
             noisy controls will not be reset but rather remain at their current value. This is based on the assumption
             that noisy controls most often represent sensor values and snapping the last sampling value back to default
             will usually have undesirable effects on an application's simulation logic.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isNoisy"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.synthetic">
             <summary>
             Whether the control is considered synthetic.
             </summary>
             <value>True if the control does not represent an actual physical control on the device.</value>
             <remarks>
             A control is considered "synthetic" if it does not correspond to an actual, physical control on the
             device. An example for this is <see cref="P:UnityEngine.InputSystem.Keyboard.anyKey"/> or the up/down/left/right buttons added
             by <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/>.
            
             The value of this property is determined by the layout (<see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>) that the
             control has been built from.
            
             The primary effect of being synthetic is in interactive rebinding (see
             <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation"/>) where non-synthetic
             controls will be favored over synthetic ones. This means, for example, that if both
             <c>"&lt;Gamepad&gt;/leftStick/x"</c> and <c>"&lt;Gamepad&gt;/leftStick/left"</c> are
             suitable picks, <c>"&lt;Gamepad&gt;/leftStick/x"</c> will be favored as it represents
             input from an actual physical control whereas <c>"&lt;Gamepad&gt;/leftStick/left"</c>
             represents input from a made-up control. If, however, the "left" button is the only
             viable pick, it will be accepted.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isSynthetic"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.synthetic"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.Item(System.String)">
            <summary>
            Fetch a control from the control's hierarchy by name.
            </summary>
            <remarks>
            Note that path matching is case-insensitive.
            </remarks>
            <example>
            <code>
            gamepad["leftStick"] // Returns Gamepad.leftStick
            gamepad["leftStick/x"] // Returns Gamepad.leftStick.x
            gamepad["{PrimaryAction}"] // Returns the control with PrimaryAction usage, that is, Gamepad.aButton
            </code>
            </example>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="path"/> cannot be found.</exception>
            <seealso cref="T:UnityEngine.InputSystem.InputControlPath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.path"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.TryGetChildControl(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.valueType">
            <summary>
            Returns the underlying value type of this control.
            </summary>
            <value>Type of values produced by the control.</value>
            <remarks>
            This is the type of values that are returned when reading the current value of a control
            or when reading a value of a control from an event.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateAsObject(System.Void*)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes">
            <summary>
            Size in bytes of values that the control returns.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueType"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.magnitude">
            <summary>
            Compute an absolute, normalized magnitude value that indicates the extent to which the control
            is actuated. Shortcut for <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>.
            </summary>
            <returns>Amount of actuation of the control or -1 if it cannot be determined.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude(System.Void*)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.ToString">
            <summary>
            Return a string representation of the control useful for debugging.
            </summary>
            <returns>A string representation of the control.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude">
             <summary>
             Compute an absolute, normalized magnitude value that indicates the extent to which the control
             is actuated.
             </summary>
             <returns>Amount of actuation of the control or -1 if it cannot be determined.</returns>
             <remarks>
             Magnitudes do not make sense for all types of controls. For example, for a control that represents
             an enumeration of values (such as <see cref="T:UnityEngine.InputSystem.Controls.TouchPhaseControl"/>), there is no meaningful
             linear ordering of values (one could derive a linear ordering through the actual enum values but
             their assignment may be entirely arbitrary; it is unclear whether a state of <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>
             has a higher or lower "magnitude" as a state of <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>).
            
             Controls that have no meaningful magnitude will return -1 when calling this method. Any negative
             return value should be considered an invalid value.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude(System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude(System.Void*)">
            <summary>
            Compute an absolute, normalized magnitude value that indicates the extent to which the control
            is actuated in the given state.
            </summary>
            <param name="statePtr">State containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.</param>
            <returns>Amount of actuation of the control or -1 if it cannot be determined.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateAsObject(System.Void*)">
            <summary>
            Read the control's final, processed value from the given state and return the value as an object.
            </summary>
            <param name="statePtr"></param>
            <returns>The control's value as stored in <paramref name="statePtr"/>.</returns>
            <remarks>
            This method allocates GC memory and should not be used during normal gameplay operation.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="statePtr"/> is null.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)">
            <summary>
            Read the control's final, processed value from the given state and store it in the given buffer.
            </summary>
            <param name="statePtr">State to read the value for the control from.</param>
            <param name="bufferPtr">Buffer to store the value in.</param>
            <param name="bufferSize">Size of <paramref name="bufferPtr"/> in bytes. Must be at least <see cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>.
            If it is smaller, <see cref="T:System.ArgumentException"/> will be thrown.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="statePtr"/> is null, or <paramref name="bufferPtr"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="bufferSize"/> is smaller than <see cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateAsObject(System.Void*)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.WriteValueFromBufferIntoState(System.Void*,System.Int32,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.WriteValueFromBufferIntoState(System.Void*,System.Int32,System.Void*)">
            <summary>
            Read a value from the given memory and store it as state.
            </summary>
            <param name="bufferPtr">Memory containing value.</param>
            <param name="bufferSize">Size of <paramref name="bufferPtr"/> in bytes. Must be at least <see cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>.</param>
            <param name="statePtr">State containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>. Will receive the state
            as converted from the given value.</param>
            <remarks>
            Writing values will NOT apply processors to the given value. This can mean that when reading a value
            from a control after it has been written to its state, the resulting value differs from what was
            written.
            </remarks>
            <exception cref="T:System.NotSupportedException">The control does not support writing. This is the case, for
            example, that compute values (such as the magnitude of a vector).</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.WriteValueFromObjectIntoState(System.Object,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.WriteValueFromObjectIntoState(System.Object,System.Void*)">
            <summary>
            Read a value object and store it as state in the given memory.
            </summary>
            <param name="value">Value for the control.</param>
            <param name="statePtr">State containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>. Will receive
            the state state as converted from the given value.</param>
            <remarks>
            Writing values will NOT apply processors to the given value. This can mean that when reading a value
            from a control after it has been written to its state, the resulting value differs from what was
            written.
            </remarks>
            <exception cref="T:System.NotSupportedException">The control does not support writing. This is the case, for
            example, that compute values (such as the magnitude of a vector).</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.WriteValueFromBufferIntoState(System.Void*,System.Int32,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)">
             <summary>
             Compare the value of the control as read from <paramref name="firstStatePtr"/> to that read from
             <paramref name="secondStatePtr"/> and return true if they are equal.
             </summary>
             <param name="firstStatePtr">Memory containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.</param>
             <param name="secondStatePtr">Memory containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/></param>
             <returns>True if the value of the control is equal in both <paramref name="firstStatePtr"/> and
             <paramref name="secondStatePtr"/>.</returns>
             <remarks>
             Unlike <see cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>, this method will have to do more than just compare the memory
             for the control in the two state buffers. It will have to read out state for the control and run
             the full processing machinery for the control to turn the state into a final, processed value.
             CompareValue is thus more costly than <see cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>.
            
             This method will apply epsilons (<see cref="F:UnityEngine.Mathf.Epsilon"/>) when comparing floats.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.TryGetChildControl(System.String)">
             <summary>
             Try to find a child control matching the given path.
             </summary>
             <param name="path">A control path. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/>.</param>
             <returns>The first direct or indirect child control that matches the given <paramref name="path"/>
             or null if no control was found to match.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c> or empty.</exception>
             <remarks>
             Note that if the given path matches multiple child controls, only the first control
             encountered in the search will be returned.
            
             <example>
             <code>
             // Returns the leftStick control of the current gamepad.
             Gamepad.current.TryGetChildControl("leftStick");
            
             // Returns the X axis control of the leftStick on the current gamepad.
             Gamepad.current.TryGetChildControl("leftStick/x");
            
             // Returns the first control ending with "stick" in its name. Note that it
             // undetermined whether this is leftStick or rightStick (or even another stick
             // added by the given gamepad).
             Gamepad.current.TryGetChildControl("*stick");
             </code>
             </example>
            
             This method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputControlPath.TryFindChild(UnityEngine.InputSystem.InputControl,System.String,System.Int32)"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.FinishSetup">
             <summary>
             Perform final initialization tasks after the control hierarchy has been put into place.
             </summary>
             <remarks>
             This method can be overridden to perform control- or device-specific setup work. The most
             common use case is for looking up child controls and storing them in local getters.
            
             <example>
             <code>
             public class MyDevice : InputDevice
             {
                 public ButtonControl button { get; private set; }
                 public AxisControl axis { get; private set; }
            
                 protected override void OnFinishSetup()
                 {
                     // Cache controls in getters.
                     button = GetChildControl("button");
                     axis = GetChildControl("axis");
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.RefreshConfigurationIfNeeded">
             <summary>
             Call <see cref="M:UnityEngine.InputSystem.InputControl.RefreshConfiguration"/> if the configuration has in the interim been invalidated
             by a <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/>.
             </summary>
             <remarks>
             This method is only relevant if you are implementing your own devices or new
             types of controls which are fetching configuration data from the devices (such
             as <see cref="T:UnityEngine.InputSystem.Controls.KeyControl"/> which is fetching display names for individual keys
             from the underlying platform).
            
             This method should be called if you are accessing cached data set up by
             <see cref="M:UnityEngine.InputSystem.InputControl.RefreshConfiguration"/>.
            
             <example>
             <code>
             // Let's say your device has an associated orientation which it can be held with
             // and you want to surface both as a property and as a usage on the device.
             // Whenever your backend code detects a change in orientation, it should send
             // a DeviceConfigurationEvent to your device to signal that the configuration
             // of the device has changed. You can then implement RefreshConfiguration() to
             // read out and update the device orientation on the managed InputDevice instance.
             public class MyDevice : InputDevice
             {
                 public enum Orientation
                 {
                     Horizontal,
                     Vertical,
                 }
            
                 private Orientation m_Orientation;
                 public Orientation orientation
                 {
                     get
                     {
                         // Call RefreshOrientation if the configuration of the device has been
                         // invalidated since last time we initialized m_Orientation.
                         RefreshConfigurationIfNeeded();
                         return m_Orientation;
                     }
                 }
                 protected override void RefreshConfiguration()
                 {
                     // Fetch the current orientation from the backend. How you do this
                     // depends on your device. Using DeviceCommands is one way.
                     var fetchOrientationCommand = new FetchOrientationCommand();
                     ExecuteCommand(ref fetchOrientationCommand);
                     m_Orientation = fetchOrientation;
            
                     // Reflect the orientation on the device.
                     switch (m_Orientation)
                     {
                         case Orientation.Vertical:
                             InputSystem.RemoveDeviceUsage(this, s_Horizontal);
                             InputSystem.AddDeviceUsage(this, s_Vertical);
                             break;
            
                         case Orientation.Horizontal:
                             InputSystem.RemoveDeviceUsage(this, s_Vertical);
                             InputSystem.AddDeviceUsage(this, s_Horizontal);
                             break;
                     }
                 }
            
                 private static InternedString s_Vertical = new InternedString("Vertical");
                 private static InternedString s_Horizontal = new InternedString("Horizontal");
             }
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControl.RefreshConfiguration"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.noiseMaskPtr">
             <summary>
             Return the memory that holds the noise mask for the control.
             </summary>
             <value>Noise bit mask for the control.</value>
             <remarks>
             Like with all state blocks, the specific memory block for the control is found at the memory
             region specified by <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.
            
             The noise mask can be overlaid as a bit mask over the state for the control. When doing so, all state
             that is noise will be masked out whereas all state that isn't will come through unmodified. In other words,
             any bit that is set in the noise mask indicates that the corresponding bit in the control's state memory
             is noise.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.stateOffsetRelativeToDeviceRoot">
            <summary>
            The offset of this control's state relative to its device root.
            </summary>
            <remarks>
            Once a device has been added to the system, its state block will get allocated
            in the global state buffers and the offset of the device's state block will
            get baked into all of the controls on the device. This property always returns
            the "unbaked" offset.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl.optimizedControlDataType">
             <summary>
             For some types of control you can safely read/write state memory directly
             which is much faster than calling ReadUnprocessedValueFromState/WriteValueIntoState.
             This method returns a type that you can use for reading/writing the control directly,
             or it returns InputStateBlock.kFormatInvalid if it's not possible for this type of control.
             </summary>
             <remarks>
             For example, AxisControl might be a "float" in state memory, and if no processing is applied during reading (e.g. no invert/scale/etc),
             then you could read it as float in memory directly without calling ReadUnprocessedValueFromState, which is faster.
             Additionally, if you have a Vector3Control which uses 3 AxisControls as consecutive floats in memory,
             you can cast the Vector3Control state memory directly to Vector3 without calling ReadUnprocessedValueFromState on x/y/z axes.
            
             The value returned for any given control is computed automatically by the Input System, when the control's setup configuration changes. <see cref="M:UnityEngine.InputSystem.InputControl.CalculateOptimizedControlDataType"/>
             There are some parameter changes which don't trigger a configuration change (such as the clamp, invert, normalize, and scale parameters on AxisControl),
             so if you modify these, the optimized data type is not automatically updated. In this situation, you should manually update it by calling <see cref="M:UnityEngine.InputSystem.InputControl.ApplyParameterChanges"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.CalculateOptimizedControlDataType">
            <summary>
            Calculates and returns a optimized data type that can represent a control's value in memory directly.
            The value then is cached in <see cref="P:UnityEngine.InputSystem.InputControl.optimizedControlDataType"/>.
            This method is for internal use only, you should not call this from your own code.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl.ApplyParameterChanges">
            <summary>
            Apply built-in parameters changes (e.g. <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.invert"/>, others), recompute <see cref="P:UnityEngine.InputSystem.InputControl.optimizedControlDataType"/> for impacted controls and clear cached value.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControl`1">
            <summary>
            Base class for input controls with a specific value type.
            </summary>
            <typeparam name="TValue">Type of value captured by the control. Note that this does not mean
            that the control has to store data in the given value format. A control that captures float
            values, for example, may be stored in state as byte values instead.</typeparam>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControl`1.value">
             <summary>
             Returns the current value of the control after processors have been applied.
             </summary>
             <returns>The controls current value.</returns>
             <remarks>
             This can only be called on devices that have been added to the system (<see cref="P:UnityEngine.InputSystem.InputDevice.added"/>).
            
             If internal feature "USE_READ_VALUE_CACHING" is enabled, then this property implements caching
             to avoid applying processors when the underlying control has not changed.
             With this in mind, be aware of processors that use global state, such as the <see cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>.
             Unless the control unprocessed value has been changed, input system settings changed or <see cref="M:UnityEngine.InputSystem.InputControl.ApplyParameterChanges"/> invoked,
             the processors will not run and calls to <see cref="P:UnityEngine.InputSystem.InputControl`1.value"/> will return the same result as previous calls.
            
             If a processor requires to be run on every read, override <see cref="P:UnityEngine.InputSystem.InputProcessor.cachingPolicy"/> property
             in the processor and set it to <see cref="F:UnityEngine.InputSystem.InputProcessor.CachingPolicy.EvaluateOnEveryRead"/>.
            
             To improve debugging try setting "PARANOID_READ_VALUE_CACHING_CHECKS" internal feature flag to check if cache value is still consistent.
            
             Also note that this property returns the result as ref readonly. If custom control states are in use, i.e.
             any controls not shipped with the Input System package, be careful of accidental defensive copies
             <see href="https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code#avoid-defensive-copies"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValue">
             <summary>
             Returns the current value of the control after processors have been applied.
             </summary>
             <returns>The controls current value.</returns>
             <remarks>
             This can only be called on devices that have been added to the system (<see cref="P:UnityEngine.InputSystem.InputDevice.added"/>).
            
             If internal feature "USE_READ_VALUE_CACHING" is enabled, then this property implements caching
             to avoid applying processors when the underlying control has not changed.
             With this in mind, be aware of processors that use global state, such as the <see cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>.
             Unless the control unprocessed value has been changed, input system settings changed or <see cref="M:UnityEngine.InputSystem.InputControl.ApplyParameterChanges"/> invoked,
             the processors will not run and calls to <see cref="P:UnityEngine.InputSystem.InputControl`1.value"/> will return the same result as previous calls.
            
             If a processor requires to be run on every read, override <see cref="P:UnityEngine.InputSystem.InputProcessor.cachingPolicy"/> property
             in the processor and set it to <see cref="F:UnityEngine.InputSystem.InputProcessor.CachingPolicy.EvaluateOnEveryRead"/>.
            
             To improve debugging try setting "PARANOID_READ_VALUE_CACHING_CHECKS" internal feature flag to check if cache value is still consistent.
             <see href="https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code#avoid-defensive-copies"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl`1.value"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromPreviousFrame">
            <summary>
            Get the control's value from the previous frame (<see cref="P:UnityEngine.InputSystem.InputControl.previousFrameStatePtr"/>).
            </summary>
            <returns>The control's value in the previous frame.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadDefaultValue">
            <summary>
            Get the control's default value.
            </summary>
            <returns>The control's default value.</returns>
            <remarks>
            This is not necessarily equivalent to <c>default(TValue)</c>. A control's default value is determined
            by reading its value from the default state (<see cref="P:UnityEngine.InputSystem.InputControl.defaultStatePtr"/>) which in turn
            is determined from settings in the control's registered layout (<see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.defaultState"/>).
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromStateWithCaching(System.Void*)">
            <summary>
            Read value from provided <paramref name="statePtr"/> and apply processors. Try cache result if possible.
            </summary>
            <param name="statePtr">State pointer to read from.</param>
            <returns>The controls current value.</returns>
            <remarks>
            If <paramref name="statePtr"/> is "currentStatePtr", then read will be done via <see cref="P:UnityEngine.InputSystem.InputControl`1.value"/> property to improve performance.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl`1.value"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadUnprocessedValueFromStateWithCaching(System.Void*)">
            <summary>
            Read value from provided <paramref name="statePtr"/>. Try cache result if possible.
            </summary>
            <param name="statePtr">State pointer to read from.</param>
            <returns>The controls current value.</returns>
            <remarks>
            If <paramref name="statePtr"/> is "currentStatePtr", then read will be done via <see cref="P:UnityEngine.InputSystem.InputControl`1.unprocessedValue"/> property to improve performance.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl`1.value"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromStateAsObject(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.WriteValueFromObjectIntoState(System.Object,System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromBufferAsObject(System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.InputControl`1.ProcessValue(`0@)">
            <summary>
            Applies all control processors to the passed value.
            </summary>
            <param name="value"></param>
            <remarks>
            Use this overload when your state struct is large to avoid creating copies of the state.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.CommonUsages">
            <summary>
            A collection of common usage string values as reported by <see cref="P:UnityEngine.InputSystem.InputControl.usages"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Primary2DMotion">
            <summary>
            Primary 2D motion control.
            </summary>
            <remarks>
            Example: Left stick on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Secondary2DMotion">
            <summary>
            Secondary 2D motion control.
            </summary>
            <remarks>
            Example: Right stick on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.PrimaryAction">
            <summary>
            The primary action control on any input device, such as a gamepad, mouse, or keyboard.
            </summary>
            <remarks>
            Example: Primary mouse button (left button on right-handed configuration, right button on left-handed configuration),
            south-button on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.SecondaryAction">
            <summary>
            Secondary action control on any input device, such as a gamepad, mouse, or keyboard.
            </summary>
            <remarks>
            Example: Secondary mouse button (right button on right-handed configuration, left button on left-handed configuration),
            east-button on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.PrimaryTrigger">
            <summary>
            The primary trigger control on input devices with triggers.
            </summary>
            <remarks>
            Example: Right trigger-button on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.SecondaryTrigger">
            <summary>
            The secondary trigger control on input devices with triggers.
            </summary>
            <remarks>
            Example: Left trigger-button on a gamepad.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Modifier">
            <summary>
            A modifier action control that modifies usage of other controls.
            </summary>
            <remarks>
            Example: Keyboard modifier keys like CTRL, SHIFT, ALT, OPTION, etc.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Position">
            <summary>
            The spatial position control on input devices with spatial tracking.
            </summary>
            <remarks>
            Example: User head position in tracking-space using e.g. a head-tracking system. This could for example be a VR tracking system or another user-facing tracking sensor.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Orientation">
            <summary>
            The spatial orientation control on input devices with spatial tracking.
            </summary>
            <remarks>
            Example: User head-orientation in tracking-space using e.g. a head-tracking system. This could for example be a VR tracking system or another user-facing tracking sensor.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Hatswitch">
            <summary>
            The primary hat-switch control on input devices with hat-switches such as joysticks or gamepads.
            </summary>
            <remarks>
            Example: Joystick or gamepad hat-switch.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Back">
             <summary>
             Button to navigate to previous location.
             </summary>
             <remarks>
             Example: Escape on keyboard, B button on gamepad.
            
             In general, the "Back" control is used for moving backwards in the navigation history
             of a UI. This is used, for example, in hierarchical menu structures to move back to parent menus
             (e.g. from the "Settings" menu back to the "Main" menu). Consoles generally have stringent requirements
             as to which button has to fulfill this role.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Forward">
            <summary>
            Button to navigate to next location.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Menu">
            <summary>
            Button to bring up menu.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Submit">
            <summary>
            Button to confirm the current choice.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Cancel">
            <summary>
            Button to not accept the current choice.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Horizontal">
            <summary>
            Horizontal motion axis.
            </summary>
            <remarks>
            Example: X axis on mouse.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Vertical">
            <summary>
            Vertical motion axis.
            </summary>
            <remarks>
            Example: Y axis on mouse.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Twist">
            <summary>
            Rotation around single, fixed axis.
            </summary>
            <remarks>
            Example: twist on joystick or twist of pen (few pens support that).
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Pressure">
            <summary>
            Pressure level axis.
            </summary>
            <remarks>
            Example: pen pressure.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.ScrollHorizontal">
            <summary>
            Axis to scroll horizontally.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.ScrollVertical">
            <summary>
            Axis to scroll vertically.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.Point">
            <summary>
            A screen-space point.
            </summary>
            <remarks>
            Example: Touch contact point.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.LowFreqMotor">
            <summary>
            Low-frequency haptic motor for force-feedback.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.HighFreqMotor">
            <summary>
            High-frequency haptic motor for force-feedback.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.LeftHand">
            <summary>
            Device in left hand.
            </summary>
            <remarks>
            Example: left hand XR controller.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.RightHand">
            <summary>
            Device in right hand.
            </summary>
            <remarks>
            Example: right hand XR controller.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.CommonUsages.BatteryStrength">
            <summary>
            Axis representing charge of battery (1=full, 0=empty).
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlLayoutChange">
            <summary>
            Enum used to identity the change type for the <see cref="E:UnityEngine.InputSystem.InputSystem.onLayoutChange"/> event.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionSetupExtensions">
            <summary>
            Methods to change the setup of <see cref="T:UnityEngine.InputSystem.InputAction"/>, <see cref="T:UnityEngine.InputSystem.InputActionMap"/>,
            and <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> objects.
            </summary>
            <remarks>
            Unlike the methods in <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions"/>, the methods here are
            generally destructive, i.e. they will rearrange the data for actions.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddActionMap(UnityEngine.InputSystem.InputActionAsset,System.String)">
            <summary>
            Create an action map with the given name and add it to the asset.
            </summary>
            <param name="asset">Asset to add the action map to</param>
            <param name="name">Name to assign to the </param>
            <returns>The newly added action map.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> or
            <exception cref="T:System.InvalidOperationException">An action map with the given <paramref name="name"/>
            already exists in <paramref name="asset"/>.</exception>
            <paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddActionMap(UnityEngine.InputSystem.InputActionAsset,UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Add an action map to the asset.
            </summary>
            <param name="asset">Asset to add the map to.</param>
            <param name="map">A named action map.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> or <paramref name="asset"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="map"/> has no name or asset already contains a
            map with the same name -or- <paramref name="map"/> is currently enabled -or- <paramref name="map"/> is part of
            an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> that has <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s that are enabled.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveActionMap(UnityEngine.InputSystem.InputActionAsset,UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Remove the given action map from the asset.
            </summary>
            <param name="asset">Asset to add the action map to.</param>
            <param name="map">An action map. If the given map is not part of the asset, the method
            does nothing.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> or <paramref name="map"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="map"/> is currently enabled (see <see
            cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>) or is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> that has <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s
            that are currently enabled.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveActionMap(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveActionMap(UnityEngine.InputSystem.InputActionAsset,System.String)">
            <summary>
            Remove the action map with the given name or ID from the asset.
            </summary>
            <param name="asset">Asset to remove the action map from.</param>
            <param name="nameOrId">The name or ID (see <see cref="P:UnityEngine.InputSystem.InputActionMap.id"/>) of a map in the
            asset. Note that lookup is case-insensitive. If no map with the given name or ID is found,
            the method does nothing.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> or <paramref name="nameOrId"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">The map referenced by <paramref name="nameOrId"/> is currently enabled
            (see <see cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>).</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveActionMap(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddAction(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Add a new <see cref="T:UnityEngine.InputSystem.InputAction"/> to the given <paramref name="map"/>.
            </summary>
            <param name="map">Action map to add the action to. The action will be appended to
            <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> of the map. The map must be disabled (see
            <see cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>).</param>
            <param name="name">Name to give to the action. Must not be <c>null</c> or empty. Also,
            no other action that already exists in <paramref name="map"/> must have this name already.</param>
            <param name="type">Action type. See <see cref="P:UnityEngine.InputSystem.InputAction.type"/>.</param>
            <param name="binding">If not <c>null</c>, a binding is automatically added to the newly created action
            with the value of this parameter being used as the binding's <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
            <param name="interactions">If <paramref name="binding"/> is not <c>null</c>, this string is used for
            <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> of the binding that is automatically added for the action.</param>
            <param name="processors">If <paramref name="binding"/> is not <c>null</c>, this string is used for
            <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> of the binding that is automatically added for the action.</param>
            <param name="groups">If <paramref name="binding"/> is not <c>null</c>, this string is used for
            <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> of the binding that is automatically added for the action.</param>
            <param name="expectedControlLayout">Value for <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/>; <c>null</c>
            by default.</param>
            <returns>The newly added input action.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="map"/> is enabled (see <see cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>)
            or is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> that has <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s that are <see cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>
            -or- <paramref name="map"/> already contains an action called <paramref name="name"/> (case-insensitive).</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveAction(UnityEngine.InputSystem.InputAction)">
            <summary>
            Remove the given action from its <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
            </summary>
            <param name="action">An input action that is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="action"/> is a standalone action
            that is not part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/> and thus cannot be removed from anything.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="action"/> is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>
            or <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> that has at least one enabled action.</exception>
            <remarks>
            After removal, the action's <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/> will be set to <c>null</c>
            and the action will effectively become a standalone action that is not associated with
            any action map. Bindings on the action will be preserved. On the action map, the bindings
            for the action will be removed.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddAction(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveAction(UnityEngine.InputSystem.InputActionAsset,System.String)">
            <summary>
            Remove the action with the given name from the asset.
            </summary>
            <param name="asset">Asset to remove the action from.</param>
            <param name="nameOrId">Name or ID of the action. See <see cref="M:UnityEngine.InputSystem.InputActionAsset.FindAction(System.String,System.Boolean)"/> for
            details.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> -or- <paramref name="nameOrId"/>
            is <c>null</c> or empty.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveAction(UnityEngine.InputSystem.InputAction)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String,System.String)">
            <summary>
            Add a new binding to the given action.
            </summary>
            <param name="action">Action to add the binding to. If the action is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>,
            the newly added binding will be visible on <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>.</param>
            <param name="path">Binding path string. See <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> for details.</param>
            <param name="interactions">Optional list of interactions to apply to the binding. See <see
            cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> for details.</param>
            <param name="processors">Optional list of processors to apply to the binding. See <see
            cref="P:UnityEngine.InputSystem.InputBinding.processors"/> for details.</param>
            <param name="groups">Optional list of binding groups that should be assigned to the binding. See
            <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> for details.</param>
            <returns>Fluent-style syntax to further configure the binding.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)">
            <summary>
            Add a binding that references the given <paramref name="control"/> and triggers
            the given <paramref cref="!:action"/>.
            </summary>
            <param name="action">Action to trigger.</param>
            <param name="control">Control to bind to. The full <see cref="P:UnityEngine.InputSystem.InputControl.path"/> of the control will
            be used in the resulting <see cref="T:UnityEngine.InputSystem.InputBinding">binding</see>.</param>
            <returns>Syntax to configure the binding further.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is null or <paramref name="control"/> is null.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Add a new binding to the action.
             </summary>
             <param name="action">An action to add the binding to.</param>
             <param name="binding">Binding to add to the action or default. Binding can be further configured via
             the struct returned by the method.</param>
             <returns>
             Returns a fluent-style syntax structure that allows performing additional modifications
             based on the new binding.
             </returns>
             <remarks>
             This works both with actions that are part of an action set as well as with actions that aren't.
            
             Note that actions must be disabled while altering their binding sets. Also, if the action belongs
             to a set, all actions in the set must be disabled.
            
             <example>
             <code>
             fireAction.AddBinding()
                 .WithPath("&lt;Gamepad&gt;/buttonSouth")
                 .WithGroup("Gamepad");
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputActionMap,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Add a new binding to the given action map.
            </summary>
            <param name="actionMap">Action map to add the binding to.</param>
            <param name="path">Path of the control(s) to bind to. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/> and
            <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
            <param name="interactions">Names and parameters for interactions to apply to the
            binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>.</param>
            <param name="groups">Optional list of groups to apply to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
            <param name="action">Action to trigger from the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.action"/>.</param>
            <param name="processors">Optional list of processors to apply to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>.</param>
            <returns>A write-accessor to the newly added binding.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            // Add a binding for the A button the gamepad and make it trigger
            // the "fire" action.
            var gameplayActions = playerInput.actions.FindActionMap("gameplay");
            gameplayActions.AddBinding("&lt;Gamepad&gt;/buttonSouth", action: "fire");
            </code>
            </example>
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputAction,System.String,System.String)">
            <summary>
            Add a new binding that triggers the given action to the given action map.
            </summary>
            <param name="actionMap">Action map to add the binding to.</param>
            <param name="action">Action to trigger from the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.action"/>.
            Must be part of <paramref name="actionMap"/>.</param>
            <param name="path">Path of the control(s) to bind to. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/> and
            <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
            <param name="interactions">Names and parameters for interactions to apply to the
            binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>.</param>
            <param name="groups">Binding groups to apply to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
            <returns>A write-accessor to the newly added binding.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="action"/> is not part of <paramref name="actionMap"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c>.</exception>
            <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputActionMap,System.String,System.Guid,System.String,System.String)">
            <summary>
            Add a new binding that triggers the action given by GUID <paramref name="action"/>.
            </summary>
            <param name="actionMap">Action map to add the binding to.</param>
            <param name="path">Path of the control(s) to bind to. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/> and <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
            <param name="action">ID of the action as per <see cref="P:UnityEngine.InputSystem.InputAction.id"/>.</param>
            <param name="interactions">Optional list of names and parameters for interactions to apply to the
            binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>.</param>
            <param name="groups">Optional list of groups to apply to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
            <returns>A write-accessor to the newly added binding.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="action"/> is not part of <paramref name="actionMap"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c>.</exception>
            <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
            <remarks>
            Example of adding a binding to an action map that binds to a Gamepad device "leftStick" control and associates it with an action:
            <example>
            <code>
            var map = new InputActionMap();
            var action = map.AddAction("action");
            map.AddBinding("&lt;Gamepad&gt;/leftStick", action: action.id);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputActionMap,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Add a binding to the given action map.
            </summary>
            <param name="actionMap">Action map to add the binding to.</param>
            <param name="binding">Binding to add to the action map.</param>
            <returns>A write-accessor to the newly added binding.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="action"/> is not part of <paramref name="actionMap"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c>.</exception>
            <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddCompositeBinding(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String)">
            <summary>
            Add a composite binding to the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>.
            </summary>
            <param name="action">Action to add the binding to.</param>
            <param name="composite">Type of composite to add. This needs to be the name the composite
            has been registered under using <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>. Case-insensitive.</param>
            <param name="interactions">Interactions to add to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>.</param>
            <param name="processors">Processors to add to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>.</param>
            <returns>A write accessor to the newly added composite binding.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="composite"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputAction,System.Int32)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             at the given <paramref name="index"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="index">Index in <paramref name="action"/>'s <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the binding to be changed.</param>
             <returns>A write accessor to the given binding.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change its second binding to go to the left mouse button.
             fireAction.ChangeBinding(1)
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is out of range (as per <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             of <paramref name="action"/>).</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputAction,System.String)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             with the given <paramref name="name"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="name">Name of the binding to be changed <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.</param>
             <returns>A write accessor to the given binding.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change its second binding to go to the left mouse button.
             fireAction.ChangeBinding("fire")
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is out of range (as per <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             of <paramref name="action"/>).</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputActionMap,System.Int32)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>
             at the given <paramref name="index"/>.
             </summary>
             <param name="actionMap">Action map whose bindings to change.</param>
             <param name="index">Index in <paramref name="actionMap"/>'s <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of the binding to be changed.</param>
             <returns>A write accessor to the given binding.</returns>
             <remarks>
             <example>
             <code>
             // Grab "gameplay" actions from PlayerInput.
             var gameplayActions = playerInput.actions.FindActionMap("gameplay");
            
             // Change its second binding to go to the left mouse button.
             gameplayActions.ChangeBinding(1)
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is out of range (as per <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
             of <paramref name="actionMap"/>).</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBindingWithId(UnityEngine.InputSystem.InputAction,System.String)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             that has the given <paramref name="id"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="id">ID of the binding as per <see cref="P:UnityEngine.InputSystem.InputBinding.id"/>.</param>
             <returns>A write accessor to the binding with the given ID.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change the binding with the given ID to go to the left mouse button.
             fireAction.ChangeBindingWithId("c3de9215-31c3-4654-8562-854bf2f7864f")
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">No binding with the given <paramref name="id"/> exists
             on <paramref name="action"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBindingWithId(UnityEngine.InputSystem.InputAction,System.Guid)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             that has the given <paramref name="id"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="id">ID of the binding as per <see cref="P:UnityEngine.InputSystem.InputBinding.id"/>.</param>
             <returns>A write accessor to the binding with the given ID.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change the binding with the given ID to go to the left mouse button.
             fireAction.ChangeBindingWithId(new Guid("c3de9215-31c3-4654-8562-854bf2f7864f"))
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">No binding with the given <paramref name="id"/> exists
             on <paramref name="action"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBindingWithGroup(UnityEngine.InputSystem.InputAction,System.String)">
             <summary>
             Get write access to the first binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             that is assigned to the given binding <paramref name="group"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="group">Name of the binding group as per <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
             <returns>A write accessor to the first binding on <paramref name="action"/> that is assigned to the
             given binding <paramref name="group"/>.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change the binding in the "Keyboard&amp;Mouse" group to go to the left mouse button.
             fireAction.ChangeBindingWithGroup("Keyboard&amp;Mouse")
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">No binding on the <paramref name="action"/> is assigned
             to the given binding <paramref name="group"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBindingWithPath(UnityEngine.InputSystem.InputAction,System.String)">
             <summary>
             Get write access to the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>
             that is bound to the given <paramref name="path"/>.
             </summary>
             <param name="action">Action whose bindings to change.</param>
             <param name="path">Path of the binding as per <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
             <returns>A write accessor to the binding on <paramref name="action"/> that is assigned the
             given <paramref name="path"/>.</returns>
             <remarks>
             <example>
             <code>
             // Grab "fire" action from PlayerInput.
             var fireAction = playerInput.actions["fire"];
            
             // Change the binding to the right mouse button to go to the left mouse button instead.
             fireAction.ChangeBindingWithPath("&lt;Mouse&gt;/rightButton")
                 .WithPath("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">No binding on the <paramref name="action"/> is assigned
             the given <paramref name="path"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Get write access to the binding on <paramref name="action"/> that matches the given
            <paramref name="match"/>.
            </summary>
            <param name="action">Action whose bindings to match against.</param>
            <param name="match">A binding mask. See <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> for
            details.</param>
            <returns>A write-accessor to the first binding matching <paramref name="match"/> or
            an invalid accessor (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>) if no binding was found to
            match the mask.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeCompositeBinding(UnityEngine.InputSystem.InputAction,System.String)">
            <summary>
            Get a write accessor to the binding of <paramref name="action"/> that is both a composite
            (see <see cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>) and has the given binding name or composite
            type.
            </summary>
            <param name="action">Action to look up the binding on. All bindings in the action's
            <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> property will be considered.</param>
            <param name="compositeName">Either the name of the composite binding (see <see cref="P:UnityEngine.InputSystem.InputBinding.name"/>)
            to look for or the name of the composite type used in the binding (such as "1DAxis"). Case-insensitive.</param>
            <returns>A write accessor to the given composite binding or an invalid accessor if no composite
            matching <paramref name="compositeName"/> could be found on <paramref name="action"/>.</returns>
            <remarks>
            <example>
            <code>
            // Add arrow keys as alternatives to the WASD Vector2 composite.
            playerInput.actions["move"]
                .ChangeCompositeBinding("WASD")
                    .InsertPartBinding("Up", "&lt;Keyboard&gt;/upArrow")
                    .InsertPartBinding("Down", "&lt;Keyboard&gt;/downArrow")
                    .InsertPartBinding("Left", "&lt;Keyboard&gt;/leftArrow")
                    .InsertPartBinding("Right", "&lt;Keyboard&gt;/rightArrow");
            </code>
            </example>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="compositeName"/>
            is <c>null</c> or empty.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.Rename(UnityEngine.InputSystem.InputAction,System.String)">
            <summary>
            Rename an existing action.
            </summary>
            <param name="action">Action to assign a new name to. Can be singleton action or action that
            is part of a map.</param>
            <param name="newName">New name to assign to action. Cannot be empty.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is null or <paramref name="newName"/> is
            null or empty.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/> of <paramref name="action"/>
            already contains an action called <paramref name="newName"/>.</exception>
            <remarks>
            Renaming an action will also update the bindings that refer to the action.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,UnityEngine.InputSystem.InputControlScheme)">
            <summary>
            Add a new control scheme to the asset.
            </summary>
            <param name="asset">Asset to add the control scheme to.</param>
            <param name="controlScheme">Control scheme to add.</param>
            <exception cref="T:System.ArgumentException"><paramref name="controlScheme"/> has no name.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">A control scheme with the same name as <paramref name="controlScheme"/>
            already exists in the asset.</exception>
            <remarks>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)">
             <summary>
             Add a new control scheme to the given <paramref name="asset"/>.
             </summary>
             <param name="asset">Asset to add the control scheme to.</param>
             <param name="name">Name to give to the control scheme. Must be unique within the control schemes of the
             asset. Also used as default name of <see cref="P:UnityEngine.InputSystem.InputControlScheme.bindingGroup">binding group</see> associated
             with the control scheme.</param>
             <returns>Syntax to allow providing additional configuration for the newly added control scheme.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> -or- <paramref name="name"/>
             is <c>null</c> or empty.</exception>
             <remarks>
             <example>
             <code>
             // Create an .inputactions asset.
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
            
             // Add an action map to it.
             var actionMap = asset.AddActionMap("actions");
            
             // Add an action to it and bind it to the A button on the gamepad.
             // Also, associate that binding with the "Gamepad" control scheme.
             var action = actionMap.AddAction("action");
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth", groups: "Gamepad");
            
             // Add a control scheme called "Gamepad" that requires a Gamepad device.
             asset.AddControlScheme("Gamepad")
                 .WithRequiredDevice&lt;Gamepad&gt;();
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)">
            <summary>
            Remove the control scheme with the given name from the asset.
            </summary>
            <param name="asset">Asset to remove the control scheme from.</param>
            <param name="name">Name of the control scheme. Matching is case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is null -or- <paramref name="name"/>
            is <c>null</c> or empty.</exception>
            <remarks>
            If no control scheme with the given name can be found, the method does nothing.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.WithBindingGroup(UnityEngine.InputSystem.InputControlScheme,System.String)">
            <summary>
            Associates the control scheme given by <paramref name="scheme"/> with the binding group given by <paramref name="bindingGroup"/>.
            </summary>
            <param name="scheme">The control scheme to modify.</param>
            <param name="bindingGroup">The binding group to be associated with the control scheme.</param>
            <returns><paramref name="scheme"/></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax">
             <summary>
             Write accessor to a binding on either an <see cref="T:UnityEngine.InputSystem.InputAction"/> or an
             <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
             </summary>
             <remarks>
             Both <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> and <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> are
             read-only. To modify bindings (other than setting overrides which you can do
             through <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>),
             it is necessary to gain indirect write access through this structure.
            
             <example>
             <code>
             playerInput.actions["fire"]
                 .ChangeBinding(0)
                 .WithPath("&lt;Keyboard&gt;/space");
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid">
            <summary>
            True if the if binding accessor is valid.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.bindingIndex">
            <summary>
            Index of the binding that the accessor refers to.
            </summary>
            <remarks>
            When accessing bindings on an <see cref="T:UnityEngine.InputSystem.InputAction"/>, this is the index in
            <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the action. When accessing bindings on an
            <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, it is the index <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
            of the map.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.binding">
            <summary>
            The current binding in entirety.
            </summary>
            <exception cref="T:System.InvalidOperationException">The accessor is not <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithName(System.String)">
            <summary>
            Set the <see cref="P:UnityEngine.InputSystem.InputBinding.name"/> of the binding.
            </summary>
            <param name="name">Name for the binding.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is not <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.name"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithPath(System.String)">
            <summary>
            Set the <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> of the binding.
            </summary>
            <param name="path">Path for the binding.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is not <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithGroup(System.String)">
            <summary>
            Add <paramref name="group"/> to the list of <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> of the binding.
            </summary>
            <param name="group">Name of the binding group (such as "Gamepad").</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="group"/> is <c>null</c> or empty -or- it contains
            a <see cref="F:UnityEngine.InputSystem.InputBinding.Separator"/> character.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithGroups(System.String)">
            <summary>
            Add all the groups specified in <paramref name="groups"/> to the list of <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/> of the binding.
            </summary>
            <param name="groups">A semi-colon separated list of group names.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithInteraction(System.String)">
            <summary>
            Add an interaction via specified name in <paramref name="interaction"/> to the list of interactions.
            </summary>
            <param name="interaction">Interaction class name</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
            <exception cref="T:System.ArgumentException">If interaction name is null or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithInteractions(System.String)">
            <summary>
            Add the set of interactions specified in <paramref name="interactions"/> to the list of interactions.
            </summary>
            <param name="interactions">A semi-colon separated list of interaction names.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithInteraction``1">
            <summary>
            Add an interaction of type specified in <typeparamref name="TInteraction"/> to the list of interactions.
            </summary>
            <typeparam name="TInteraction"></typeparam>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
            <exception cref="T:System.NotSupportedException">Interaction type has not been registered.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithProcessor(System.String)">
            <summary>
            Add a processor to the list of <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> of the binding.
            </summary>
            <param name="processor">Name of the processor, such as &quot;Scale&quot;.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
            <exception cref="T:System.ArgumentException">The processor name is null or empty.</exception>
            <exception cref="T:System.ArgumentException">The processor name contains a semi-colon.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithProcessors(System.String)">
            <summary>
            Add processors to the list of <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> of the binding.
            </summary>
            <param name="processors">A semi-colon separated list of processor names.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.WithProcessor``1">
            <summary>
            Add a processor to the list of <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> of the binding.
            </summary>
            <typeparam name="TProcessor">Type of processor.</typeparam>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
            <exception cref="T:System.NotSupportedException">Processor type has not been registered.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.Triggering(UnityEngine.InputSystem.InputAction)">
            <summary>
            Specify which action to trigger.
            </summary>
            <param name="action">Action to trigger.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid.</exception>
            <exception cref="T:System.ArgumentNullException">Provided action is null.</exception>
            <exception cref="T:System.ArgumentException">Provided action is a singleton action (not part of any action maps).</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.To(UnityEngine.InputSystem.InputBinding)">
            <summary>
            Replace the current binding with the given one.
            </summary>
            <param name="binding">An input binding.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <remarks>
            This method replaces the current binding wholesale, i.e. it will overwrite all fields.
            Be aware that this has the potential of corrupting the binding data in case the given
            binding is a composite.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.NextBinding">
            <summary>
            Switch to configuring the next binding.
            </summary>
            <returns>An instance configured to edit the next binding or an invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>) instance if
            there is no next binding.</returns>
            <remarks>If the BindingSyntax is restricted to a single action, the result will be invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>)
            if there is no next binding on the action. If the BindingSyntax is restricted to an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, the result will
            be be invalid if there is no next binding in the map.</remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.PreviousBinding">
            <summary>
            Switch to configuring the previous binding.
            </summary>
            <returns>An instance configured to edit the previous binding or an invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>) instance if
            there is no previous binding.</returns>
            <remarks>If the BindingSyntax is restricted to a single action, the result will be invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>)
            if there is no previous binding on the action. If the BindingSyntax is restricted to an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, the result will
            be be invalid if there is no previous binding in the map.</remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.NextPartBinding(System.String)">
             <summary>
             Iterate to the next part binding of the current composite with the given part name.
             </summary>
             <param name="partName">Name of the part of the binding, such as <c>"Positive"</c>.</param>
             <returns>An accessor to the next part binding with the given name or an invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>)
             accessor if there is no such binding.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="partName"/> is <c>null</c> or empty.</exception>
             <remarks>
             Each binding that is part of a composite is marked with <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>
             set to true. The name of the part is determined by <see cref="P:UnityEngine.InputSystem.InputBinding.name"/> (comparison is
             case-insensitive). Which parts are relevant to a specific composite is determined by the type of
             composite. An <see cref="T:UnityEngine.InputSystem.Composites.AxisComposite"/>, for example, has <c>"Negative"</c> and a
             <c>"Positive"</c> part.
            
             <example>
             <code>
             // Delete first "Positive" part of "Axis" composite.
             action.ChangeCompositeBinding("Axis")
                 .NextPartBinding("Positive").Erase();
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
             <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.PreviousPartBinding(System.String)">
            <summary>
            Iterate to the previous part binding of the current composite with the given part name.
            </summary>
            <param name="partName">Name of the part of the binding, such as <c>"Positive"</c>.</param>
            <returns>An accessor to the previous part binding with the given name or an invalid (see <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>)
            accessor if there is no such binding.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="partName"/> is <c>null</c> or empty.</exception>
            <remarks>
            Each binding that is part of a composite is marked with <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>
            set to true. The name of the part is determined by <see cref="P:UnityEngine.InputSystem.InputBinding.name"/> (comparison is
            case-insensitive). Which parts are relevant to a specific composite is determined by the type of
            composite. An <see cref="T:UnityEngine.InputSystem.Composites.AxisComposite"/>, for example, has <c>"Negative"</c> and a
            <c>"Positive"</c> part.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
            <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.NextCompositeBinding(System.String)">
            <summary>
            Iterate to the next composite binding.
            </summary>
            <param name="compositeName">If <c>null</c> (default), an accessor to the next composite binding,
            regardless of name or type, is returned. If it is not <c>null</c>, can be either the name of
            the binding (see <see cref="P:UnityEngine.InputSystem.InputBinding.name"/>) or the name of the composite used in the
            binding (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)"/></param>).
            <returns>A write accessor to the next composite binding or an invalid accessor (see
            <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>) if no such binding was found.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.PreviousCompositeBinding(System.String)">
            <summary>
            Iterate to the previous composite binding.
            </summary>
            <param name="compositeName">If <c>null</c> (default), an accessor to the previous composite binding,
            regardless of name or type, is returned. If it is not <c>null</c>, can be either the name of
            the binding (see <see cref="P:UnityEngine.InputSystem.InputBinding.name"/>) or the name of the composite used in the
            binding (see <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)"/>).</param>
            <returns>A write accessor to the previous composite binding or an invalid accessor (see
            <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>) if no such binding was found.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.Erase">
             <summary>
             Remove the binding.
             </summary>
             <remarks>
             If the binding is a composite (see <see cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>), part bindings of the
             composite will be removed as well.
            
             Note that the accessor will not necessarily be invalidated. Instead, it will point to what used
             to be the next binding in the array (though that means the accessor will be invalid if the binding
             that got erased was the last one in the array).
             </remarks>
             <exception cref="T:System.InvalidOperationException">The instance is not <see cref="P:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.valid"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.BindingSyntax.InsertPartBinding(System.String,System.String)">
            <summary>
            Insert a composite part into a composite binding.
            </summary>
            <param name="partName">Name of the part in composite binding.</param>
            <param name="path">Control path to bind to.</param>
            <returns>The same binding syntax for further configuration.</returns>
            <exception cref="T:System.ArgumentNullException">Part name is null or empty.</exception>
            <exception cref="T:System.InvalidOperationException">The binding accessor is invalid or the binding accessor is not pointing to composite or part binding.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionSetupExtensions.CompositeSyntax">
            <summary>
            Write accessor to a composite binding.
            </summary>
            <remarks>
            To add a composite binding to an action, you must first call <see cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddCompositeBinding(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String)"/>
            and then use the CompositeSyntax struct to add composite parts.
            <example>
            <code>
            playerInput.actions["fire"]
                .ChangeBinding(0)
                .AddCompositeBinding("2DVector")
                .With("Up", "&lt;Keyboard&gt;/w")
                .With("Down", "&lt;Keyboard&gt;/s")
                .With("Left", "&lt;Keyboard&gt;/a")
                .With("Right", "&lt;Keyboard&gt;/d");
            </code>
            </example>
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.ChangeBinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionSetupExtensions.CompositeSyntax.bindingIndex">
            <summary>
            Index of the binding that the accessor refers to.
            </summary>
            <remarks>
            When accessing bindings on an <see cref="T:UnityEngine.InputSystem.InputAction"/>, this is the index in
            <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the action. When accessing bindings on an
            <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, it is the index <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
            of the map.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.CompositeSyntax.With(System.String,System.String,System.String,System.String)">
            <summary>
            Add a part binding to the composite.
            </summary>
            <param name="name">Name of the part. This is dependent on the type of composite. For
            <see cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/>, for example, the valid parts are <c>"Up"</c>, <c>"Down"</c>,
            <c>"Left"</c>, and <c>"Right"</c>.</param>
            <param name="binding">Control path to binding to. See <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
            <param name="groups">Binding groups to assign to the part binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
            <param name="processors">Optional list of processors to apply to the binding. See <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>.</param>
            <returns>The same composite syntax for further configuration.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax">
            <summary>
            Write accessor to a control scheme.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.WithBindingGroup(System.String)">
            <summary>
            Sets or overwrite the binding group for control scheme.
            </summary>
            <param name="bindingGroup">A binding group. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
            <returns>The same control scheme syntax for further configuration.</returns>
            <exception cref="T:System.ArgumentNullException">If provided name is null or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.WithRequiredDevice``1">
            <summary>
            Adds a required device to control scheme.
            </summary>
            <typeparam name="TDevice">Type of device.</typeparam>
            <returns>The same control scheme syntax for further configuration.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.WithOptionalDevice``1">
            <summary>
            Adds an optional device to control scheme.
            </summary>
            <typeparam name="TDevice">Type of device.</typeparam>
            <returns>The same control scheme syntax for further configuration.</returns>
            <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.OrWithRequiredDevice``1">
             <summary>
             Combines another required device with the previous device using boolean OR
             logic such that either the previous device or this device are required to be present.
             </summary>
             <typeparam name="TDevice">Type of device.</typeparam>
             <returns>The same control scheme syntax for further configuration.</returns>
             <remarks>
             <example>
             <code>
             // Create an .inputactions asset.
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
            
             asset.AddControlScheme("KeyboardAndMouseOrPen")
                 .WithRequiredDevice("&lt;Keyboard&gt;")
                 .WithRequiredDevice("&lt;Mouse&gt;")
                 .OrWithRequiredDevice("&lt;Pen&gt;")
             </code>
             </example>
             </remarks>
             <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOR"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.OrWithOptionalDevice``1">
            <summary>
            Combines another optional device with the previous device using boolean OR
            logic such that either the previous device or this device are required to be present.
            If this is the last device in a chain of OR'd devices, the entire chain of
            devices becomes optional.
            </summary>
            <typeparam name="TDevice">Type of device.</typeparam>
            <returns>The same control scheme syntax for further configuration.</returns>
            <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOR"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.WithRequiredDevice(System.String)">
            <summary>
            Adds a required device to control scheme.
            </summary>
            <param name="controlPath">Device path, like &lt;Gamepad&gt;.</param>
            <returns>The same control scheme syntax for further configuration.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.WithOptionalDevice(System.String)">
            <summary>
            Add an optional device to the control scheme.
            </summary>
            <param name="controlPath">The device path, like &lt;Gamepad&gt;.</param>
            <returns>The same control scheme syntax for further configuration.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.OrWithRequiredDevice(System.String)">
            <summary>
            Adds another possible required device to the control scheme.
            </summary>
            <param name="controlPath">Device path, like &lt;Gamepad&gt;.</param>
            <returns>The same control scheme syntax for further configuration.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.OrWithOptionalDevice(System.String)">
            <summary>
            Adds another possible optional device to control scheme.
            </summary>
            <param name="controlPath">Device path, like &lt;Gamepad&gt;.</param>
            <returns>The same control scheme syntax for further configuration.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionSetupExtensions.ControlSchemeSyntax.Done">
            <summary>
            Call this method when done building out the control scheme to return the associated instance.
            </summary>
            <returns>The associated control scheme</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.TrackedDevice">
            <summary>
            An input device that has its orientation and position in space tracked.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.XR.XRController"/>
            <seealso cref="T:UnityEngine.InputSystem.XR.XRHMD"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionReference">
             <summary>
             References a specific <see cref="T:UnityEngine.InputSystem.InputAction"/> in an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>
             stored inside an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>.
             </summary>
             <remarks>
             The difference to a plain reference directly to an <see cref="T:UnityEngine.InputSystem.InputAction"/> object is
             that an InputActionReference can be serialized without causing the referenced <see cref="T:UnityEngine.InputSystem.InputAction"/>
             to be serialized as well. The reference will remain intact even if the action or the map
             that contains the action is renamed.
            
             References can be set up graphically in the editor by dropping individual actions from the project
             browser onto a reference field.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputActionProperty"/>
             <seealso cref="T:UnityEngine.InputSystem.InputAction"/>
             <seealso cref="T:UnityEngine.InputSystem.InputActionAsset"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionReference.asset">
            <summary>
            The asset that the referenced action is part of. Null if the reference
            is not initialized or if the asset has been deleted.
            </summary>
            <value>InputActionAsset of the referenced action.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionReference.action">
            <summary>
            The action that the reference resolves to. Null if the action
            cannot be found.
            </summary>
            <value>The action that reference points to.</value>
            <remarks>
            Actions are resolved on demand based on their internally stored IDs.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.Set(UnityEngine.InputSystem.InputAction)">
            <summary>
            Initialize the reference to refer to the given action.
            </summary>
            <param name="action">An input action. Must be contained in an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>
            that is itself contained in an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>. Can be <c>null</c> in which
            case the reference is reset to its default state which does not reference an action.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="action"/> is not contained in an
            <see cref="T:UnityEngine.InputSystem.InputActionMap"/> that is itself contained in an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.Set(UnityEngine.InputSystem.InputActionAsset,System.String,System.String)">
            <summary>
            Look up an action in the given asset and initialize the reference to
            point to it.
            </summary>
            <param name="asset">An .inputactions asset.</param>
            <param name="mapName">Name of the <see cref="T:UnityEngine.InputSystem.InputActionMap"/> in <paramref name="asset"/>
            (see <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>). Case-insensitive.</param>
            <param name="actionName">Name of the action in <paramref name="mapName"/>. Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> -or-
            <paramref name="mapName"/> is <c>null</c> or empty -or- <paramref name="actionName"/>
            is <c>null</c> or empty.</exception>
            <exception cref="T:System.ArgumentException">No action map called <paramref name="mapName"/> could
            be found in <paramref name="asset"/> -or- no action called <paramref name="actionName"/>
            could be found in the action map called <paramref name="mapName"/> in <paramref name="asset"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.ToString">
            <summary>
            Return a string representation of the reference useful for debugging.
            </summary>
            <returns>A string representation of the reference.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.ToDisplayName">
            <summary>
            Return a string representation useful for showing in UI.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.op_Implicit(UnityEngine.InputSystem.InputActionReference)~UnityEngine.InputSystem.InputAction">
            <summary>
            Convert an InputActionReference to the InputAction it points to.
            </summary>
            <param name="reference">An InputActionReference object. Can be null.</param>
            <returns>The value of <see cref="P:UnityEngine.InputSystem.InputActionReference.action"/> from <paramref name="reference"/>. Can be null.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionReference.Create(UnityEngine.InputSystem.InputAction)">
            <summary>
            Create a new InputActionReference object that references the given action.
            </summary>
            <param name="action">An input action. Must be contained in an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>
            that is itself contained in an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>. Can be <c>null</c> in which
            case the reference is reset to its default state which does not reference an action.</param>
            <returns>A new InputActionReference referencing <paramref name="action"/>.</returns>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionReference.m_Action">
            <summary>
            The resolved, cached input action.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.Touch">
             <summary>
             A high-level representation of a touch which automatically keeps track of a touch
             over time.
             </summary>
             <remarks>
             This API obsoletes the need for manually keeping tracking of touch IDs (<see cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/>)
             and touch phases (<see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>) in order to tell one touch apart from another.
            
             Also, this class protects against losing touches. If a touch is shorter-lived than a single input update,
             <see cref="T:UnityEngine.InputSystem.Touchscreen"/> may overwrite it with a new touch coming in in the same update whereas this class
             will retain all changes that happened on the touchscreen in any particular update.
            
             The API makes a distinction between "fingers" and "touches". A touch refers to one contact state change event, that is, a
             finger beginning to touch the screen (<see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>), moving on the screen (<see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>),
             or being lifted off the screen (<see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>).
             A finger, on the other hand, always refers to the Nth contact on the screen.
            
             A Touch instance is a struct which only contains a reference to the actual data which is stored in unmanaged
             memory.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.valid">
             <summary>
             Whether this touch record holds valid data.
             </summary>
             <value>If true, the data contained in the touch is valid.</value>
             <remarks>
             Touch data is stored in unmanaged memory as a circular input buffer. This means that when
             the buffer runs out of capacity, older touch entries will get reused. When this happens,
             existing <c>Touch</c> instances referring to the record become invalid.
            
             This property can be used to determine whether the record held on to by the <c>Touch</c>
             instance is still valid.
            
             This property will be <c>false</c> for default-initialized <c>Touch</c> instances.
            
             Note that accessing most of the other properties on this struct when the touch is
             invalid will trigger <c>InvalidOperationException</c>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.finger">
            <summary>
            The finger used for the touch contact. Null only for default-initialized
            instances of the struct.
            </summary>
            <value>Finger used for the touch contact.</value>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeFingers"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase">
             <summary>
             Current phase of the touch.
             </summary>
             <value>Current phase of the touch.</value>
             <remarks>
             Every touch goes through a predefined cycle that starts with <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>,
             then potentially <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/> and/or <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>,
             and finally concludes with either <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>.
            
             This property indicates where in the cycle the touch is.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.isInProgress"/>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.began">
            <summary>
            Whether the touch has begun this frame, i.e. whether <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> is <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.ended"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.inProgress"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.inProgress">
            <summary>
            Whether the touch is currently in progress, i.e. whether <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> is either
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>, <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>, or <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.began"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.ended"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.ended">
            <summary>
            Whether the touch has ended this frame, i.e. whether <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> is either
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.began"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.isInProgress"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.touchId">
             <summary>
             Unique ID of the touch as (usually) assigned by the platform.
             </summary>
             <value>Unique, non-zero ID of the touch.</value>
             <remarks>
             Each touch contact that is made with the screen receives its own unique ID which is
             normally assigned by the underlying platform.
            
             Note a platform may reuse touch IDs after their respective touches have finished.
             This means that the guarantee of uniqueness is only made with respect to <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches"/>.
            
             In particular, all touches in <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.history"/> will have the same ID whereas
             touches in the a finger's <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Finger.touchHistory"/> may end up having the same
             touch ID even though constituting different physical touch contacts.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.touchId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.pressure">
             <summary>
             Normalized pressure of the touch against the touch surface.
             </summary>
             <value>Pressure level of the touch.</value>
             <remarks>
             Not all touchscreens are pressure-sensitive. If unsupported, this property will
             always return 0.
            
             In general, touch pressure is supported on mobile platforms only.
            
             Note that it is possible for the value to go above 1 even though it is considered normalized. The reason is
             that calibration on the system can put the maximum pressure point below the physically supported maximum value.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.pressure"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.radius">
            <summary>
            Screen-space radius of the touch.
            </summary>
            <value>Horizontal and vertical extents of the touch contact.</value>
            <remarks>
            If supported by the underlying device, this reports the size of the touch contact based on its
            <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.screenPosition"/> center point. If not supported, this will be <c>default(Vector2)</c>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.radius"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.startTime">
            <summary>
            Time in seconds on the same timeline as <c>Time.realTimeSinceStartup</c> when the touch began.
            </summary>
            <value>Start time of the touch.</value>
            <remarks>
            This is the value of <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> when the touch started with
            <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.startTime"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.time">
            <summary>
            Time in seconds on the same timeline as <c>Time.realTimeSinceStartup</c> when the touch record was
            reported.
            </summary>
            <value>Time the touch record was reported.</value>
            <remarks>
            This is the value <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> of the event that signaled the current state
            change for the touch.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.screen">
            <summary>
            The touchscreen on which the touch occurred.
            </summary>
            <value>Touchscreen associated with the touch.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.screenPosition">
            <summary>
            Screen-space position of the touch.
            </summary>
            <value>Screen-space position of the touch.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.position"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.startScreenPosition">
            <summary>
            Screen-space position where the touch started.
            </summary>
            <value>Start position of the touch.</value>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.startPosition"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.delta">
            <summary>
            Screen-space motion delta of the touch.
            </summary>
            <value>Screen-space motion delta of the touch.</value>
            <remarks>
            Note that deltas have behaviors attached to them different from most other
            controls. See <see cref="P:UnityEngine.InputSystem.Pointer.delta"/> for details.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.delta"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.tapCount">
            <summary>
            Number of times that the touch has been tapped in succession.
            </summary>
            <value>Indicates how many taps have been performed one after the other.</value>
            <remarks>
            Successive taps have to come within <see cref="P:UnityEngine.InputSystem.InputSettings.multiTapDelayTime"/> for them
            to increase the tap count. I.e. if a new tap finishes within that time after <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.startTime"/>
            of the previous touch, the tap count is increased by one. If more than <see cref="P:UnityEngine.InputSystem.InputSettings.multiTapDelayTime"/>
            passes after a tap with no successive tap, the tap count is reset to zero.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.tapCount"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.isTap">
             <summary>
             Whether the touch has performed a tap.
             </summary>
             <value>Indicates whether the touch has tapped the screen.</value>
             <remarks>
             A tap is defined as a touch that begins and ends within <see cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/> and
             stays within <see cref="P:UnityEngine.InputSystem.InputSettings.tapRadius"/> of its <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.startScreenPosition"/>. If this
             is the case for a touch, this button is set to 1 at the time the touch goes to <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/>
             <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/>.
            
             Resets to 0 only when another touch is started on the control or when the control is reset.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.tapCount"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>
             <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.tap"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.isInProgress">
            <summary>
            Whether the touch is currently in progress, i.e. has a <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> of
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>, <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>, or <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>.
            </summary>
            <value>Whether the touch is currently ongoing.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.history">
            <summary>
            History for this specific touch.
            </summary>
            <remarks>
            Unlike <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Finger.touchHistory"/>, this gives the history of this touch only.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches">
             <summary>
             All touches that are either on-going as of the current frame or have ended in the current frame.
             </summary>
             <remarks>
             A touch that begins in a frame will always have its phase set to <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/> even
             if there was also movement (or even an end/cancellation) for the touch in the same frame.
            
             A touch that begins and ends in the same frame will have its <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/> surface
             in that frame and then another entry with <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> surface in the
             <em>next</em> frame. This logic implies that there can be more active touches than concurrent touches
             supported by the hardware/platform.
            
             A touch that begins and moves in the same frame will have its <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/> surface
             in that frame and then another entry with <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/> and the screen motion
             surface in the <em>next</em> frame <em>except</em> if the touch also ended in the frame (in which
             case <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.phase"/> will be <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> instead of <see cref="F:UnityEngine.InputSystem.TouchPhase.Moved"/>).
            
             Note that the touches reported by this API do <em>not</em> necessarily have to match the contents of
             <see href="https://docs.unity3d.com/ScriptReference/Input-touches.html">UnityEngine.Input.touches</see>.
             The reason for this is that the <c>UnityEngine.Input</c> API and the Input System API flush their input
             queues at different points in time and may thus have a different view on available input. In particular,
             the Input System event queue is flushed <em>later</em> in the frame than inputs for <c>UnityEngine.Input</c>
             and may thus have newer inputs available. On Android, for example, touch input is gathered from a separate
             UI thread and fed into the input system via a "background" event queue that can gather input asynchronously.
             Due to this setup, touch events that will reach <c>UnityEngine.Input</c> only in the next frame may have
             already reached the Input System.
            
             <example>
             <code>
             void Awake()
             {
                 // Enable EnhancedTouch.
                 EnhancedTouchSupport.Enable();
             }
            
             void Update()
             {
                 foreach (var touch in Touch.activeTouches)
                     if (touch.began)
                         Debug.Log($"Touch {touch} started this frame");
                     else if (touch.ended)
                         Debug.Log($"Touch {touch} ended this frame");
             }
             </code>
             </example>
             </remarks>
             <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
             <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeFingers"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.fingers">
             <summary>
             An array of all possible concurrent touch contacts, i.e. all concurrent touch contacts regardless of whether
             they are currently active or not.
             </summary>
             <remarks>
             For querying only active fingers, use <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeFingers"/>.
            
             The length of this array will always correspond to the maximum number of concurrent touches supported by the system.
             Note that the actual number of physically supported concurrent touches as determined by the current hardware and
             operating system may be lower than this number.
             </remarks>
             <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
             <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches"/>
             <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeFingers"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeFingers">
            <summary>
            Set of currently active fingers, i.e. touch contacts that currently have an active touch (as defined by <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches"/>
            <seealso cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.fingers"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.screens">
            <summary>
            Return the set of <see cref="T:UnityEngine.InputSystem.Touchscreen"/>s on which touch input is monitored.
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
        </member>
        <member name="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerDown">
            <summary>
            Event that is invoked when a finger touches a <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerUp"/>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerMove"/>
        </member>
        <member name="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerUp">
            <summary>
            Event that is invoked when a finger stops touching a <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerDown"/>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerMove"/>
        </member>
        <member name="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerMove">
            <summary>
            Event that is invoked when a finger that is in contact with a <see cref="T:UnityEngine.InputSystem.Touchscreen"/> moves
            on the screen.
            </summary>
            <exception cref="T:System.InvalidOperationException"><c>EnhancedTouch</c> has not been enabled via <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.</exception>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerUp"/>
            <seealso cref="E:UnityEngine.InputSystem.EnhancedTouch.Touch.onFingerDown"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Touch.maxHistoryLengthPerFinger">
            <summary>
            The amount of history kept for each single touch.
            </summary>
            <remarks>
            By default, this is zero meaning that no history information is kept for
            touches. Setting this to <c>Int32.maxValue</c> will cause all history from
            the beginning to the end of a touch being kept.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.Touch.GlobalState">
            <summary>
            Holds global (static) touch state.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport">
             <summary>
             API to control enhanced touch facilities like <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/> that are not
             enabled by default.
             </summary>
             <remarks>
             Enhanced touch support provides automatic finger tracking and touch history recording.
             It is an API designed for polling, i.e. for querying touch state directly in methods
             such as <c>MonoBehaviour.Update</c>. Enhanced touch support cannot be used in combination
             with <see cref="T:UnityEngine.InputSystem.InputAction"/>s though both can be used side-by-side.
            
             <example>
             <code>
             public class MyBehavior : MonoBehaviour
             {
                 protected void OnEnable()
                 {
                     EnhancedTouchSupport.Enable();
                 }
            
                 protected void OnDisable()
                 {
                     EnhancedTouchSupport.Disable();
                 }
            
                 protected void Update()
                 {
                     var activeTouches = Touch.activeTouches;
                     for (var i = 0; i &lt; activeTouches.Count; ++i)
                         Debug.Log("Active touch: " + activeTouches[i]);
                 }
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/>
             <seealso cref="T:UnityEngine.InputSystem.EnhancedTouch.Finger"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.enabled">
            <summary>
            Whether enhanced touch support is currently enabled.
            </summary>
            <value>True if EnhancedTouch support has been enabled.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable">
             <summary>
             Enable enhanced touch support.
             </summary>
             <remarks>
             Calling this method is necessary to enable the functionality provided
             by <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/> and <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Finger"/>. These APIs add extra
             processing to touches and are thus disabled by default.
            
             Calls to <c>Enable</c> and <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Disable"/> balance each other out.
             If <c>Enable</c> is called repeatedly, it will take as many calls to
             <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Disable"/> to disable the system again.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Disable">
            <summary>
            Disable enhanced touch support.
            </summary>
            <remarks>
            This method only undoes a single call to <see cref="M:UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.TouchHistory">
            <summary>
            A fixed-size buffer of <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/> records used to trace the history of touches.
            </summary>
            <remarks>
            This struct provides access to a recorded list of touches.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.EnhancedTouch.TouchHistory.GetEnumerator">
            <summary>
            Enumerate touches in the history. Goes from newest records to oldest.
            </summary>
            <returns>Enumerator over the touches in the history.</returns>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.TouchHistory.Count">
            <summary>
            Number of history records available.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.TouchHistory.Item(System.Int32)">
            <summary>
            Return a history record by index. Indexing starts at 0 == newest to <see cref="P:UnityEngine.InputSystem.EnhancedTouch.TouchHistory.Count"/> - 1 == oldest.
            </summary>
            <param name="index">Index of history record.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0 or >= <see cref="P:UnityEngine.InputSystem.EnhancedTouch.TouchHistory.Count"/>.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.TouchSimulation">
            <summary>
            Adds a <see cref="T:UnityEngine.InputSystem.Touchscreen"/> with input simulated from other types of <see cref="T:UnityEngine.InputSystem.Pointer"/> devices (e.g. <see cref="T:UnityEngine.InputSystem.Mouse"/>
            or <see cref="T:UnityEngine.InputSystem.Pen"/>).
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.EnhancedTouch.Finger">
             <summary>
             A source of touches (<see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/>).
             </summary>
             <remarks>
             Each <see cref="T:UnityEngine.InputSystem.Touchscreen"/> has a limited number of fingers it supports corresponding to the total number of concurrent
             touches supported by the screen. Unlike a <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/>, a <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Finger"/> will stay the same and valid for the
             lifetime of its <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
            
             Note that a Finger does not represent an actual physical finger in the world. That is, the same Finger instance might be used,
             for example, for a touch from the index finger at one point and then for a touch from the ring finger. Each Finger simply
             corresponds to the Nth touch on the given screen.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.screen">
            <summary>
            The screen that the finger is associated with.
            </summary>
            <value>Touchscreen associated with the touch.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.index">
            <summary>
            Index of the finger on <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Finger.screen"/>. Each finger corresponds to the Nth touch on a screen.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.isActive">
            <summary>
            Whether the finger is currently touching the screen.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.screenPosition">
            <summary>
            The current position of the finger on the screen or <c>default(Vector2)</c> if there is no
            ongoing touch.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.lastTouch">
            <summary>
            The last touch that happened on the finger or <c>default(Touch)</c> (with <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.valid"/> being
            false) if no touch has been registered on the finger yet.
            </summary>
            <remarks>
            A given touch will be returned from this property for as long as no new touch has been started. As soon as a
            new touch is registered on the finger, the property switches to the new touch.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.currentTouch">
            <summary>
            The currently ongoing touch for the finger or <c>default(Touch)</c> (with <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.valid"/> being false)
            if no touch is currently in progress on the finger.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.EnhancedTouch.Finger.touchHistory">
            <summary>
            The full touch history of the finger.
            </summary>
            <remarks>
            The history is capped at <see cref="P:UnityEngine.InputSystem.EnhancedTouch.Touch.maxHistoryLengthPerFinger"/>. Once full, newer touch records will start
            overwriting older entries. Note that this means that a given touch will not trace all the way back to its beginning
            if it runs past the max history size.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerInputManager">
             <summary>
             Manages joining and leaving of players.
             </summary>
             <remarks>
             This is a singleton component. Only one instance is meant to be active in a game
             at any one time. To retrieve the current instance, use <see cref="P:UnityEngine.InputSystem.PlayerInputManager.instance"/>.
            
             Note that a PlayerInputManager is not strictly required to have multiple <see cref="T:UnityEngine.InputSystem.PlayerInput"/> components.
             What PlayerInputManager provides is the implementation of specific player join mechanisms
             (<see cref="P:UnityEngine.InputSystem.PlayerInputManager.joinBehavior"/>) as well as automatic assignment of split-screen areas (<see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/>).
             However, you can always implement your own custom logic instead and simply instantiate multiple GameObjects with
             <see cref="T:UnityEngine.InputSystem.PlayerInput"/> yourself.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerInputManager.PlayerJoinedMessage">
            <summary>
            Name of the message that is sent when a player joins the game.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen">
             <summary>
             If enabled, each player will automatically be assigned a portion of the available screen area.
             </summary>
             <remarks>
             For this to work, each <see cref="T:UnityEngine.InputSystem.PlayerInput"/> component must have an associated <see cref="T:UnityEngine.Camera"/>
             object through <see cref="P:UnityEngine.InputSystem.PlayerInput.camera"/>.
            
             Note that as player join, the screen may be increasingly subdivided and players may see their
             previous screen area getting resized.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.maintainAspectRatioInSplitScreen">
             <summary>
             If <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/> is enabled, this property determines whether subdividing the screen is allowed to
             produce screen areas that have an aspect ratio different from the screen resolution.
             </summary>
             <remarks>
             By default, when <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/> is enabled, the manager will add or remove screen subdivisions in
             steps of two. This means that when, for example, the second player is added, the screen will be subdivided into
             a left and a right screen area; the left one allocated to the first player and the right one allocated to the
             second player.
            
             This behavior makes optimal use of screen real estate but will result in screen areas that have aspect ratios
             different from the screen resolution. If this is not acceptable, this property can be set to true to enforce
             split-screen to only create screen areas that have the same aspect ratio of the screen.
            
             This results in the screen being subdivided more aggressively. When, for example, a second player is added,
             the screen will immediately be divided into a four-way split-screen setup with the lower two screen areas
             not being used.
            
             This property is irrelevant if <see cref="P:UnityEngine.InputSystem.PlayerInputManager.fixedNumberOfSplitScreens"/> is used.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.fixedNumberOfSplitScreens">
             <summary>
             If <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/> is enabled, this property determines how many screen divisions there will be.
             </summary>
             <remarks>
             This is only used if <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/> is true.
            
             By default this is set to -1 which means the screen will automatically be divided to best fit the
             current number of players i.e. the highest player index in <see cref="T:UnityEngine.InputSystem.PlayerInput"/>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.splitScreenArea">
             <summary>
             The normalized screen rectangle available for allocating player split-screens into.
             </summary>
             <remarks>
             This is only used if <see cref="P:UnityEngine.InputSystem.PlayerInputManager.splitScreen"/> is true.
            
             By default it is set to <c>(0,0,1,1)</c>, i.e. the entire screen area will be used for player screens.
             If, for example, part of the screen should display a UI/information shared by all players, this
             property can be used to cut off the area and not have it used by PlayerInputManager.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.playerCount">
            <summary>
            The current number of active players.
            </summary>
            <remarks>
            This count corresponds to all <see cref="T:UnityEngine.InputSystem.PlayerInput"/> instances that are currently enabled.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.maxPlayerCount">
             <summary>
             Maximum number of players allowed concurrently in the game.
             </summary>
             <remarks>
             If this limit is reached, joining is turned off automatically.
            
             By default this is set to -1. Any negative value deactivates the player limit and allows
             arbitrary many players to join.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled">
            <summary>
            Whether new players can currently join.
            </summary>
            <remarks>
            While this is true, new players can join via the mechanism determined by <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joinBehavior"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInputManager.EnableJoining"/>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInputManager.DisableJoining"/>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.joinBehavior">
            <summary>
            Determines the mechanism by which players can join when joining is enabled (<see cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>).
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.joinAction">
             <summary>
             The input action that a player must trigger to join the game.
             </summary>
             <remarks>
             If the join action is a reference to an existing input action, it will be cloned when the PlayerInputManager
             is enabled. This avoids the situation where the join action can become disabled after the first user joins which
             can happen when the join action is the same as a player in-game action. When a player joins, input bindings from
             devices other than the device they joined with are disabled. If the join action had a binding for keyboard and one
             for gamepad for example, and the first player joined using the keyboard, the expectation is that the next player
             could still join by pressing the gamepad join button. Without the cloning behavior, the gamepad input would have
             been disabled.
            
             For more details about joining behavior, see <see cref="T:UnityEngine.InputSystem.PlayerInput"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.playerPrefab">
            <summary>
            Reference to the prefab that the manager will instantiate when players join.
            </summary>
            <value>Prefab to instantiate for new players.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.PlayerInputManager.instance">
            <summary>
            Singleton instance of the manager.
            </summary>
            <value>Singleton instance or null.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.EnableJoining">
            <summary>
            Allow players to join the game based on <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joinBehavior"/>.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInputManager.DisableJoining"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.DisableJoining">
            <summary>
            Inhibit players from joining the game.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.PlayerInputManager.EnableJoining"/>
            <seealso cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayerFromUI">
            <summary>
            Join a new player based on input on a UI element.
            </summary>
            <remarks>
            This should be called directly from a UI callback such as <see cref="!:Button.onClick"/>. The device
            that the player joins with is taken from the device that was used to interact with the UI element.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayerFromAction(UnityEngine.InputSystem.InputAction.CallbackContext)">
            <summary>
            Join a new player based on input received through an <see cref="T:UnityEngine.InputSystem.InputAction"/>.
            </summary>
            <param name="context"></param>
            <remarks>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayer(System.Int32,System.Int32,System.String,UnityEngine.InputSystem.InputDevice)">
             <summary>
             Spawn a new player from <see cref="P:UnityEngine.InputSystem.PlayerInputManager.playerPrefab"/>.
             </summary>
             <param name="playerIndex">Optional explicit <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/> to assign to the player. Must be unique within
             <see cref="P:UnityEngine.InputSystem.PlayerInput.all"/>. If not supplied, a player index will be assigned automatically (smallest unused index will be used).</param>
             <param name="splitScreenIndex">Optional <see cref="P:UnityEngine.InputSystem.PlayerInput.splitScreenIndex"/>. If supplied, this assigns a split-screen area to the player. For example,
             a split-screen index of </param>
             <param name="controlScheme">Control scheme to activate on the player (optional). If not supplied, a control scheme will
             be selected based on <paramref name="pairWithDevice"/>. If no device is given either, the first control scheme that matches
             the currently available unpaired devices (see <see cref="M:UnityEngine.InputSystem.Users.InputUser.GetUnpairedInputDevices"/>) is used.</param>
             <param name="pairWithDevice">Device to pair to the player. Also determines which control scheme to use if <paramref name="controlScheme"/>
             is not given.</param>
             <returns>The newly instantiated player or <c>null</c> if joining failed.</returns>
             <remarks>
             Joining must be enabled (see <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>) or the method will fail.
            
             To pair multiple devices, use <see cref="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayer(System.Int32,System.Int32,System.String,UnityEngine.InputSystem.InputDevice[])"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.JoinPlayer(System.Int32,System.Int32,System.String,UnityEngine.InputSystem.InputDevice[])">
            <summary>
            Spawn a new player from <see cref="P:UnityEngine.InputSystem.PlayerInputManager.playerPrefab"/>.
            </summary>
            <param name="playerIndex">Optional explicit <see cref="P:UnityEngine.InputSystem.PlayerInput.playerIndex"/> to assign to the player. Must be unique within
            <see cref="P:UnityEngine.InputSystem.PlayerInput.all"/>. If not supplied, a player index will be assigned automatically (smallest unused index will be used).</param>
            <param name="splitScreenIndex">Optional <see cref="P:UnityEngine.InputSystem.PlayerInput.splitScreenIndex"/>. If supplied, this assigns a split-screen area to the player. For example,
            a split-screen index of </param>
            <param name="controlScheme">Control scheme to activate on the player (optional). If not supplied, a control scheme will
            be selected based on <paramref name="pairWithDevices"/>. If no device is given either, the first control scheme that matches
            the currently available unpaired devices (see <see cref="M:UnityEngine.InputSystem.Users.InputUser.GetUnpairedInputDevices"/>) is used.</param>
            <param name="pairWithDevices">Devices to pair to the player. Also determines which control scheme to use if <paramref name="controlScheme"/>
            is not given.</param>
            <returns>The newly instantiated player or <c>null</c> if joining failed.</returns>
            <remarks>
            Joining must be enabled (see <see cref="P:UnityEngine.InputSystem.PlayerInputManager.joiningEnabled"/>) or the method will fail.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.UpdateSplitScreen">
            <summary>
            If split-screen is enabled, then for each player in the game, adjust the player's <see cref="P:UnityEngine.Camera.rect"/>
            to fit the player's split screen area according to the number of players currently in the game and the
            current split-screen configuration.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.NotifyPlayerJoined(UnityEngine.InputSystem.PlayerInput)">
            <summary>
            Called by <see cref="T:UnityEngine.InputSystem.PlayerInput"/> when it is enabled.
            </summary>
            <param name="player"></param>
        </member>
        <member name="M:UnityEngine.InputSystem.PlayerInputManager.NotifyPlayerLeft(UnityEngine.InputSystem.PlayerInput)">
            <summary>
            Called by <see cref="T:UnityEngine.InputSystem.PlayerInput"/> when it is disabled.
            </summary>
            <param name="player"></param>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUserPairingOptions">
            <summary>
            Options to modify the behavior on <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserPairingOptions.None">
            <summary>
            Default behavior.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserPairingOptions.ForcePlatformUserAccountSelection">
             <summary>
             Even if the device is already paired to a user account at the platform level, force the user to select
             an account.
             </summary>
             <remarks>
             This is only supported on Xbox and Switch, at the moment.
            
             On PS4, this is ignored as account pairing is under system control. If the user wants to switch accounts,
             he/she does so by pressing the PS4 button on the controller.
            
             On Xbox, this option will bring up the account picker even if the device is already paired to a user.
             This behavior is useful to allow the player to change accounts.
            
             On platforms other than Xbox and Switch, this option is ignored.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserPairingOptions.ForceNoPlatformUserAccountSelection">
             <summary>
             Suppress user account selection when supported at the platform level and a device is not currently paired
             to a user account.
             </summary>
             <remarks>
             On Xbox, if a device that does not currently have a user account logged in on it is paired to an
             <see cref="T:UnityEngine.InputSystem.Users.InputUser"/>, no account picker will come up and the device will be used without an associated
             user account.
            
             On Switch, this prevents the user management applet from coming up.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserPairingOptions.UnpairCurrentDevicesFromUser">
            <summary>
            If the user already has paired devices, unpair them first.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUserSettings">
             <summary>
             A user profile may alter select aspects of input behavior at runtime.
             </summary>
             <remarks>
             This class implements several user adjustable input behaviors commonly found in games, such
             as mouse sensitivity and axis inversion.
            
             Note that the behaviors only work in combination with actions, that is, for users that have
             actions associated with them via <see cref="M:UnityEngine.InputSystem.Users.InputUser.AssociateActionsWithUser(UnityEngine.InputSystem.IInputActionCollection)"/>.
             The behaviors do not alter the input as present directly on the devices. Meaning that, for example,
             <see cref="P:UnityEngine.InputSystem.Users.InputUserSettings.invertMouseX"/> will not impact <see cref="F:UnityEngine.Vector2.x"/> of <see cref="!:Mouse.delta"/> but will
             rather impact the value read out with <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/> from an action
             bound to mouse deltas.
            
             In other words, all the input behaviors operate at the binding level and modify <see cref="T:UnityEngine.InputSystem.InputBinding"/>s.
             ////REVIEW: does this really make sense?
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.customBindings">
            <summary>
            Customized bindings for the user.
            </summary>
            <remarks>
            This will only contain customizations explicitly applied to the user's bindings
            and will not contain default bindings. It is thus not a complete set of bindings
            but rather just a set of customizations.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.invertMouseX">
            <summary>
            Invert X on <see cref="!:Mouse.position"/>  and <see cref="!:Mouse.delta"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.invertMouseY">
            <summary>
            Invert Y on <see cref="!:Mouse.position"/>  and <see cref="!:Mouse.delta"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.mouseSmoothing">
            <summary>
            Smooth mouse motion on both X and Y ...
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.invertStickX">
            <summary>
            Invert X axis on <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.invertStickY">
            <summary>
            Invert Y axis on <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.swapSticks">
            <summary>
            If true, swap sides
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.swapBumpers">
            <summary>
            Swap <see cref="P:UnityEngine.InputSystem.Gamepad.leftShoulder"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightShoulder"/> on gamepads.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserSettings.swapTriggers">
            <summary>
            Swap <see cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightTrigger"/> on gamepads.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUserChange">
            <summary>
            Indicates what type of change related to an <see cref="T:UnityEngine.InputSystem.Users.InputUser"/> occurred.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.Added">
            <summary>
            A new user was added to the system.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.Removed">
            <summary>
            An existing user was removed from the user.
            </summary>
            <remarks>
            <see cref="T:UnityEngine.InputSystem.Users.InputUser"/>s are only removed when explicitly requested (<see cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>).
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.DevicePaired">
            <summary>
            A user has had a device assigned to it.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired">
            <summary>
            A user has had a device removed from it.
            </summary>
            <remarks>
            This is different from <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/> in that the removal is intentional. <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/>
            instead indicates that the device was removed due to causes outside of the control of the application (such
            as battery loss) whereas DeviceUnpaired indicates the device was removed from the user under the control of
            the application itself.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost">
             <summary>
             A device was removed while paired to the user.
             </summary>
             <remarks>
             This scenario happens on battery loss, for example.
            
             Note that there is still a <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DevicePaired"/> change sent when the device is subsequently removed
             from the user.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.lostDevices"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceRegained">
             <summary>
             A device that was previously lost (<see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/>) was regained by the user.
             </summary>
             <remarks>
             This can happen, for example, when a gamepad runs out of battery and is then plugged in by wire.
            
             Note that a device may be permanently lost and instead be replaced by a different device.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.lostDevices"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.ControlSchemeChanged">
            <summary>
            A user switched to a different control scheme.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(UnityEngine.InputSystem.InputControlScheme)"/>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUserChange.ControlsChanged">
            <summary>
            A user's bound controls have changed, either because the bindings of the user have changed (for example,
            due to an override applied with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>)
            or because the controls themselves may have changed configuration (every time the device of the controls receives
            an <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/>; for example, when the current keyboard layout on a <see cref="T:UnityEngine.InputSystem.Keyboard"/>
            changes which in turn modifies the <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/>s of the keys on the keyboard).
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUser">
             <summary>
             Represents a specific user/player interacting with one or more devices and input actions.
             </summary>
             <remarks>
             Principally, an InputUser represents a human interacting with the application. Moreover, at any point
             each InputUser represents a human actor distinct from all other InputUsers in the system.
            
             Each user has one or more paired devices. In general, these devices are unique to each user. However,
             it is permitted to use <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/> to pair the same device to multiple users.
             This can be useful in setups such as split-keyboard (e.g. one user using left side of keyboard and the
             other the right one) use or hotseat-style gameplay (e.g. two players taking turns on the same game controller).
            
             Note that the InputUser API, like <see cref="T:UnityEngine.InputSystem.InputAction"/>) is a play mode-only feature. When exiting play mode,
             all users are automatically removed and all devices automatically unpaired.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Users.InputUserChange"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.valid">
            <summary>
            Whether this is a currently active user record in <see cref="P:UnityEngine.InputSystem.Users.InputUser.all"/>.
            </summary>
            <remarks>
            Users that are removed (<see cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>) will become invalid.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
            <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.Removed"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.index">
             <summary>
             The sequence number of the user.
             </summary>
             <remarks>
             It can be useful to establish a sorting of players locally such that it is
             known who is the first player, who is the second, and so on. This property
             gives the positioning of the user within <see cref="P:UnityEngine.InputSystem.Users.InputUser.all"/>.
            
             Note that the index of a user may change as users are added and removed.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.all"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.id">
             <summary>
             The unique numeric ID of the user.
             </summary>
             <remarks>
             The ID of a user is internally assigned and cannot be changed over its lifetime. No two users, even
             if not concurrently active, will receive the same ID.
            
             The ID stays valid and unique even if the user is removed and no longer <see cref="P:UnityEngine.InputSystem.Users.InputUser.valid"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices">
             <summary>
             Devices assigned/paired/linked to the user.
             </summary>
             <remarks>
             It is generally valid for a device to be assigned to multiple users. For example, two users could
             both use the local keyboard in a split-keyboard or hot seat setup. However, a platform may restrict this
             and mandate that a device never belong to more than one user. This is the case on Xbox and PS4, for
             example.
            
             To associate devices with users, use <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>. To remove devices, use
             <see cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/> or <see cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>.
            
             The array will be empty for a user who is currently not paired to any devices.
            
             If <see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/> is set (<see cref="M:UnityEngine.InputSystem.Users.InputUser.AssociateActionsWithUser(UnityEngine.InputSystem.IInputActionCollection)"/>), then
             <see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/> will be kept synchronized with the devices paired to the user.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DevicePaired"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.lostDevices">
             <summary>
             Devices that were removed while they were still paired to the user.
             </summary>
             <remarks>
            
             This list is cleared once the user has either regained lost devices or has regained other devices
             such that the <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/> is satisfied.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceRegained"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceLost"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.actions">
             <summary>
             Actions associated with the user.
             </summary>
             <remarks>
             Associating actions with a user will synchronize the actions with the devices paired to the
             user. Also, it makes it possible to use support for control scheme activation (<see
             cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(UnityEngine.InputSystem.InputControlScheme)"/> and related APIs like <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/>
             and <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlSchemeMatch"/>).
            
             Note that is generally does not make sense for users to share actions. Instead, each user should
             receive a set of actions private to the user.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.AssociateActionsWithUser(UnityEngine.InputSystem.IInputActionCollection)"/>
             <seealso cref="T:UnityEngine.InputSystem.InputActionMap"/>
             <seealso cref="T:UnityEngine.InputSystem.InputActionAsset"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.ControlsChanged"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.controlScheme">
             <summary>
             The control scheme currently employed by the user.
             </summary>
             <remarks>
             This is null by default.
            
             Any time the value of this property changes (whether by <see cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(System.String)"/>
             or by automatic switching), a notification is sent on <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/> with
             <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.ControlSchemeChanged"/>.
            
             Be aware that using control schemes with InputUsers requires <see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/> to
             be set, i.e. input actions to be associated with the user (<see
             cref="M:UnityEngine.InputSystem.Users.InputUser.AssociateActionsWithUser(UnityEngine.InputSystem.IInputActionCollection)"/>).
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.ActivateControlScheme(UnityEngine.InputSystem.InputControlScheme)"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.ControlSchemeChanged"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.controlSchemeMatch">
            <summary>
            The result of matching the device requirements given by <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/> against
            the devices paired to the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>).
            </summary>
            <remarks>
            When devices are paired to or unpaired from a user, as well as when a new control scheme is
            activated on a user, this property is updated automatically.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControlScheme.PickDevicesFrom``1(``0,UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.hasMissingRequiredDevices">
            <summary>
            Whether the user is missing devices required by the <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/> activated
            on the user.
            </summary>
            <remarks>
            This will only take required devices into account. Device requirements marked optional (<see
            cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>) will not be considered missing
            devices if they cannot be satisfied based on the devices paired to the user.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.all">
             <summary>
             List of all current users.
             </summary>
             <remarks>
             Use <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/> to add new users and <see cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/> to
             remove users.
            
             Note that this array does not necessarily correspond to the list of users present at the platform level
             (e.g. Xbox and PS4). There can be users present at the platform level that are not present in this array
             (e.g. because they are not joined to the game) and users can even be present more than once (e.g. if
             playing on the user account but as two different players in the game). Also, there can be users in the array
             that are not present at the platform level.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
        </member>
        <member name="E:UnityEngine.InputSystem.Users.InputUser.onChange">
            <summary>
            Event that is triggered when the <see cref="T:UnityEngine.InputSystem.Users.InputUser">user</see> setup in the system
            changes.
            </summary>
            <remarks>
            Each notification receives the user that was affected by the change and, in the form of <see cref="T:UnityEngine.InputSystem.Users.InputUserChange"/>,
            a description of what has changed about the user. The third parameter may be null but if the change will be related
            to an input device, will reference the device involved in the change.
            </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed">
             <summary>
             Event that is triggered when a device is used that is not currently paired to any user.
             </summary>
             <remarks>
             A device is considered "used" when it has magnitude (<see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) greater than zero
             on a control that is not noisy (<see cref="P:UnityEngine.InputSystem.InputControl.noisy"/>) and not synthetic (i.e. not a control that is
             "made up" like <see cref="P:UnityEngine.InputSystem.Keyboard.anyKey"/>; <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>).
            
             Detecting the use of unpaired devices has a non-zero cost. While multiple levels of tests are applied to try to
             cheaply ignore devices that have events sent to them that do not contain user activity, finding out whether
             a device had real user activity will eventually require going through the device control by control.
            
             To enable detection of the use of unpaired devices, set <see cref="P:UnityEngine.InputSystem.Users.InputUser.listenForUnpairedDeviceActivity"/> to true.
             It is disabled by default.
            
             The callback is invoked for each non-leaf, non-synthetic, non-noisy control that has been actuated on the device.
             It being restricted to non-leaf controls means that if, say, the stick on a gamepad is actuated in both X and Y
             direction, you will see two calls: one with stick/x and one with stick/y.
            
             The reason that the callback is invoked for each individual control is that pairing often relies on checking
             for specific kinds of interactions. For example, a pairing callback may listen exclusively for button presses.
            
             Note that whether the use of unpaired devices leads to them getting paired is under the control of the application.
             If the device should be paired, invoke <see cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/> from the callback. If you do so,
             no further callbacks will get triggered for other controls that may have been actuated in the same event.
            
             Be aware that the callback is fired <em>before</em> input is actually incorporated into the device (it is
             indirectly triggered from <see cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>). This means at the time the callback is run,
             the state of the given device does not yet have the input that triggered the callback. For this reason, the
             callback receives a second argument that references the event from which the use of an unpaired device was
             detected.
            
             What this sequence allows is to make changes to the system before the input is processed. For example, an
             action that is enabled as part of the callback will subsequently respond to the input that triggered the
             callback.
            
             <example>
             <code>
             // Activate support for listening to device activity.
             ++InputUser.listenForUnpairedDeviceActivity;
            
             // When a button on an unpaired device is pressed, pair the device to a new
             // or existing user.
             InputUser.onUnpairedDeviceUsed +=
                 usedControl =>
                 {
                     // Only react to button presses on unpaired devices.
                     if (!(usedControl is ButtonControl))
                         return;
            
                     // Pair the device to a user.
                     InputUser.PerformPairingWithDevice(usedControl.device);
                 };
             </code>
             </example>
            
             Another possible use of the callback is for implementing automatic control scheme switching for a user such that
             the user can, for example, switch from keyboard&amp;mouse to gamepad seamlessly by simply picking up the gamepad
             and starting to play.
             </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.Users.InputUser.onPrefilterUnpairedDeviceActivity">
             <summary>
             Callback that works in combination with <see cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/>. If all callbacks
             added to this event return <c>false</c> for a
             </summary>
             <remarks>
             Checking a given event for activity of interest is relatively fast but is still costlier than
             not doing it all. In case only certain devices are of interest for <see cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/>,
             this "pre-filter" can be used to quickly reject entire devices and thus skip looking closer at
             an event.
            
             The first argument is the <see cref="T:UnityEngine.InputSystem.InputDevice"/> than an event has been received for.
             The second argument is the <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> that is being looked at.
            
             A callback should return <c>true</c> if it wants <see cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/> to proceed
             looking at the event and should return <c>false</c> if the event should be skipped.
            
             If multiple callbacks are added to the event, it is enough for any single one callback
             to return <c>true</c> for the event to get looked at.
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.listenForUnpairedDeviceActivity"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUser.listenForUnpairedDeviceActivity">
             <summary>
             Whether to listen for user activity on currently unpaired devices and invoke <see cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/>
             if such activity is detected.
             </summary>
             <remarks>
             This is off by default.
            
             Note that enabling this has a non-zero cost. Whenever the state changes of a device that is not currently paired
             to a user, the system has to spend time figuring out whether there was a meaningful change or whether it's just
             noise on the device.
            
             This is an integer rather than a bool to allow multiple systems to concurrently use to listen for unpaired
             device activity without treading on each other when enabling/disabling the code path.
             </remarks>
             <seealso cref="E:UnityEngine.InputSystem.Users.InputUser.onUnpairedDeviceUsed"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.AssociateActionsWithUser(UnityEngine.InputSystem.IInputActionCollection)">
             <summary>
             Associate a collection of <see cref="T:UnityEngine.InputSystem.InputAction"/>s with the user.
             </summary>
             <param name="actions">Actions to associate with the user, either an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>
             or an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>. Can be <c>null</c> to unset the current association.</param>
             <exception cref="T:System.InvalidOperationException">The user instance is invalid.</exception>
             <remarks>
             Associating actions with a user will ensure that the <see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/> and
             <see cref="P:UnityEngine.InputSystem.IInputActionCollection.bindingMask"/> property of the action collection are automatically
             kept in sync with the device paired to the user (see <see cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>) and the control
             scheme active on the user (see <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/>).
            
             <example>
             <code>
             var gamepad = Gamepad.all[0];
            
             // Pair the gamepad to a user.
             var user = InputUser.PerformPairingWithDevice(gamepad);
            
             // Create an action map with an action.
             var actionMap = new InputActionMap():
             actionMap.AddAction("Fire", binding: "&lt;Gamepad&gt;/buttonSouth");
            
             // Associate the action map with the user (the same works for an asset).
             user.AssociateActionsWithUser(actionMap);
            
             // Now the action map is restricted to just the gamepad that is paired
             // with the user, even if there are more gamepads currently connected.
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Unpair a single device from the user.
             </summary>
             <param name="device">Device to unpair from the user. If the device is not currently paired to the user,
             the method does nothing.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <remarks>
             If actions are associated with the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>), the list of devices used by the
             actions (<see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/>) is automatically updated.
            
             If a control scheme is activated on the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/>), <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlSchemeMatch"/>
             is automatically updated.
            
             Sends <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/> through <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevices">
             <summary>
             Unpair all devices from the user.
             </summary>
             <remarks>
             If actions are associated with the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>), the list of devices used by the
             actions (<see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/>) is automatically updated.
            
             If a control scheme is activated on the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/>), <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlSchemeMatch"/>
             is automatically updated.
            
             Sends <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/> through <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/> for every device
             unpaired from the user.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser">
             <summary>
             Unpair all devices from the user and remove the user.
             </summary>
             <remarks>
             If actions are associated with the user (<see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>), the list of devices used by the
             actions (<see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/>) is reset as is the binding mask (<see
             cref="P:UnityEngine.InputSystem.IInputActionCollection.bindingMask"/>) in case a control scheme is activated on the user.
            
             Sends <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/> through <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/> for every device
             unpaired from the user.
            
             Sends <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.Removed"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DeviceUnpaired"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.Removed"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.GetUnpairedInputDevices">
            <summary>
            Return a list of all currently added devices that are not paired to any user.
            </summary>
            <returns>A (possibly empty) list of devices that are currently not paired to a user.</returns>
            <remarks>
            The resulting list uses <see cref="F:Unity.Collections.Allocator.Temp"> temporary, unmanaged memory</see>. If not disposed of
            explicitly, the list will automatically be deallocated at the end of the frame and will become unusable.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.GetUnpairedInputDevices(UnityEngine.InputSystem.InputControlList{UnityEngine.InputSystem.InputDevice}@)">
            <summary>
            Add all currently added devices that are not paired to any user to <paramref name="list"/>.
            </summary>
            <param name="list">List to add the devices to. Devices will be added to the end.</param>
            <returns>Number of devices added to <paramref name="list"/>.</returns>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
            <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
            <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.FindUserPairedToDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Find the user (if any) that <paramref name="device"/> is currently paired to.
             </summary>
             <param name="device">An input device.</param>
             <returns>The user that <paramref name="device"/> is currently paired to or <c>null</c> if the device
             is not currently paired to an user.</returns>
             <remarks>
             Note that multiple users may be paired to the same device. If that is the case for <paramref name="device"/>,
             the method will return one of the users with no guarantee which one it is.
            
             To find all users paired to a device requires manually going through the list of users and their paired
             devices.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.PerformPairingWithDevice(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.Users.InputUser,UnityEngine.InputSystem.Users.InputUserPairingOptions)">
             <summary>
             Pair the given device to a user.
             </summary>
             <param name="device">Device to pair to a user.</param>
             <param name="user">Optional parameter. If given, instead of creating a new user to pair the device
             to, the device is paired to the given user.</param>
             <param name="options">Optional set of options to modify pairing behavior.</param>
             <remarks>
             By default, a new user is created and <paramref name="device"/> is added <see cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             of the user and <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.DevicePaired"/> is sent on <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/>.
            
             If a valid user is supplied to <paramref name="user"/>, the device is paired to the given user instead
             of creating a new user. By default, the device is added to the list of already paired devices for the user.
             This can be changed by using <see cref="F:UnityEngine.InputSystem.Users.InputUserPairingOptions.UnpairCurrentDevicesFromUser"/> which causes
             devices currently paired to the user to first be unpaired.
            
             The method will not prevent pairing of the same device to multiple users.
            
             Note that if the user has an associated set of actions (<see cref="P:UnityEngine.InputSystem.Users.InputUser.actions"/>), the list of devices on the
             actions (<see cref="P:UnityEngine.InputSystem.IInputActionCollection.devices"/>) will automatically be updated meaning that the newly
             paired devices will automatically reflect in the set of devices available to the user's actions. If the
             user has a control scheme that is currently activated (<see cref="P:UnityEngine.InputSystem.Users.InputUser.controlScheme"/>), then <see cref="P:UnityEngine.InputSystem.Users.InputUser.controlSchemeMatch"/>
             will also automatically update to reflect the matching of devices to the control scheme's device requirements.
            
             <example>
             <code>
             // Pair device to new user.
             var user = InputUser.PerformPairingWithDevice(wand1);
            
             // Pair another device to the same user.
             InputUser.PerformPairingWithDevice(wand2, user: user);
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevices"/>
             <seealso cref="M:UnityEngine.InputSystem.Users.InputUser.UnpairDevicesAndRemoveUser"/>
             <seealso cref="F:UnityEngine.InputSystem.Users.InputUserChange.DevicePaired"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.AddUser">
             <summary>
             Add a new user.
             </summary>
             <returns>Index of the newly created user.</returns>
             <remarks>
             Adding a user sends a notification with <see cref="F:UnityEngine.InputSystem.Users.InputUserChange.Added"/> through <see cref="E:UnityEngine.InputSystem.Users.InputUser.onChange"/>.
            
             The user will start out with no devices and no actions assigned.
            
             The user is added to <see cref="P:UnityEngine.InputSystem.Users.InputUser.all"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.RemoveUser(System.Int32)">
            <summary>
            Remove an active user.
            </summary>
            <param name="userIndex">Index of active user.</param>
            <remarks>
            Removing a user also unassigns all currently assigned devices from the user. On completion of this
            method, <see cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/> of <paramref name="user"/> will be empty.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.TryFindUserIndex(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Find the user (if any) that is currently assigned the given <paramref name="device"/>.
            </summary>
            <param name="device">An input device that has been added to the system.</param>
            <returns>Index of the user that has <paramref name="device"/> among its <see cref="P:UnityEngine.InputSystem.Users.InputUser.pairedDevices"/> or -1 if
            no user is currently assigned the given device.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.AddDeviceToUser(System.Int32,UnityEngine.InputSystem.InputDevice,System.Boolean,System.Boolean)">
            <summary>
            Add the given device to the user as either a lost device or a paired device.
            </summary>
            <param name="userIndex"></param>
            <param name="device"></param>
            <param name="asLostDevice"></param>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.InitiateUserAccountSelectionAtPlatformLevel(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Try to initiate user account pairing for the given device at the platform level.
            </summary>
            <param name="device"></param>
            <returns>True if the device accepted the request and an account picker has been raised.</returns>
            <remarks>
            Sends <see cref="T:UnityEngine.InputSystem.LowLevel.InitiateUserAccountPairingCommand"/> to the device.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.OnDeviceChange(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.InputDeviceChange)">
            <summary>
            Invoked in response to <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>.
            </summary>
            <param name="device"></param>
            <param name="change"></param>
            <remarks>
            We monitor the device setup in the system for activity that impacts the user setup.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUser.ControlSchemeChangeSyntax">
            <summary>
            Syntax for configuring a control scheme on a user.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Users.InputUser.ControlSchemeChangeSyntax.AndPairRemainingDevices">
            <summary>
            Leave the user's paired devices in place but pair any available devices
            that are still required by the control scheme.
            </summary>
            <returns></returns>
            <remarks>
            If there are unpaired devices that, at the platform level, are associated with the same
            user account, those will take precedence over other unpaired devices.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserFlags.UserAccountSelectionInProgress">
            <summary>
            Whether we have initiated a user account selection.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUser.UserData">
            <summary>
            Data we store for each user.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.platformUserAccountHandle">
            <summary>
            The platform handle associated with the user.
            </summary>
            <remarks>
            If set, this identifies the user on the platform. It also means that the devices
            assigned to the user may be paired at the platform level.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.platformUserAccountName">
            <summary>
            Plain-text user name as returned by the underlying platform. Null if not associated with user on platform.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.platformUserAccountId">
            <summary>
            Platform-specific ID that identifies the user across sessions even if the user
            name changes.
            </summary>
            <remarks>
            This might not be a human-readable string.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.deviceCount">
            <summary>
            Number of devices in <see cref="!:InputUser.s_AllPairedDevices"/> assigned to the user.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.deviceStartIndex">
            <summary>
            Index in <see cref="!:InputUser.s_AllPairedDevices"/> where the devices for this user start. Only valid
            if <see cref="F:UnityEngine.InputSystem.Users.InputUser.UserData.deviceCount"/> is greater than zero.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.actions">
            <summary>
            Input actions associated with the user.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.controlScheme">
            <summary>
            Currently active control scheme or null if no control scheme has been set on the user.
            </summary>
            <remarks>
            This also dictates the binding mask that we're using with <see cref="F:UnityEngine.InputSystem.Users.InputUser.UserData.actions"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.lostDeviceCount">
            <summary>
            Number of devices in <see cref="!:InputUser.s_AllLostDevices"/> assigned to the user.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Users.InputUser.UserData.lostDeviceStartIndex">
            <summary>
            Index in <see cref="!:InputUser.s_AllLostDevices"/> where the lost devices for this user start. Only valid
            if <see cref="F:UnityEngine.InputSystem.Users.InputUser.UserData.lostDeviceCount"/> is greater than zero.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUser.CompareDevicesByUserAccount">
            <summary>
            Compare two devices for being associated with a specific platform user account.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Users.InputUserAccountHandle">
            <summary>
            Handle for a user account in an external API.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Users.InputUserAccountHandle.apiName">
             <summary>
             Symbolic name of the API that owns the handle.
             </summary>
             <remarks>
             This essentially provides a namespace for <see cref="P:UnityEngine.InputSystem.Users.InputUserAccountHandle.handle"/>.
            
             On PS4, for example, this will read "PS4" for user handles corresponding
             to <c>sceUserId</c>.
            
             This will not be null or empty except if the handle is invalid.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputDeviceBuilder">
             <summary>
             Turns a device layout into an actual <see cref="T:UnityEngine.InputSystem.InputDevice"/> instance.
             </summary>
             <remarks>
             Ultimately produces a device but can also be used to query the control setup described
             by a layout.
            
             Can be used both to create control hierarchies from scratch as well as to re-create or
             change existing hierarchies.
            
             InputDeviceBuilder is the only way to create control hierarchies. InputControls cannot be
             <c>new</c>'d directly.
            
             Also computes a final state layout when setup is finished.
            
             Note that InputDeviceBuilders generate garbage. They are meant to be used for initialization only. Don't
             use them during normal gameplay.
            
             Running an *existing* device through another control build is a *destructive* operation.
             Existing controls may be reused while at the same time the hierarchy and even the device instance
             itself may change.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher">
             <summary>
             Specification that can be matched against an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/>. This is
             used to find which <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> to create for a device when it is discovered.
             </summary>
             <remarks>
             Each matcher is basically a set of key/value pairs where each value may either be
             a regular expression or a plain value object. The central method for testing a given matcher
             against an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> is <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.MatchPercentage(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>.
            
             Various helper methods such as <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithInterface(System.String,System.Boolean)"/> or <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithCapability``1(System.String,``0)"/>
             assist with creating matchers.
            
             <example>
             <code>
             // A matcher that matches a PS4 controller by name.
             new InputDeviceMatcher()
                 .WithInterface("HID")
                 .WithManufacturer("Sony.+Entertainment") // Regular expression
                 .WithProduct("Wireless Controller"));
            
             // A matcher that matches the same controller by PID and VID.
             new InputDeviceMatcher()
                 .WithInterface("HID")
                 .WithCapability("vendorId", 0x54C) // Sony Entertainment.
                 .WithCapability("productId", 0x9CC)); // Wireless controller.
             </code>
             </example>
            
             For each registered <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> in the system that represents
             a device, arbitrary many matchers can be added. A matcher can be supplied either
             at registration time or at any point after using <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>.
            
             <example>
             <code>
             // Supply a matcher at registration time.
             InputSystem.RegisterLayout&lt;DualShock4GamepadHID&gt;(
                 matches: new InputDeviceMatcher()
                     .WithInterface("HID")
                     .WithCapability("vendorId", 0x54C) // Sony Entertainment.
                     .WithCapability("productId", 0x9CC)); // Wireless controller.
            
             // Supply a matcher for an already registered layout.
             // This can be called repeatedly and will add another matcher
             // each time.
             InputSystem.RegisterLayoutMatcher&lt;DualShock4GamepadHID&gt;(
                 matches: new InputDeviceMatcher()
                     .WithInterface("HID")
                     .WithManufacturer("Sony.+Entertainment")
                     .WithProduct("Wireless Controller"));
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.description"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutMatcher(System.String,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.empty">
            <summary>
            If true, the matcher has been default-initialized and contains no
            matching <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/>.
            </summary>
            <value>Whether the matcher contains any matching patterns.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns">
             <summary>
             The list of patterns to match.
             </summary>
             <value>List of matching patterns.</value>
             <remarks>
             Each pattern is comprised of a key and a value. The key determines which part
             of an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription"/> to match.
            
             The value represents the expected value. This can be either a plain string
             (matched case-insensitive) or a regular expression.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithInterface(System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithCapability``1(System.String,``0)"/>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithProduct(System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithManufacturer(System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithVersion(System.String,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithDeviceClass(System.String,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithInterface(System.String,System.Boolean)">
            <summary>
            Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match an <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.interfaceName"/>.
            </summary>
            <param name="pattern">String to match.</param>
            <param name="supportRegex">If true (default), <paramref name="pattern"/> can be
            a regular expression.</param>
            <returns>The modified device matcher with the added pattern.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.interfaceName"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithDeviceClass(System.String,System.Boolean)">
            <summary>
            Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match a <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.deviceClass"/>.
            </summary>
            <param name="pattern">String to match.</param>
            <param name="supportRegex">If true (default), <paramref name="pattern"/> can be
            a regular expression.</param>
            <returns>The modified device matcher with the added pattern.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.deviceClass"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithManufacturer(System.String,System.Boolean)">
            <summary>
            Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match a <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.manufacturer"/>.
            </summary>
            <param name="pattern">String to match.</param>
            <param name="supportRegex">If true (default), <paramref name="pattern"/> can be
            a regular expression.</param>
            <returns>The modified device matcher with the added pattern.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.manufacturer"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithProduct(System.String,System.Boolean)">
            <summary>
            Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match a <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.product"/>.
            </summary>
            <param name="pattern">String to match.</param>
            <param name="supportRegex">If true (default), <paramref name="pattern"/> can be
            a regular expression.</param>
            <returns>The modified device matcher with the added pattern.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.product"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithVersion(System.String,System.Boolean)">
            <summary>
            Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match a <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.version"/>.
            </summary>
            <param name="pattern">String to match.</param>
            <param name="supportRegex">If true (default), <paramref name="pattern"/> can be
            a regular expression.</param>
            <returns>The modified device matcher with the added pattern.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.version"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithCapability``1(System.String,``0)">
             <summary>
             Add a pattern to <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> to match an individual capability in <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/>.
             </summary>
             <param name="path">Path to the JSON property using '/' as a separator,
             e.g. <c>"elements/count"</c>.</param>
             <param name="value">Value to match. This can be a string, a regular expression,
             a boolean, an integer, or a float. Floating-point numbers are matched with respect
             for <c>Mathf.Epsilon</c>. Values are converted between types automatically as
             needed (meaning that a bool can be compared to a string, for example).</param>
             <typeparam name="TValue">Type of value to match.</typeparam>
             <returns>The modified device matcher with the added pattern.</returns>
             <remarks>
             Capabilities are stored as JSON strings in <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/>.
             A matcher has the ability to match specific properties from the JSON object
             contained in the capabilities string.
            
             <example>
             <code>
             // The description for a HID will usually have a HIDDeviceDescriptor in
             // JSON format found on its InputDeviceDescription.capabilities. So, a
             // real-world device description could look the equivalent of this:
             var description = new InputDeviceDescription
             {
                 interfaceName = "HID",
                 capabilities = new HID.HIDDeviceDescriptor
                 {
                     vendorId = 0x54C,
                     productId = 0x9CC
                 }.ToJson()
             };
            
             // We can create a device matcher that looks for those to properties
             // directly in the JSON object.
             new InputDeviceMatcher()
                 .WithCapability("vendorId", 0x54C)
                 .WithCapability("productId", 0x9CC);
             </code>
             </example>
            
             Properties in nested objects can be referenced by separating properties
             with <c>/</c> and properties in arrays can be indexed with <c>[..]</c>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.MatchPercentage(UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
             <summary>
             Return the level of matching to the given <paramref name="deviceDescription"/>.
             </summary>
             <param name="deviceDescription">A device description.</param>
             <returns>A score usually in the range between 0 and 1.</returns>
             <remarks>
             The algorithm computes a score of how well the matcher matches the given description.
             Essentially, a matcher that matches every single property that is present (as in
             not <c>null</c> and not an empty string) in <paramref name="deviceDescription"/> receives
             a score of 1, a matcher that matches none a score of 0. Matches that match only a subset
             receive a score in-between.
            
             An exception to this are capabilities. Every single match of a capability is counted
             as one property match and added to the score. This means that matchers that match
             on multiple capabilities may actually achieve a score &gt;1.
            
             <example>
             <code>
             var description = new InputDeviceDescription
             {
                 interfaceName = "HID",
                 product = "MadeUpDevice",
                 capabilities = new HID.HIDDeviceDescriptor
                 {
                     vendorId = 0xABC,
                     productId = 0xDEF
                 }.ToJson()
             };
            
             // This matcher will achieve a score of 0.666 (2/3) as it
             // matches two out of three available properties.
             new InputDeviceMatcher()
                 .WithInterface("HID")
                 .WithProduct("MadeUpDevice");
            
             // This matcher will achieve a score of 1 despite not matching
             // 'product'. The reason is that it matches two keys in
             // 'capabilities'.
             new InputDeviceMatcher()
                 .WithInterface("HID")
                 .WithCapability("vendorId", 0xABC)
                 .WithCapability("productId", 0xDEF);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.FromDeviceDescription(UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
            <summary>
            Produce a matcher that matches the given device description verbatim.
            </summary>
            <param name="deviceDescription">A device description.</param>
            <returns>A matcher that matches <paramref name="deviceDescription"/> exactly.</returns>
            <remarks>
            This method can be used to produce a matcher for an existing device description,
            e.g. when writing a layout <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder"/> that produces
            layouts for devices on the fly.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.ToString">
            <summary>
            Return a string representation useful for debugging. Lists the
            <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.patterns"/> contained in the matcher.
            </summary>
            <returns>A string representation of the matcher.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.Equals(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)">
            <summary>
            Test whether this matcher is equivalent to the <paramref name="other"/> matcher.
            </summary>
            <param name="other">Another device matcher.</param>
            <returns>True if the two matchers are equivalent.</returns>
            <remarks>
            Two matchers are equivalent if they contain the same number of patterns and the
            same pattern occurs in each of the matchers. Order of the patterns does not
            matter.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.Equals(System.Object)">
            <summary>
            Compare this matcher to another.
            </summary>
            <param name="obj">A matcher object or <c>null</c>.</param>
            <returns>True if the matcher is equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.Equals(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.op_Equality(UnityEngine.InputSystem.Layouts.InputDeviceMatcher,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)">
            <summary>
            Compare two matchers for equivalence.
            </summary>
            <param name="left">First device matcher.</param>
            <param name="right">Second device matcher.</param>
            <returns>True if the two matchers are equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.Equals(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.op_Inequality(UnityEngine.InputSystem.Layouts.InputDeviceMatcher,UnityEngine.InputSystem.Layouts.InputDeviceMatcher)">
            <summary>
            Compare two matchers for non-equivalence.
            </summary>
            <param name="left">First device matcher.</param>
            <param name="right">Second device matcher.</param>
            <returns>True if the two matchers are not equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.Equals(UnityEngine.InputSystem.Layouts.InputDeviceMatcher)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.GetHashCode">
            <summary>
            Compute a hash code for the device matcher.
            </summary>
            <returns>A hash code for the matcher.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputDeviceFindControlLayoutDelegate">
            <summary>
            Delegate used by <see cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>.
            </summary>
            <param name="description">The device description supplied by the runtime or through <see
            cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>. This is passed by reference instead of
            by value to allow the callback to fill out fields such as <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/>
            on the fly based on information queried from external APIs or from the runtime.</param>
            <param name="matchedLayout">Name of the layout that has been selected for the device or <c>null</c> if
            no matching layout could be found. Matching is determined from the <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>s for
            layouts registered in the system.</param>
            <param name="executeDeviceCommand">A delegate which can be invoked to execute <see cref="T:UnityEngine.InputSystem.LowLevel.InputDeviceCommand"/>s
            on the device.</param>
            <returns>  Return <c>null</c> or an empty string to indicate that </returns>
            <remarks>
            </remarks>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onFindLayoutForDevice"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlLayout">
             <summary>
             A control layout specifies the composition of an <see cref="T:UnityEngine.InputSystem.InputControl"/> or
             <see cref="T:UnityEngine.InputSystem.InputDevice"/>.
             </summary>
             <remarks>
             Control layouts can be created in three possible ways:
            
             <list type="number">
             <item><description>Loaded from JSON.</description></item>
             <item><description>Constructed through reflection from <see cref="T:UnityEngine.InputSystem.InputControl">InputControls</see> classes.</description></item>
             <item><description>Through layout factories using <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder"/>.</description></item>
             </list>
            
             Once constructed, control layouts are immutable (but you can always
             replace a registered layout in the system and it will affect
             everything constructed from the layout).
            
             Control layouts can be for arbitrary control rigs or for entire
             devices. Device layouts can be matched to <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription">
             device description</see> using associated <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher">
             device matchers</see>.
            
             InputControlLayout objects are considered temporaries. Except in the
             editor, they are not kept around beyond device creation.
            
             See the <a href="../manual/Layouts.html">manual</a> for more details on control layouts.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem">
            <summary>
            Specification for the composition of a direct or indirect child control.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.name">
             <summary>
             Name of the control. Cannot be empty or <c>null</c>.
             </summary>
             <value>Name of the control.</value>
             <remarks>
             This may also be a path of the form <c>"parentName/childName..."</c>.
             This can be used to reach inside another layout and modify properties of
             a control inside of it. An example for this is adding a "leftStick" control
             using the Stick layout and then adding two control layouts that refer to
             "leftStick/x" and "leftStick/y" respectively to modify the state format used
             by the stick.
            
             This field is required.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isModifyingExistingControl"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.name"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.layout">
             <summary>
             Name of the layout to use for the control.
             </summary>
             <value>Name of layout to use.</value>
             <remarks>
             Must be the name of a control layout, not device layout.
            
             An example would be "Stick".
             </remarks>
             <seealso cref="!:InputSystem.RegisterLayout(Type,string,Nullable&lt;InputDeviceMatcher&gt;"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.displayName">
            <summary>
            Optional display name of the control.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.displayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.shortDisplayName">
            <summary>
            Optional abbreviated display name of the control.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.shortDisplayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.defaultState">
            <summary>
            Optional default value for the state memory associated with the control.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isModifyingExistingControl">
            <summary>
            If true, the item will not add a control but rather a modify a control
            inside the hierarchy added by <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.layout"/>. This allows, for example, to modify
            just the X axis control of the left stick directly from within a gamepad
            layout instead of having to have a custom stick layout for the left stick
            than in turn would have to make use of a custom axis layout for the X axis.
            Instead, you can just have a control layout with the name <c>"leftStick/x"</c>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isNoisy">
            <summary>
            Get or set whether to mark the control as noisy.
            </summary>
            <value>Whether to mark the control as noisy.</value>
            <remarks>
            Noisy controls may generate varying input even without "proper" user interaction. For example,
            a sensor may generate slightly different input values over time even if in fact the very thing
            (such as the device orientation) that is being measured is not changing.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isSynthetic">
            <summary>
            Get or set whether to mark the control as "synthetic".
            </summary>
            <value>Whether to mark the control as synthetic.</value>
            <remarks>
            Synthetic controls are artificial controls that provide input but do not correspond to actual controls
            on the hardware. An example is <see cref="P:UnityEngine.InputSystem.Keyboard.anyKey"/> which is an artificial button that triggers
            if any key on the keyboard is pressed.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.synthetic"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.dontReset">
             <summary>
             Get or set whether the control should be excluded when performing a device reset.
             </summary>
             <value>If true, the control will not get reset in a device reset. Off by default.</value>
             <remarks>
             Some controls like, for example, mouse positions do not generally make sense to reset when a
             device is reset. By setting this flag on, the control's state will be excluded in resets.
            
             Note that a full reset can still be forced through <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/> in
             which case controls that have this flag set will also get reset.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isFirstDefinedInThisLayout">
            <summary>
            Whether the control is introduced by the layout.
            </summary>
            <value>If true, the control is first introduced by this layout.</value>
            <remarks>
            The value of this property is automatically determined by the input system.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.Merge(UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem)">
            <summary>
            For any property not set on this control layout, take the setting from <paramref name="other"/>.
            </summary>
            <param name="other">Control layout providing settings.</param>
            <remarks>
            <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.name"/> will not be touched.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputControlLayout.MergeLayout(UnityEngine.InputSystem.Layouts.InputControlLayout)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.controls">
            <summary>
            List of child controls defined for the layout.
            </summary>
            <value>Child controls defined for the layout.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.isOverride">
            <summary>
            Whether the layout is applies overrides to other layouts instead of
            defining a layout by itself.
            </summary>
            <value>True if the layout acts as an override.</value>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutOverride(System.String,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.isNoisy">
            <summary>
            Mark the input device created from this layout as noisy, irrespective of whether or not any
            of its controls have been marked as noisy.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.isNoisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.canRunInBackground">
            <summary>
            Override value for <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>. If this is set by the
            layout, it will prevent <see cref="T:UnityEngine.InputSystem.LowLevel.QueryCanRunInBackground"/> from being issued. However, other
            logic that affects <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/> may still force a specific value
            on a device regardless of what's set in the layout.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputControlLayout.GetValueType">
            <summary>
            Return the type of values produced by controls created from the layout.
            </summary>
            <returns>The value type of the control or null if it cannot be determined.</returns>
            <remarks>
            This method only returns the statically inferred value type. This type corresponds
            to the type argument to <see cref="T:UnityEngine.InputSystem.InputControl`1"/> in the inheritance hierarchy
            of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.type"/>. As the type used by the layout may not inherit from
            <see cref="T:UnityEngine.InputSystem.InputControl`1"/>, this may mean that the value type cannot be inferred
            and the method will return null.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueType"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder">
            <summary>
            Build a layout programmatically. Primarily for use by layout builders
            registered with the system.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayoutBuilder(System.Func{UnityEngine.InputSystem.Layouts.InputControlLayout},System.String,System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.name">
            <summary>
            Name to assign to the layout.
            </summary>
            <value>Name to assign to the layout.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.name"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.displayName">
            <summary>
            Display name to assign to the layout.
            </summary>
            <value>Display name to assign to the layout</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.displayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.type">
            <summary>
            <see cref="T:UnityEngine.InputSystem.InputControl"/> type to instantiate for the layout.
            </summary>
            <value>Control type to instantiate for the layout.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.type"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.stateFormat">
            <summary>
            Memory format FourCC code to apply to state memory used by the
            layout.
            </summary>
            <value>FourCC memory format tag.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.stateFormat"/>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.stateSizeInBytes">
            <summary>
            Total size of memory used by the layout.
            </summary>
            <value>Size of memory used by the layout.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.stateSizeInBytes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.extendsLayout">
            <summary>
            Which layout to base this layout on.
            </summary>
            <value>Name of base layout.</value>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.baseLayouts"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.updateBeforeRender">
            <summary>
            For device layouts, whether the device wants an extra update
            before rendering.
            </summary>
            <value>True if before-render updates should be enabled for the device.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.updateBeforeRender"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.controls">
            <summary>
            List of control items set up by the layout.
            </summary>
            <value>Controls set up by the layout.</value>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.AddControl(System.String)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.ControlBuilder">
            <summary>
            Syntax for configuring an individual <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputControlLayout.Builder.AddControl(System.String)">
            <summary>
            Add a new control to the layout.
            </summary>
            <param name="name">Name or path of the control. If it is a path (e.g. <c>"leftStick/x"</c>,
            then the control either modifies the setup of a child control of another control in the layout
            or adds a new child control to another control in the layout. Modifying child control is useful,
            for example, to alter the state format of controls coming from the base layout. Likewise,
            adding child controls to another control is useful to modify the setup of of the control layout
            being used without having to create and register a custom control layout.</param>
            <returns>A control builder that permits setting various parameters on the control.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is null or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputControlLayout.MergeLayout(UnityEngine.InputSystem.Layouts.InputControlLayout)">
            <summary>
            Merge the settings from <paramref name="other"/> into the layout such that they become
            the base settings.
            </summary>
            <param name="other"></param>
            <remarks>
            This is the central method for allowing layouts to 'inherit' settings from their
            base layout. It will merge the information in <paramref name="other"/> into the current
            layout such that the existing settings in the current layout acts as if applied on top
            of the settings in the base layout.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute">
            <summary>
            Attribute to control layout settings of a type used to generate an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.stateType">
             <summary>
             Associates a state representation with an input device and drives
             the control layout generated for the device from its state rather
             than from the device class.
             </summary>
             <remarks>This is *only* useful if you have a state struct dictating a specific
             state layout and you want the device layout to automatically take offsets from
             the fields annotated with <see cref="T:UnityEngine.InputSystem.Layouts.InputControlAttribute"/>.
            
             <example>
             <code>
             public struct MyStateStruct : IInputStateTypeInfo
             {
                 public FourCC format => new FourCC('M', 'Y', 'D', 'V');
            
                 [InputControl(name = "button1", layout = "Button", bit = 0)]
                 [InputControl(name = "button2", layout = "Button", bit = 0)]
                 public int buttons;
             }
            
             [InputControlLayout(stateType = typeof(MyStateStruct)]
             public class MyDevice : InputDevice
             {
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputStateBlock"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.MouseState"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.stateFormat">
            <summary>
            <see cref="T:UnityEngine.InputSystem.Utilities.FourCC"/> identifier for the memory format associated with the layout.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.isNoisy">
            <summary>
            Allows marking a device as noisy regardless of control layout.
            </summary>
            <remarks>
            Controls can be individually marked as noisy using the <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy"/>
            attribute, but this property can be used to mark a device as noisy even when no control has been
            marked as such. This can be useful when a device state layout has only been partially implemented
            i.e. some data in the state memory has not been mapped to a control, and the unimplemented controls
            are noisy. Without doing this, the device will constantly be made current as the system has no way
            to know that the event data contains only noise.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.updateBeforeRender">
            <summary>
            Whether the device should receive events in <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/> updates.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.isGenericTypeOfDevice">
            <summary>
            If true, the layout describes a generic class of devices such as "gamepads" or "mice".
            </summary>
            <remarks>
            This property also determines how the layout is presented in the UI. All the device layouts
            that are marked as generic kinds of devices are displayed with their own entry at the root level of
            the control picker (<see cref="T:UnityEngine.InputSystem.Editor.InputControlPicker"/>), for example.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.displayName">
            <summary>
            Gives a name to display in the UI. By default, the name is the same as the class the attribute
            is applied to.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.hideInUI">
            <summary>
            If true, don't include the layout when presenting picking options in the UI.
            </summary>
            <remarks>
            This will keep device layouts out of the control picker and will keep control layouts out of
            action type dropdowns.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputControlAttribute">
             <summary>
             Mark a field or property as representing/identifying an input control in some form.
             </summary>
             <remarks>
             This attribute is used in different places for different purposes.
            
             When creating input control layouts (<see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>) in C#, applying the
             attribute to fields in a state struct (see <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateTypeInfo"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.GamepadState"/>
             for an example) or to properties in an input device (<see cref="T:UnityEngine.InputSystem.InputDevice"/>), will cause an
             <see cref="T:UnityEngine.InputSystem.InputControl"/> to be created from the field or property at runtime. The attribute
             can be applied multiple times to create multiple input controls (e.g. when having an int field
             that represents a bitfield where each bit is a separate button).
            
             <example>
             <code>
             public class MyDevice : InputDevice
             {
                 // Adds an InputControl with name=myButton and layout=Button to the device.
                 [InputControl]
                 public ButtonControl myButton { get; set; }
             }
             </code>
             </example>
            
             Another use is for marking <c>string</c> type fields that represent input control paths. Applying
             the attribute to them will cause them to automatically use a custom inspector similar to the one
             found in the action editor. For this use, only the <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout"/> property is taken into
             account.
            
             <example>
             <code>
             public class MyBehavior : MonoBehaviour
             {
                 // In the inspector, shows a control selector that is restricted to
                 // selecting buttons. As a result, controlPath will be set to path
                 // representing the control that was picked (e.g. "&lt;Gamepad&gt;/buttonSouth").
                 [InputControl(layout = "Button")]
                 public string controlPath;
            
                 protected void OnEnable()
                 {
                     // Find controls by path.
                     var controls = InputSystem.FindControl(controlPath);
                     //...
                 }
             }
             </code>
             </example>
            
             Finally, the attribute is also used in composite bindings (<see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>)
             to mark fields that reference parts of the composite. An example for this is <see cref="F:UnityEngine.InputSystem.Composites.AxisComposite.negative"/>.
             In this use, also only the <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout"/> property is taken into account while other properties
             are ignored.
            
             <example>
             <code>
             public class MyComposite : InputBindingComposite&lt;float&gt;
             {
                 // Add a part to the composite called 'firstControl' which expects
                 // AxisControls.
                 [InputControl(layout = "Axis")]
                 public int firstControl;
            
                 // Add a part to the composite called 'secondControl' which expects
                 // Vector3Controls.
                 [InputControl(layout = "Vector3")]
                 public int secondControl;
            
                 //...
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
             <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout">
            <summary>
            Layout to use for the control.
            </summary>
            <value>Layout to use for the control.</value>
            <remarks>
            If this is not set, the system tries to infer the layout type from the value type of
            the field or property. If the value type is itself registered as a layout, that layout
            will be used (e.g. when you have a property of type <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>, the layout
            will be inferred to be "Button"). Otherwise, if a layout with the same name as the type is registered,
            that layout will be used (e.g. when you have a field of type <see cref="T:UnityEngine.Vector3"/>, the layout
            will be inferred to be "Vector3").
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.variants">
            <summary>
            Layout variant to use for the control.
            </summary>
            <value>Layout variant to use for the control.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.name">
            <summary>
            Name to give to the name. If null or empty, the name of the property or
            field the attribute is applied to will be used.
            </summary>
            <value>Name to give to the control.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.name"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.format">
            <summary>
            Storage format to use for the control. If not set, default storage format
            for the given <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout"/> is used.
            </summary>
            <value>Memory storage format to use for the control.</value>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usage">
            <summary>
            Usage to apply to the control.
            </summary>
            <value>Usage for the control.</value>
            <remarks>
            This property can be used in place of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usages"/> to set just a single
            usage on the control.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.usages"/>
            <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usages">
            <summary>
            Usages to apply to the control.
            </summary>
            <value>Usages for the control.</value>
            <remarks>
            This property should be used instead of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.usage"/> when a control has multiple usages.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.usages"/>
            <seealso cref="T:UnityEngine.InputSystem.CommonUsages"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.parameters">
             <summary>
             Optional list of parameters to apply to the control.
             </summary>
             <value>Parameters to apply to the control.</value>
             <remarks>
             An <see cref="T:UnityEngine.InputSystem.InputControl"/> may expose public fields which can be set as
             parameters. An example of this is <see cref="F:UnityEngine.InputSystem.Controls.AxisControl.clamp"/>.
            
             <example>
             <code>
             public struct MyStateStruct : IInputStateTypeInfo
             {
                 [InputControl(parameters = "clamp,clampMin=-0.5,clampMax=0.5")]
                 public float axis;
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.parameters"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.processors">
             <summary>
             Optional list of processors to add to the control.
             </summary>
             <value>Processors to apply to the control.</value>
             <remarks>
             Each element in the list is a name of a processor (as registered with
             <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>) followed by an optional
             list of parameters.
            
             For example, <c>"normalize(min=0,max=256)"</c> is one element that puts
             a <c>NormalizeProcessor</c> on the control and sets its <c>min</c> field
             to 0 and its its <c>max</c> field to 256.
            
             Multiple processors can be put on a control by separating them with a comma.
             For example, <c>"normalize(max=256),scale(factor=2)"</c> puts both a <c>NormalizeProcessor</c>
             and a <c>ScaleProcessor</c> on the control. Processors are applied in the
             order they are listed.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.alias">
             <summary>
             An alternative name that can be used in place of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.name"/> to find
             the control.
             </summary>
             <value>Alternative name for the control.</value>
             <remarks>
             This property can be used instead of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.aliases"/> when there is only a
             single alias for the control.
            
             Aliases, like names, are case-insensitive. Any control may have arbitrary many
             aliases.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.aliases"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.aliases"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.aliases">
             <summary>
             A list of alternative names that can be used in place of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.name"/> to
             find the control.
             </summary>
             <value>Alternative names for the control.</value>
             <remarks>
             This property should be used instead of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.alias"/> when a control has
             multiple aliases.
            
             Aliases, like names, are case-insensitive. Any control may have arbitrary many
             aliases.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.aliases"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.aliases"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.offset">
             <summary>
             Offset in bytes to where the memory of the control starts. Relative to
             the offset of the parent control (which may be the device itself).
             </summary>
             <value>Byte offset of the control.</value>
             <remarks>
             If the attribute is applied to fields in an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> and
             this property is not set, the offset of the field is used instead.
            
             <example>
             <code>
             public struct MyStateStruct : IInputStateTypeInfo
             {
                 public int buttons;
            
                 [InputControl] // Automatically uses the offset of 'axis'.
                 public float axis;
             }
            
             [InputControlLayout(stateType = typeof(MyStateStruct))]
             public class MyDevice : InputDevice
             {
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.offset"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.sizeInBits">
             <summary>
             Size of the memory storage for the control in bits.
             </summary>
             <value>Size of the control in bits.</value>
             <remarks>
             If the attribute is applied to fields in an <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> and
             this property is not set, the size is taken from the field.
            
             <example>
             <code>
             public struct MyStateStruct : IInputStateTypeInfo
             {
                 public int buttons;
            
                 [InputControl] // Automatically uses sizeof(float).
                 public float axis;
             }
            
             [InputControlLayout(stateType = typeof(MyStateStruct))]
             public class MyDevice : InputDevice
             {
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.sizeInBits"/>
             <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.sizeInBits"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.displayName">
            <summary>
            Display name to assign to the control.
            </summary>
            <value>Display name for the control.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.displayName"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.displayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.shortDisplayName">
            <summary>
            Short display name to assign to the control.
            </summary>
            <value>Short display name for the control.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.shortDisplayName"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.shortDisplayName"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.noisy">
            <summary>
            Whether the control is noisy. Off by default.
            </summary>
            <value>Whether control is noisy.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isNoisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.synthetic">
            <summary>
            Whether the control is synthetic. Off by default.
            </summary>
            <value>Whether control is synthetic.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.isSynthetic"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.dontReset">
            <summary>
            Allows you to specify that a control should not be reset when its device is reset.
            </summary>
            <value>If true, resets of the device will leave the value of the control untouched except if a "hard" reset
            is explicitly enforced.</value>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.dontReset"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.defaultState">
            <summary>
            Default state to write into the control's memory.
            </summary>
            <value>Default memory state for the control.</value>
            <remarks>
            This is not the default <em>value</em> but rather the default memory state, i.e.
            the raw memory value read and the processed and returned as a value. By default
            this is <c>null</c> and result in a control's memory to be initialized with all
            zeroes.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.defaultState"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.minValue">
            <summary>
            Lower limit for values of the control.
            </summary>
            <value>Lower limit for values of the control.</value>
            <remarks>
            This is null by default in which case no lower bound is applied to the TODO
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Layouts.InputDeviceDescription">
             <summary>
             Metadata for an input device.
             </summary>
             <remarks>
             Device descriptions are mainly used to determine which <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
             to create an actual <see cref="T:UnityEngine.InputSystem.InputDevice"/> instance from. Each description is comprised
             of a set of properties that each are individually optional. However, for a description
             to be usable, at least some need to be set. Generally, the minimum viable description
             for a device is one with <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.deviceClass"/> filled out.
            
             <example>
             <code>
             // Device description equivalent to a generic gamepad with no
             // further information about the device.
             new InputDeviceDescription
             {
                 deviceClass = "Gamepad"
             };
             </code>
             </example>
            
             Device descriptions will usually be supplied by the Unity runtime but can also be manually
             fed into the system using <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>. The
             system will remember each device description it has seen regardless of whether it was
             able to successfully create a device from the description. To query the list of descriptions
             that for whatever reason did not result in a device being created, call <see
             cref="M:UnityEngine.InputSystem.InputSystem.GetUnsupportedDevices"/>.
            
             Whenever layout registrations in the system are changed (e.g. by calling <see
             cref="M:UnityEngine.InputSystem.InputSystem.RegisterLayout``1(System.String,System.Nullable{UnityEngine.InputSystem.Layouts.InputDeviceMatcher})"/> or whenever <see cref="P:UnityEngine.InputSystem.InputSettings.supportedDevices"/>
             is changed, the system will go through the list of unsupported devices itself and figure out
             if there are device descriptions that now it can turn into devices. The same also applies
             in reverse; if, for example, a layout is removed that is currently used a device, the
             device will be removed and its description (if any) will be placed on the list of
             unsupported devices.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.description"/>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.interfaceName">
            <summary>
            How we talk to the device; usually name of the underlying backend that feeds
            state for the device (e.g. "HID" or "XInput").
            </summary>
            <value>Name of interface through which the device is reported.</value>
            <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithInterface(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.deviceClass">
            <summary>
            What the interface thinks the device classifies as.
            </summary>
            <value>Broad classification of device.</value>
            <remarks>
            If there is no layout specifically matching a device description,
            the device class is used as as fallback. If, for example, this field
            is set to "Gamepad", the "Gamepad" layout is used as a fallback.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithDeviceClass(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.manufacturer">
            <summary>
            Name of the vendor that produced the device.
            </summary>
            <value>Name of manufacturer.</value>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithManufacturer(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.product">
            <summary>
            Name of the product assigned by the vendor to the device.
            </summary>
            <value>Name of product.</value>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithProduct(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.serial">
            <summary>
            If available, serial number for the device.
            </summary>
            <value>Serial number of device.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.version">
            <summary>
            Version string of the device and/or driver.
            </summary>
            <value>Version of device and/or driver.</value>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithVersion(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities">
             <summary>
             An optional JSON string listing device-specific capabilities.
             </summary>
             <value>Interface-specific listing of device capabilities.</value>
             <remarks>
             The primary use of this field is to allow custom layout factories
             to create layouts on the fly from in-depth device descriptions delivered
             by external APIs.
            
             In the case of HID, for example, this field contains a JSON representation
             of the HID descriptor (see <see cref="T:UnityEngine.InputSystem.HID.HID.HIDDeviceDescriptor"/>) as
             reported by the device driver. This descriptor contains information about
             all I/O elements on the device which can be used to determine the control
             setup and data format used by the device.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceMatcher.WithCapability``1(System.String,``0)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.empty">
            <summary>
            Whether any of the properties in the description are set.
            </summary>
            <value>True if any of <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.interfaceName"/>, <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.deviceClass"/>,
            <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.manufacturer"/>, <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.product"/>, <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.serial"/>,
            <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.version"/>, or <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/> is not <c>null</c> and
            not empty.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.ToString">
            <summary>
            Return a string representation of the description useful for
            debugging.
            </summary>
            <returns>A script representation of the description.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.Equals(UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
            <summary>
            Compare the description to the given <paramref name="other"/> description.
            </summary>
            <param name="other">Another device description.</param>
            <returns>True if the two descriptions are equivalent.</returns>
            <remarks>
            Two descriptions are equivalent if all their properties are equal
            (ignore case).
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.Equals(System.Object)">
            <summary>
            Compare the description to the given object.
            </summary>
            <param name="obj">An object.</param>
            <returns>True if <paramref name="obj"/> is an InputDeviceDescription
            equivalent to this one.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.Equals(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.GetHashCode">
            <summary>
            Compute a hash code for the device description.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.op_Equality(UnityEngine.InputSystem.Layouts.InputDeviceDescription,UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
            <summary>
            Compare the two device descriptions.
            </summary>
            <param name="left">First device description.</param>
            <param name="right">Second device description.</param>
            <returns>True if the two descriptions are equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.Equals(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.op_Inequality(UnityEngine.InputSystem.Layouts.InputDeviceDescription,UnityEngine.InputSystem.Layouts.InputDeviceDescription)">
            <summary>
            Compare the two device descriptions for inequality.
            </summary>
            <param name="left">First device description.</param>
            <param name="right">Second device description.</param>
            <returns>True if the two descriptions are not equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.Equals(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.ToJson">
             <summary>
             Return a JSON representation of the device description.
             </summary>
             <returns>A JSON representation of the description.</returns>
             <remarks>
             <example>
             The result can be converted back into an InputDeviceDescription
             using <see cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.FromJson(System.String)"/>.
            
             <code>
             var description = new InputDeviceDescription
             {
                 interfaceName = "HID",
                 product = "SomeDevice",
                 capabilities = @"
                     {
                         ""vendorId"" : 0xABA,
                         ""productId"" : 0xEFE
                     }
                 "
             };
            
             Debug.Log(description.ToJson());
             // Prints
             // {
             //     "interface" : "HID",
             //     "product" : "SomeDevice",
             //     "capabilities" : "{ \"vendorId\" : 0xABA, \"productId\" : 0xEFF }"
             // }
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.FromJson(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.FromJson(System.String)">
            <summary>
            Read an InputDeviceDescription from its JSON representation.
            </summary>
            <param name="json">String in JSON format.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is <c>null</c>.</exception>
            <returns>The converted </returns>
            <exception cref="T:System.ArgumentException">There as a parse error in <paramref name="json"/>.
            </exception>
            <remarks>
            <example>
            <code>
            InputDeviceDescription.FromJson(@"
                {
                    ""interface"" : ""HID"",
                    ""product"" : ""SomeDevice""
                }
            ");
            </code>
            </example>
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.Layouts.InputDeviceDescription.ToJson"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Gamepad">
             <summary>
             An Xbox-style gamepad with two sticks, a D-Pad, four face buttons, two triggers,
             two shoulder buttons, and two menu buttons that usually sit in the midsection of the gamepad.
             </summary>
             <remarks>
             The Gamepad layout provides a standardized layouts for gamepads. Generally, if a specific
             device is represented as a Gamepad, the controls, such as the face buttons, are guaranteed
             to be mapped correctly and consistently. If, based on the set of supported devices available
             to the input system, this cannot be guaranteed, a given device is usually represented as a
             generic <see cref="T:UnityEngine.InputSystem.Joystick"/> or as just a plain <see cref="T:UnityEngine.InputSystem.HID.HID"/> instead.
            
             <example>
             <code>
             // Show all gamepads in the system.
             Debug.Log(string.Join("\n", Gamepad.all));
            
             // Check whether the X button on the current gamepad is pressed.
             if (Gamepad.current.xButton.wasPressedThisFrame)
                 Debug.Log("Pressed");
            
             // Rumble the left motor on the current gamepad slightly.
             Gamepad.current.SetMotorSpeeds(0.2f, 0.
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.buttonWest">
            <summary>
            The left face button of the gamepad.
            </summary>
            <value>Control representing the X/Square face button.</value>
            <remarks>
            On an Xbox controller, this is the X button and on the PS4 controller, this is the
            square button.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.xButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.squareButton"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.buttonNorth">
            <summary>
            The top face button of the gamepad.
            </summary>
            <value>Control representing the Y/Triangle face button.</value>
            <remarks>
            On an Xbox controller, this is the Y button and on the PS4 controller, this is the
            triangle button.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.yButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.triangleButton"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.buttonSouth">
            <summary>
            The bottom face button of the gamepad.
            </summary>
            <value>Control representing the A/Cross face button.</value>
            <remarks>
            On an Xbox controller, this is the A button and on the PS4 controller, this is the
            cross button.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.aButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.crossButton"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.buttonEast">
            <summary>
            The right face button of the gamepad.
            </summary>
            <value>Control representing the B/Circle face button.</value>
            <remarks>
            On an Xbox controller, this is the B button and on the PS4 controller, this is the
            circle button.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.bButton"/>
            <seealso cref="P:UnityEngine.InputSystem.Gamepad.circleButton"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.leftStickButton">
            <summary>
            The button that gets triggered when <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> is pressed down.
            </summary>
            <value>Control representing a click with the left stick.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.rightStickButton">
            <summary>
            The button that gets triggered when <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/> is pressed down.
            </summary>
            <value>Control representing a click with the right stick.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.startButton">
            <summary>
            The right button in the middle section of the gamepad (called "menu" on Xbox
            controllers and "options" on PS4 controllers).
            </summary>
            <value>Control representing the right button in midsection.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.selectButton">
            <summary>
            The left button in the middle section of the gamepad (called "view" on Xbox
            controllers and "share" on PS4 controllers).
            </summary>
            <value>Control representing the left button in midsection.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.dpad">
            <summary>
            The 4-way directional pad on the gamepad.
            </summary>
            <value>Control representing the d-pad.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.leftShoulder">
            <summary>
            The left shoulder/bumper button that sits on top of <see cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/>.
            </summary>
            <value>Control representing the left shoulder button.</value>
            <remarks>
            On Xbox controllers, this is usually called "left bumper" whereas on PS4
            controllers, this button is referred to as "L1".
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.rightShoulder">
            <summary>
            The right shoulder/bumper button that sits on top of <see cref="P:UnityEngine.InputSystem.Gamepad.rightTrigger"/>.
            </summary>
            <value>Control representing the right shoulder button.</value>
            <remarks>
            On Xbox controllers, this is usually called "right bumper" whereas on PS4
            controllers, this button is referred to as "R1".
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.leftStick">
            <summary>
            The left thumbstick on the gamepad.
            </summary>
            <value>Control representing the left thumbstick.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.rightStick">
            <summary>
            The right thumbstick on the gamepad.
            </summary>
            <value>Control representing the right thumbstick.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.leftTrigger">
            <summary>
            The left trigger button sitting below <see cref="P:UnityEngine.InputSystem.Gamepad.leftShoulder"/>.
            </summary>
            <value>Control representing the left trigger button.</value>
            <remarks>
            On PS4 controllers, this button is referred to as "L2".
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.rightTrigger">
            <summary>
            The right trigger button sitting below <see cref="P:UnityEngine.InputSystem.Gamepad.rightShoulder"/>.
            </summary>
            <value>Control representing the right trigger button.</value>
            <remarks>
            On PS4 controllers, this button is referred to as "R2".
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.aButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>. Xbox-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.bButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonEast"/>. Xbox-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonEast"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.xButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonWest"/> Xbox-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonWest"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.yButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonNorth"/>. Xbox-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonNorth"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.triangleButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonNorth"/>. PS4-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonNorth"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.squareButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonWest"/>. PS4-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonWest"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.circleButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonEast"/>. PS4-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonEast"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.crossButton">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>. PS4-style alias.
            </summary>
            <value>Same as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.Item(UnityEngine.InputSystem.LowLevel.GamepadButton)">
            <summary>
            Retrieve a gamepad button by its <see cref="T:UnityEngine.InputSystem.LowLevel.GamepadButton"/> enumeration
            constant.
            </summary>
            <param name="button">Button to retrieve.</param>
            <exception cref="T:System.ArgumentException"><paramref name="button"/> is not a valid gamepad
            button value.</exception>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.current">
             <summary>
             The gamepad last used/connected by the player or <c>null</c> if there is no gamepad connected
             to the system.
             </summary>
             <remarks>
             When added, a device is automatically made current (see <see cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>), so
             when connecting a gamepad, it will also become current. After that, it will only become current again
             when input change on non-noisy controls (see <see cref="P:UnityEngine.InputSystem.InputControl.noisy"/>) is received.
            
             For local multiplayer scenarios (or whenever there are multiple gamepads that need to be usable
             in a concurrent fashion), it is not recommended to rely on this property. Instead, it is recommended
             to use <see cref="T:UnityEngine.InputSystem.PlayerInput"/> or <see cref="T:UnityEngine.InputSystem.Users.InputUser"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>
             <seealso cref="P:UnityEngine.InputSystem.Gamepad.all"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Gamepad.all">
             <summary>
             A list of gamepads currently connected to the system.
             </summary>
             <value>All currently connected gamepads.</value>
             <remarks>
             Does not cause GC allocation.
            
             Do <em>not</em> hold on to the value returned by this getter but rather query it whenever
             you need it. Whenever the gamepad setup changes, the value returned by this getter
             is invalidated.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Gamepad.current"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.MakeCurrent">
            <summary>
            Make the gamepad the <see cref="P:UnityEngine.InputSystem.Gamepad.current"/> gamepad.
            </summary>
            <remarks>
            This is called automatically by the system when there is input on a gamepad.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.OnAdded">
            <summary>
            Called when the gamepad is added to the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.OnRemoved">
            <summary>
            Called when the gamepad is removed from the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.PauseHaptics">
            <summary>
            Pause rumble effects on the gamepad. Resume with <see cref="M:UnityEngine.InputSystem.Gamepad.ResumeHaptics"/>.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Haptics.IDualMotorRumble"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.ResumeHaptics">
            <summary>
            Resume rumble affects on the gamepad that have been paused with <see cref="M:UnityEngine.InputSystem.Gamepad.PauseHaptics"/>.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Haptics.IDualMotorRumble"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.ResetHaptics">
            <summary>
            Reset rumble effects on the gamepad. Puts the gamepad rumble motors back into their
            default state.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Haptics.IDualMotorRumble"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Gamepad.SetMotorSpeeds(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.InputBindingComposite">
            <summary>
            A binding that synthesizes a value from from several component bindings.
            </summary>
            <remarks>
            This is the base class for composite bindings. See <see cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>
            for more details about composites and for how to define custom composites.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.isComposite"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingComposite.valueType">
            <summary>
            The type of value returned by the composite.
            </summary>
            <value>Type of value returned by the composite.</value>
            <remarks>
            Just like each <see cref="T:UnityEngine.InputSystem.InputControl"/> has a specific type of value it
            will return, each composite has a specific type of value it will return.
            This is usually implicitly defined by the type parameter of <see
            cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueType"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.valueType"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingComposite.valueSizeInBytes">
            <summary>
            Size of a value read by <see cref="M:UnityEngine.InputSystem.InputBindingComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)"/>.
            </summary>
            <value>Size of values stored in memory buffers by <see cref="M:UnityEngine.InputSystem.InputBindingComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)"/>.</value>
            <remarks>
            This is usually implicitly defined by the size of values derived
            from the type argument to <see cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>. E.g.
            if the type argument is <c>Vector2</c>, this property will be 8.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.valueSizeInBytes"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)">
             <summary>
             Read a value from the composite without having to know the value type (unlike
             <see cref="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)"/> and
             without allocating GC heap memory (unlike <see cref="M:UnityEngine.InputSystem.InputBindingComposite.ReadValueAsObject(UnityEngine.InputSystem.InputBindingCompositeContext@)"/>).
             </summary>
             <param name="context">Callback context for the binding composite. Use this
             to access the values supplied by part bindings.</param>
             <param name="buffer">Buffer that receives the value read for the composite.</param>
             <param name="bufferSize">Size of the buffer allocated at <paramref name="buffer"/>.</param>
             <exception cref="T:System.ArgumentException"><paramref name="bufferSize"/> is smaller than
             <see cref="P:UnityEngine.InputSystem.InputBindingComposite.valueSizeInBytes"/>.</exception>
             <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is <c>null</c>.</exception>
             <remarks>
             This API will be used if someone calls <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>
             with the action leading to the composite.
            
             By deriving from <see cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>, this will automatically
             be implemented for you.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite.ReadValueAsObject(UnityEngine.InputSystem.InputBindingCompositeContext@)">
             <summary>
             Read the value of the composite as a boxed object. This allows reading the value
             without having to know the value type and without having to deal with raw byte buffers.
             </summary>
             <param name="context">Callback context for the binding composite. Use this
             to access the values supplied by part bindings.</param>
             <returns>The current value of the composite according to the state passed in through
             <paramref name="context"/>.</returns>
             <remarks>
             This API will be used if someone calls <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject"/>
             with the action leading to the composite.
            
             By deriving from <see cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>, this will automatically
             be implemented for you.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)">
             <summary>
             Determine the current level of actuation of the composite.
             </summary>
             <param name="context">Callback context for the binding composite. Use this
             to access the values supplied by part bindings.</param>
             <returns></returns>
             <remarks>
             This method by default returns -1, meaning that the composite does not support
             magnitudes. You can override the method to add support for magnitudes.
            
             See <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> for details of how magnitudes
             work.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite.FinishSetup(UnityEngine.InputSystem.InputBindingCompositeContext@)">
             <summary>
             Called after binding resolution for an <see cref="T:UnityEngine.InputSystem.InputActionMap"/> is complete.
             </summary>
             <remarks>
             Some composites do not have predetermine value types. Two examples of this are
             <see cref="T:UnityEngine.InputSystem.Composites.OneModifierComposite"/> and <see cref="T:UnityEngine.InputSystem.Composites.TwoModifiersComposite"/>, which
             both have a <c>"binding"</c> part that can be bound to arbitrary controls. This means that the
             value type of these bindings can only be determined at runtime.
            
             Overriding this method allows accessing the actual controls bound to each part
             at runtime.
            
             <example>
             <code>
             [InputControl] public int binding;
            
             protected override void FinishSetup(ref InputBindingContext context)
             {
                 // Get all controls bound to the 'binding' part.
                 var controls = context.controls
                     .Where(x => x.part == binding)
                     .Select(x => x.control);
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite.GetExpectedControlLayoutName(System.String,System.String)">
             <summary>
             Return the name of the control layout that is expected for the given part (e.g. "Up") on the given
             composite (e.g. "Dpad").
             </summary>
             <param name="composite">Registration name of the composite.</param>
             <param name="part">Name of the part.</param>
             <returns>The layout name (such as "Button") expected for the given part on the composite or null if
             there is no composite with the given name or no part on the composite with the given name.</returns>
             <remarks>
             Expected control layouts can be set on composite parts by setting the <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.layout"/>
             property on them.
             </remarks>
             <example>
             <code>
             InputBindingComposite.GetExpectedControlLayoutName("Dpad", "Up") // Returns "Button"
            
             // This is how Dpad communicates that:
             [InputControl(layout = "Button")] public int up;
             </code>
             </example>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBindingComposite`1">
             <summary>
             A binding composite arranges several bindings such that they form a "virtual control".
             </summary>
             <typeparam name="TValue">Type of value returned by the composite. This must be a "blittable"
             type, that is, a type whose values can simply be copied around.</typeparam>
             <remarks>
             Composite bindings are a special type of <see cref="T:UnityEngine.InputSystem.InputBinding"/>. Whereas normally
             an input binding simply references a set of controls and returns whatever input values are
             generated by those controls, a composite binding sources input from several controls and
             derives a new value from that.
            
             A good example for that is a classic WASD keyboard binding:
            
             <example>
             <code>
             var moveAction = new InputAction(name: "move");
             moveAction.AddCompositeBinding("Vector2")
                 .With("Up", "&lt;Keyboard&gt;/w")
                 .With("Down", "&lt;Keyboard&gt;/s")
                 .With("Left", "&lt;Keyboard&gt;/a")
                 .With("Right", "&lt;Keyboard&gt;/d")
             </code>
             </example>
            
             Here, each direction is represented by a separate binding. "Up" is bound to "W", "Down"
             is bound to "S", and so on. Each direction individually returns a 0 or 1 depending
             on whether it is pressed or not.
            
             However, as a composite, the binding to the "move" action returns a combined <c>Vector2</c>
             that is computed from the state of each of the directional controls. This is what composites
             do. They take inputs from their "parts" to derive an input for the binding as a whole.
            
             Note that the properties and methods defined in <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/> and this
             class will generally be called internally by the input system and are not generally meant
             to be called directly from user land.
            
             The set of composites available in the system is extensible. While some composites are
             such as <see cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/> and <see cref="T:UnityEngine.InputSystem.Composites.ButtonWithOneModifier"/>
             are available out of the box, new composites can be implemented by anyone and simply be
             registered with <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>.
            
             See the "Custom Composite" sample (can be installed from package manager UI) for a detailed example
             of how to create a custom composite.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite``1(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingComposite`1.valueType">
            <summary>
            The type of value returned by the composite, i.e. <c>typeof(TValue)</c>.
            </summary>
            <value>Returns <c>typeof(TValue)</c>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingComposite`1.valueSizeInBytes">
            <summary>
            The size of values returned by the composite, i.e. <c>sizeof(TValue)</c>.
            </summary>
            <value>Returns <c>sizeof(TValue)</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)">
             <summary>
             Read a value for the composite given the supplied context.
             </summary>
             <param name="context">Callback context for the binding composite. Use this
             to access the values supplied by part bindings.</param>
             <returns>The current value of the composite according to the state made
             accessible through <paramref name="context"/>.</returns>
             <remarks>
             This is the main method to implement in custom composites.
            
             <example>
             <code>
             public class CustomComposite : InputBindingComposite&lt;float&gt;
             {
                 [InputControl(layout = "Button")]
                 public int button;
            
                 public float scaleFactor = 1;
            
                 public override float ReadValue(ref InputBindingComposite context)
                 {
                     return context.ReadValue&lt;float&gt;(button) * scaleFactor;
                 }
             }
             </code>
             </example>
            
             The other method to consider overriding is <see cref="M:UnityEngine.InputSystem.InputBindingComposite.EvaluateMagnitude(UnityEngine.InputSystem.InputBindingCompositeContext@)"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@,System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValueAsObject(UnityEngine.InputSystem.InputBindingCompositeContext@)">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.InputAction">
             <summary>
             A named input signal that can flexibly decide which input data to tap.
             </summary>
             <remarks>
             An input action is an abstraction over the source of input(s) it receives. They are
             most useful for representing input as "logical" concepts (e.g. "jump") rather than
             as "physical" inputs (e.g. "space bar on keyboard pressed").
            
             In its most basic form, an action is simply an object along with a collection of
             bindings that trigger the action.
            
             <example>
             <code>
             // A simple action can be created directly using `new`. If desired, a binding
             // can be specified directly as part of construction.
             var action = new InputAction(binding: "&lt;Gamepad&gt;/buttonSouth");
            
             // Additional bindings can be added using `AddBinding`.
             action.AddBinding("&lt;Mouse&gt;/leftButton");
             </code>
             </example>
            
             Bindings use control path expressions to reference controls. See <see cref="T:UnityEngine.InputSystem.InputBinding"/>
             for more details. There may be arbitrary many bindings targeting a single action. The
             list of bindings targeting an action can be obtained through <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.
            
             By itself an action does not do anything until it is enabled:
            
             <example>
             <code>
             action.Enable();
             </code>
             </example>
            
             Once enabled, the action will actively monitor all controls on devices present
             in the system (see <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>) that match any of the binding paths
             associated with the action. If you want to restrict the set of bindings used at runtime
             or restrict the set of devices which controls are chosen from, you can do so using
             <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/> or, if the action is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>,
             by setting the <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/> property of the action map. The
             controls that an action uses can be queried using the <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> property.
            
             When input is received on controls bound to an action, the action will trigger callbacks
             in response. These callbacks are <see cref="E:UnityEngine.InputSystem.InputAction.started"/>, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>, and
             <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>. The callbacks are triggered as part of input system updates
             (see <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>), i.e. they happen before the respective
             <c>MonoBehaviour.Update</c> or <c>MonoBehaviour.FixedUpdate</c> methods
             get executed (depending on which <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/> the system is
             set to).
            
             In what order and how those callbacks get triggered depends on both the <see cref="P:UnityEngine.InputSystem.InputAction.type"/>
             of the action as well as on the interactions (see <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>) present
             on the bindings of the action. The default behavior is that when a control is actuated
             (that is, moving away from its resting position), <see cref="E:UnityEngine.InputSystem.InputAction.started"/> is called and then
             <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>. Subsequently, whenever the a control further changes value to
             anything other than its default value, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> will be called again.
             Finally, when the control moves back to its default value (i.e. resting position),
             <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> is called.
            
             To hook into the callbacks, there are several options available to you. The most obvious
             one is to hook directly into <see cref="E:UnityEngine.InputSystem.InputAction.started"/>, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>, and/or
             <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>. In these callbacks, you will receive a <see cref="T:UnityEngine.InputSystem.InputAction.CallbackContext"/>
             with information about how the action got triggered. For example, you can use <see
             cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/> to read the value from the binding that triggered
             or use <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.interaction"/> to find the interaction that is in progress.
            
             <example>
             <code>
             action.started += context => Debug.Log($"{context.action} started");
             action.performed += context => Debug.Log($"{context.action} performed");
             action.canceled += context => Debug.Log($"{context.action} canceled");
             </code>
             </example>
            
             Alternatively, you can use the <see cref="E:UnityEngine.InputSystem.InputActionMap.actionTriggered"/> callback for
             actions that are part of an action map or the global <see cref="E:UnityEngine.InputSystem.InputSystem.onActionChange"/>
             callback to globally listen for action activity. To simply record action activity instead
             of responding to it directly, you can use <see cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace"/>.
            
             If you prefer to poll an action directly as part of your <c>MonoBehaviour.Update</c>
             or <c>MonoBehaviour.FixedUpdate</c> logic, you can do so using the <see cref="P:UnityEngine.InputSystem.InputAction.triggered"/>
             and <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/> methods.
            
             <example>
             <code>
             protected void Update()
             {
                 // For a button type action.
                 if (action.triggered)
                     /* ... */;
            
                 // For a value type action.
                 // (Vector2 is just an example; pick the value type that is the right
                 // one according to the bindings you have)
                 var v = action.ReadValue&lt;Vector2&gt;();
             }
             </code>
             </example>
            
             Note that actions are not generally frame-based. What this means is that an action
             will observe any value change on its connected controls, even if the control changes
             value multiple times in the same frame. In practice, this means that, for example,
             no button press will get missed.
            
             Actions can be grouped into maps (see <see cref="T:UnityEngine.InputSystem.InputActionMap"/>) which can in turn
             be grouped into assets (see <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>).
            
             Please note that actions are a player-only feature. They are not supported in
             edit mode.
            
             For more in-depth reading on actions, see the <a href="../manual/Actions.html">manual</a>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputActionMap"/>
             <seealso cref="T:UnityEngine.InputSystem.InputActionAsset"/>
             <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.name">
             <summary>
             Name of the action.
             </summary>
             <value>Plain-text name of the action.</value>
             <remarks>
             Can be null for anonymous actions created in code.
            
             If the action is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, it will have a name and the name
             will be unique in the map. The name is just the name of the action alone, not a "mapName/actionName"
             combination.
            
             The name should not contain slashes or dots but can contain spaces and other punctuation.
            
             An action can be renamed after creation using <see cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.Rename(UnityEngine.InputSystem.InputAction,System.String)"/>..
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.type">
             <summary>
             Behavior type of the action.
             </summary>
             <value>General behavior type of the action.</value>
             <remarks>
             Determines how the action gets triggered in response to control value changes.
            
             For details about how the action type affects an action, see <see cref="T:UnityEngine.InputSystem.InputActionType"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.id">
            <summary>
            A stable, unique identifier for the action.
            </summary>
            <value>Unique ID of the action.</value>
            <remarks>
            This can be used instead of the name to refer to the action. Doing so allows referring to the
            action such that renaming the action does not break references.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.expectedControlType">
             <summary>
             Name of control layout expected for controls bound to this action.
             </summary>
             <remarks>
             This is optional and is null by default.
            
             Constraining an action to a particular control layout allows determine the value
             type and expected input behavior of an action without being reliant on any particular
             binding.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.processors">
             <summary>
             Processors applied to every binding on the action.
             </summary>
             <value>Processors added to all bindings on the action.</value>
             <remarks>
             This property is equivalent to appending the same string to the
             <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/> field of every binding that targets
             the action. It is thus simply a means of avoiding the need configure the
             same processor the same way on every binding in case it uniformly applies
             to all of them.
            
             <example>
             <code>
             var action = new InputAction(processors: "scaleVector2(x=2, y=2)");
            
             // Both of the following bindings will implicitly have a
             // ScaleVector2Processor applied to them.
             action.AddBinding("&lt;Gamepad&gt;/leftStick");
             action.AddBinding("&lt;Joystick&gt;/stick");
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
             <seealso cref="T:UnityEngine.InputSystem.InputProcessor"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.interactions">
             <summary>
             Interactions applied to every binding on the action.
             </summary>
             <value>Interactions added to all bindings on the action.</value>
             <remarks>
             This property is equivalent to appending the same string to the
             <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/> field of every binding that targets
             the action. It is thus simply a means of avoiding the need configure the
             same interaction the same way on every binding in case it uniformly applies
             to all of them.
            
             <example>
             <code>
             var action = new InputAction(interactions: "press");
            
             // Both of the following bindings will implicitly have a
             // Press interaction applied to them.
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             action.AddBinding("&lt;Joystick&gt;/trigger");
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
             <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction``1(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.actionMap">
             <summary>
             The map the action belongs to.
             </summary>
             <value><see cref="T:UnityEngine.InputSystem.InputActionMap"/> that the action belongs to or null.</value>
             <remarks>
             If the action is a loose action created in code, this will be <c>null</c>.
            
             <example>
             <code>
             var action1 = new InputAction(); // action1.actionMap will be null
            
             var actionMap = new InputActionMap();
             var action2 = actionMap.AddAction("action"); // action2.actionMap will point to actionMap
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddAction(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.bindingMask">
             <summary>
             An optional mask that determines which bindings of the action to enable and
             which to ignore.
             </summary>
             <value>Optional mask that determines which bindings on the action to enable.</value>
             <remarks>
             Binding masks can be applied at three different levels: for an entire asset through
             <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>, for a specific map through <see
             cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>, and for single actions through this property.
             By default, none of the masks will be set (i.e. they will be <c>null</c>).
            
             When an action is enabled, all the binding masks that apply to it are taken into
             account. Specifically, this means that any given binding on the action will be
             enabled only if it matches the mask applied to the asset, the mask applied
             to the map that contains the action, and the mask applied to the action itself.
             All the masks are individually optional.
            
             Masks are matched against bindings using <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.
            
             Note that if you modify the masks applicable to an action while it is
             enabled, the action's <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> will get updated immediately to
             respect the mask. To avoid repeated binding resolution, it is most efficient
             to apply binding masks before enabling actions.
            
             Binding masks are non-destructive. All the bindings on the action are left
             in place. Setting a mask will not affect the value of the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             property.
            
             <example>
             <code>
             // Create a free-standing action with two bindings, one in the
             // "Keyboard" group and one in the "Gamepad" group.
             var action = new InputAction();
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth", groups: "Gamepad");
             action.AddBinding("&lt;Keyboard&gt;/space", groups: "Keyboard");
            
             // By default, all bindings will be enabled. This means if both
             // a keyboard and gamepad (or several of them) is present, the action
             // will respond to input from all of them.
             action.Enable();
            
             // With a binding mask we can restrict the action to just specific
             // bindings. For example, to only enable the gamepad binding:
             action.bindingMask = InputBinding.MaskByGroup("Gamepad");
            
             // Note that we can mask by more than just by group. Masking by path
             // or by action as well as a combination of these is also possible.
             // We could, for example, mask for just a specific binding path:
             action.bindingMask = new InputBinding()
             {
                 // Select the keyboard binding based on its specific path.
                 path = "&lt;Keyboard&gt;/space"
             };
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.MaskByGroup(System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.bindings">
             <summary>
             The list of bindings associated with the action.
             </summary>
             <value>List of bindings for the action.</value>
             <remarks>
             This list contains all bindings from <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of the action's
             <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/> that reference the action through their <see cref="P:UnityEngine.InputSystem.InputBinding.action"/>
             property.
            
             Note that on the first call, the list may have to be extracted from the action map first which
             may require allocating GC memory. However, once initialized, no further GC allocation hits should occur.
             If the binding setup on the map is changed, re-initialization may be required.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.controls">
             <summary>
             The set of controls to which the action's <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> resolve.
             </summary>
             <value>Controls resolved from the action's <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.</value>
             <remarks>
             This property can be queried whether the action is enabled or not and will return the
             set of controls that match the action's bindings according to the current setup of
             binding masks (<see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>) and device restrictions (<see
             cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>).
            
             Note that internally, controls are not stored on a per-action basis. This means
             that on the first read of this property, the list of controls for just the action
             may have to be extracted which in turn may allocate GC memory. After the first read,
             no further GC allocations should occur except if the set of controls is changed (e.g.
             by changing the binding mask or by adding/removing devices to/from the system).
            
             If the property is queried when the action has not been enabled yet, the system
             will first resolve controls on the action (and for all actions in the map and/or
             the asset). See <a href="../manual/ActionBindings.html#binding-resolution">Binding Resolution</a>
             in the manual for details.
            
             To map a control in this array to an index into <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>, use
             <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndexForControl(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)"/>.
            
             <example>
             <code>
             // Map control list to binding indices.
             var bindingIndices = myAction.controls.Select(c => myAction.GetBindingIndexForControl(c));
             </code>
             </example>
            
             Note that this array will not contain the same control multiple times even if more than
             one binding on an action references the same control.
            
             <example>
             <code>
             var action1 = new InputAction();
             action1.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             action1.AddBinding("&lt;Gamepad&gt;/buttonSouth"); // This binding will be ignored.
            
             // Contains only one instance of buttonSouth which is associated
             // with the first binding (at index #0).
             var action1Controls = action1.controls;
            
             var action2 = new InputAction();
             action2.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             // Add a binding that implicitly matches the first binding, too. When binding resolution
             // happens, this binding will only receive buttonNorth, buttonWest, and buttonEast, but not
             // buttonSouth as the first binding already received that control.
             action2.AddBinding("&lt;Gamepad&gt;/button*");
            
             // Contains only all four face buttons (buttonSouth, buttonNorth, buttonEast, buttonWest)
             // but buttonSouth is associated with the first button and only buttonNorth, buttonEast,
             // and buttonWest are associated with the second binding.
             var action2Controls = action2.controls;
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndexForControl(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.phase">
             <summary>
             The current phase of the action.
             </summary>
             <remarks>
             When listening for control input and when responding to control value changes,
             actions will go through several possible phases.
            
             In general, when an action starts receiving input, it will go to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
             and when it stops receiving input, it will go to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>.
             When <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> is used depends primarily on the type
             of action. <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> will trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
             whenever the value of the control changes (including the first time; i.e. it will first
             trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> and then <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
             right after) whereas <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> will trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
             as soon as the button press threshold (<see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>)
             has been crossed.
            
             Note that both interactions and the action <see cref="P:UnityEngine.InputSystem.InputAction.type"/> can affect the phases
             that an action goes through. <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> actions will
             only ever use <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> and not go to <see
             cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/> (as
             pass-through actions do not follow the start-performed-canceled model in general).
             Also, interactions can choose their
            
             While an action is disabled, its phase is <see cref="F:UnityEngine.InputSystem.InputActionPhase.Disabled"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.inProgress">
            <summary>
            True if the action is currently in <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
            phase. False in all other cases.
            </summary>
            <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.enabled">
            <summary>
            Whether the action is currently enabled, i.e. responds to input, or not.
            </summary>
            <value>True if the action is currently enabled.</value>
            <remarks>
            An action is enabled by either calling <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/> on it directly or by calling
            <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/> on the <see cref="T:UnityEngine.InputSystem.InputActionMap"/> containing the action.
            When enabled, an action will listen for changes on the controls it is bound to and trigger
            callbacks such as <see cref="E:UnityEngine.InputSystem.InputAction.started"/>, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>, and <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
            in response.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.ListEnabledActions"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputAction.started">
            <summary>
            Event that is triggered when the action has been started.
            </summary>
            <remarks>
            See <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> for details of how an action progresses through phases
            and triggers this callback.
            </remarks>
            <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputAction.canceled">
            <summary>
            Event that is triggered when the action has been <see cref="E:UnityEngine.InputSystem.InputAction.started"/>
            but then canceled before being fully <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>.
            </summary>
            <remarks>
            See <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> for details of how an action progresses through phases
            and triggers this callback.
            </remarks>
            <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputAction.performed">
            <summary>
            Event that is triggered when the action has been fully performed.
            </summary>
            <remarks>
            See <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> for details of how an action progresses through phases
            and triggers this callback.
            </remarks>
            <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.triggered">
            <summary>
            Equivalent to <see cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/>.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.activeControl">
            <summary>
            The currently active control that is driving the action. Null while the action
            is in waiting (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>) or canceled (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>)
            state. Otherwise the control that last had activity on it which wasn't ignored.
            </summary>
            <remarks>
            Note that the control's value does not necessarily correspond to the value of the
            action (<see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>) as the control may be part of a composite.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.control"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.wantsInitialStateCheck">
             <summary>
             Whether the action wants a state check on its bound controls as soon as it is enabled. This is always
             true for <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> actions but can optionally be enabled for <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/>
             or <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> actions.
             </summary>
             <remarks>
             Usually, when an action is <see cref="P:UnityEngine.InputSystem.InputAction.enabled"/> (e.g. via <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/>), it will start listening for input
             and then trigger once the first input arrives. However, <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> bound to an action may already be
             actuated when an action is enabled. For example, if a "jump" action is bound to <see cref="P:UnityEngine.InputSystem.Keyboard.spaceKey"/>,
             the space bar may already be pressed when the jump action is enabled.
            
             <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> actions handle this differently by immediately performing an "initial state check"
             in the next input update (see <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>) after being enabled. If any of the bound controls
             is already actuated, the action will trigger right away -- even with no change in state on the controls.
            
             This same behavior can be enabled explicitly for <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/>
             actions using this property.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
             <seealso cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.#ctor">
             <summary>
             Construct an unnamed, free-standing action that is not part of any map or asset
             and has no bindings. Bindings can be added with <see
             cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String,System.String)"/>.
             The action type defaults to <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>.
             </summary>
             <remarks>
             The action will not have an associated <see cref="T:UnityEngine.InputSystem.InputActionMap"/> and <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/>
             will thus be <c>null</c>. Use <see cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddAction(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String,System.String)"/> instead if
             you want to add a new action to an action map.
            
             The action will remain disabled after construction and thus not listen/react to input yet.
             Use <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/> to enable the action.
            
             <example>
             <code>
             // Create an action with two bindings.
             var action = new InputAction();
             action.AddBinding("&lt;Gamepad&gt;/leftStick");
             action.AddBinding("&lt;Mouse&gt;/delta");
            
             action.performed += ctx => Debug.Log("Value: " + ctx.ReadValue&lt;Vector2&gt;());
            
             action.Enable();
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.#ctor(System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String)">
             <summary>
             Construct a free-standing action that is not part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
             </summary>
             <param name="name">Name of the action. If null or empty, the action will be unnamed.</param>
             <param name="type">Type of action to create. Defaults to <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>, i.e.
             an action that provides continuous values.</param>
             <param name="binding">If not null or empty, a binding with the given path will be added to the action
             right away. The format of the string is the as for <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.</param>
             <param name="interactions">If <paramref name="binding"/> is not null or empty, this parameter represents
             the interaction to apply to the newly created binding (i.e. <see cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>). If
             <paramref name="binding"/> is not supplied, this parameter represents the interactions to apply to the action
             (i.e. the value of <see cref="P:UnityEngine.InputSystem.InputAction.interactions"/>).</param>
             <param name="processors">If <paramref name="binding"/> is not null or empty, this parameter represents
             the processors to apply to the newly created binding (i.e. <see cref="P:UnityEngine.InputSystem.InputBinding.processors"/>). If
             <paramref name="binding"/> is not supplied, this parameter represents the processors to apply to the
             action (i.e. the value of <see cref="P:UnityEngine.InputSystem.InputAction.processors"/>).</param>
             <param name="expectedControlType">The optional expected control type for the action (i.e. <see
             cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/>).</param>
             <remarks>
             The action will not have an associated <see cref="T:UnityEngine.InputSystem.InputActionMap"/> and <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/>
             will thus be <c>null</c>. Use <see cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddAction(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.InputActionType,System.String,System.String,System.String,System.String,System.String)"/> instead if
             you want to add a new action to an action map.
            
             The action will remain disabled after construction and thus not listen/react to input yet.
             Use <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/> to enable the action.
            
             Additional bindings can be added with <see
             cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddBinding(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String,System.String)"/>.
            
             <example>
             <code>
             // Create a button action responding to the gamepad A button.
             var action = new InputAction(type: InputActionType.Button, binding: "&lt;Gamepad&gt;/buttonSouth");
             action.performed += ctx => Debug.Log("Pressed");
             action.Enable();
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.Dispose">
             <summary>
             Release internal state held on to by the action.
             </summary>
             <remarks>
             Once enabled, actions will allocate a block of state internally that they will hold on to
             until disposed of. For free-standing actions, that state is private to just the action.
             For actions that are part of <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s, the state is shared by all
             actions in the map and, if the map itself is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>,
             also by all the maps that are part of the asset.
            
             Note that the internal state holds on to GC heap memory as well as memory from the
             unmanaged, C++ heap.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.ToString">
            <summary>
            Return a string version of the action. Mainly useful for debugging.
            </summary>
            <returns>A string version of the action.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.Enable">
             <summary>
             Enable the action such that it actively listens for input and runs callbacks
             in response.
             </summary>
             <remarks>
             If the action is already enabled, this method does nothing.
            
             By default, actions start out disabled, i.e. with <see cref="P:UnityEngine.InputSystem.InputAction.enabled"/> being false.
             When enabled, two things happen.
            
             First, if it hasn't already happened, an action will resolve all of its bindings
             to <see cref="T:UnityEngine.InputSystem.InputControl"/>s. This also happens if, since the action was last enabled,
             the setup of devices in the system has changed such that it may impact the action.
            
             Second, for all the <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> bound to an action, change monitors (see
             <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateChangeMonitor"/>) will be added to the system. If any of the
             controls changes state in the future, the action will get notified and respond.
            
             <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> type actions will also perform an initial state
             check in the input system update following the call to Enable. This means that if
             any of the bound controls are already actuated and produce a non-<c>default</c> value,
             the action will immediately trigger in response.
            
             Note that this method only enables a single action. This is also allowed for action
             that are part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>. To enable all actions in a map,
             call <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>.
            
             The <see cref="T:UnityEngine.InputSystem.InputActionMap"/> associated with an action (if any), will immediately
             toggle to being enabled (see <see cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>) as soon as the first
             action in the map is enabled and for as long as any action in the map is still enabled.
            
             The first time an action is enabled, it will allocate a block of state internally that it
             will hold on to until disposed of. For free-standing actions, that state is private to
             just the action. For actions that are part of <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s, the state
             is shared by all actions in the map and, if the map itself is part of an <see
             cref="T:UnityEngine.InputSystem.InputActionAsset"/>, also by all the maps that are part of the asset.
            
             To dispose of the state, call <see cref="M:UnityEngine.InputSystem.InputAction.Dispose"/>.
            
             <example>
             <code>
             var gamepad = InputSystem.AddDevice&lt;Gamepad&gt;();
            
             var action = new InputAction(type: InputActionType.Value, binding: "&lt;Gamepad&gt;/leftTrigger");
             action.performed = ctx => Debug.Log("Action triggered!");
            
             // Perform some fake input on the gamepad. Note that the action
             // will *NOT* get triggered as it is not enabled.
             // NOTE: We use Update() here only for demonstration purposes. In most cases,
             //       it's not a good method to call directly as it basically injects artificial
             //       input frames into the player loop. Usually a recipe for breakage.
             InputSystem.QueueStateEvent(gamepad, new GamepadState { leftTrigger = 0.5f });
             InputSystem.Update();
            
             action.Enable();
            
             // Now, with the left trigger already being down and the action enabled, it will
             // trigger in the next frame.
             InputSystem.Update();
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.Disable">
             <summary>
             Disable the action such that is stop listening/responding to input.
             </summary>
             <remarks>
             If the action is already disabled, this method does nothing.
            
             If the action is currently in progress, i.e. if <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> is
             <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>, the action will be canceled as
             part of being disabled. This means that you will see a call on <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
             from within the call to <c>Disable()</c>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.Clone">
             <summary>
             Return an identical instance of the action.
             </summary>
             <returns>An identical clone of the action</returns>
             <remarks>
             Note that if you clone an action that is part of an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>,
             you will not get a new action that is part of the same map. Instead, you will
             get a free-standing action not associated with any action map.
            
             Also, note that the <see cref="P:UnityEngine.InputSystem.InputAction.id"/> of the action is not cloned. Instead, the
             clone will receive a new unique ID. Also, callbacks install on events such
             as <see cref="E:UnityEngine.InputSystem.InputAction.started"/> will not be copied over to the clone.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.System#ICloneable#Clone">
            <summary>
            Return an boxed instance of the action.
            </summary>
            <returns>An boxed clone of the action</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Clone"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.ReadValue``1">
             <summary>
             Read the current value of the control that is driving this action. If no bound control is actuated, returns
             default(TValue), but note that binding processors are always applied.
             </summary>
             <typeparam name="TValue">Value type to read. Must match the value type of the binding/control that triggered.</typeparam>
             <returns>The current value of the control/binding that is driving this action with all binding processors applied.</returns>
             <remarks>
             This method can be used as an alternative to hooking into <see cref="E:UnityEngine.InputSystem.InputAction.started"/>, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>,
             and/or <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> and reading out the value using <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>
             there. Instead, this API acts more like a polling API that can be called, for example, as part of
             <c>MonoBehaviour.Update</c>.
            
             <example>
             <code>
             // Let's say you have a MyControls.inputactions file with "Generate C# Class" enabled
             // and it has an action map called "gameplay" with a "move" action of type Vector2.
             public class MyBehavior : MonoBehaviour
             {
                 public MyControls controls;
                 public float moveSpeed = 4;
            
                 protected void Awake()
                 {
                     controls = new MyControls();
                 }
            
                 protected void OnEnable()
                 {
                     controls.gameplay.Enable();
                 }
            
                 protected void OnDisable()
                 {
                     controls.gameplay.Disable();
                 }
            
                 protected void Update()
                 {
                     var moveVector = controls.gameplay.move.ReadValue&lt;Vector2&gt;() * (moveSpeed * Time.deltaTime);
                     //...
                 }
             }
             </code>
             </example>
            
             If the action has button-like behavior, then <see cref="P:UnityEngine.InputSystem.InputAction.triggered"/> is usually a better alternative to
             reading out a float and checking if it is above the button press point.
             </remarks>
             <exception cref="T:System.InvalidOperationException">The given <typeparamref name="TValue"/> type does not match
             the value type of the control or composite currently driving the action.</exception>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.triggered"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValueAsObject"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.ReadValueAsObject">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/> but read the value without having to know the value type
            of the action.
            </summary>
            <returns>The current value of the action or <c>null</c> if the action is not currently in <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
            or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> phase.</returns>
            <remarks>
            This method allocates GC memory and is thus not a good choice for getting called as part of gameplay
            logic.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.Reset">
             <summary>
             Reset the action state to default.
             </summary>
             <remarks>
             This method can be used to forcibly cancel an action even while it is in progress. Note that unlike
             disabling an action, for example, this also effects APIs such as <see cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/>.
            
             Note that invoking this method will not modify enabled state.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.inProgress"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.IsPressed">
             <summary>
             Check whether the current actuation of the action has crossed the button press threshold (see
             <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>) and has not yet fallen back below the
             release threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.buttonReleaseThreshold"/>).
             </summary>
             <returns>True if the action is considered to be in "pressed" state, false otherwise.</returns>
             <remarks>
             This method is different from simply reading the action's current <c>float</c> value and comparing
             it to the press threshold and is also different from comparing the current actuation of
             <see cref="P:UnityEngine.InputSystem.InputAction.activeControl"/> to it. This is because the current level of actuation might have already
             fallen below the press threshold but might not yet have reached the release threshold.
            
             This method works with any <see cref="P:UnityEngine.InputSystem.InputAction.type"/> of action, not just buttons.
            
             Also note that because this operates on the results of <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>,
             it works with many kind of controls, not just buttons. For example, if an action is bound
             to a <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/>, the control will be considered "pressed" once the magnitude
             of the Vector2 of the control has crossed the press threshold.
            
             Finally, note that custom button press points of controls (see <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>)
             are respected and will take precedence over <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            
             <example>
             <code>
             var up = playerInput.actions["up"];
             if (up.IsPressed())
                transform.Translate(0, 10 * Time.deltaTime, 0);
             </code>
             </example>
            
             Disabled actions will always return false from this method, even if a control bound to the action
             is currently pressed. Also, re-enabling an action will not restore the state to when the action
             was disabled even if the control is still actuated.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
             <seealso cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsButton"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasReleasedThisFrame"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.IsInProgress">
            <summary>
            Whether the action has been <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
            </summary>
            <returns>True if the action is currently triggering.</returns>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame">
             <summary>
             Returns true if the action's value crossed the press threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>)
             at any point in the frame.
             </summary>
             <returns>True if the action was pressed this frame.</returns>
             <remarks>
             This method is different from <see cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/> in that it is not bound
             to <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>. Instead, if the action's level of actuation (that is, the level of
             magnitude -- see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> -- of the control(s) bound
             to the action) crossed the press threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>)
             at any point in the frame, this method will return true. It will do so even if there is an
             interaction on the action that has not yet performed the action in response to the press.
            
             This method works with any <see cref="P:UnityEngine.InputSystem.InputAction.type"/> of action, not just buttons.
            
             Also note that because this operates on the results of <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>,
             it works with many kind of controls, not just buttons. For example, if an action is bound
             to a <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/>, the control will be considered "pressed" once the magnitude
             of the Vector2 of the control has crossed the press threshold.
            
             Finally, note that custom button press points of controls (see <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>)
             are respected and will take precedence over <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            
             <example>
             <code>
             var fire = playerInput.actions["fire"];
             if (fire.WasPressedThisFrame() &amp;&amp; fire.IsPressed())
                 StartFiring();
             else if (fire.WasReleasedThisFrame())
                 StopFiring();
             </code>
             </example>
            
             This method will disregard whether the action is currently enabled or disabled. It will keep returning
             true for the duration of the frame even if the action was subsequently disabled in the frame.
            
             The meaning of "frame" is either the current "dynamic" update (<c>MonoBehaviour.Update</c>) or the current
             fixed update (<c>MonoBehaviour.FixedUpdate</c>) depending on the value of the <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/> setting.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.IsPressed"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasReleasedThisFrame"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsButton"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.WasReleasedThisFrame">
             <summary>
             Returns true if the action's value crossed the release threshold (see <see cref="P:UnityEngine.InputSystem.InputSettings.buttonReleaseThreshold"/>)
             at any point in the frame after being in pressed state.
             </summary>
             <returns>True if the action was released this frame.</returns>
             <remarks>
             This method works with any <see cref="P:UnityEngine.InputSystem.InputAction.type"/> of action, not just buttons.
            
             Also note that because this operates on the results of <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>,
             it works with many kind of controls, not just buttons. For example, if an action is bound
             to a <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/>, the control will be considered "pressed" once the magnitude
             of the Vector2 of the control has crossed the press threshold.
            
             Finally, note that custom button press points of controls (see <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>)
             are respected and will take precedence over <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            
             <example>
             <code>
             var fire = playerInput.actions["fire"];
             if (fire.WasPressedThisFrame() &amp;&amp; fire.IsPressed())
                 StartFiring();
             else if (fire.WasReleasedThisFrame())
                 StopFiring();
             </code>
             </example>
            
             This method will disregard whether the action is currently enabled or disabled. It will keep returning
             true for the duration of the frame even if the action was subsequently disabled in the frame.
            
             The meaning of "frame" is either the current "dynamic" update (<c>MonoBehaviour.Update</c>) or the current
             fixed update (<c>MonoBehaviour.FixedUpdate</c>) depending on the value of the <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/> setting.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.IsPressed"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsButton"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.WasPerformedThisFrame">
             <summary>
             Check whether <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> was <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> at any point
             in the current frame.
             </summary>
             <returns>True if the action performed this frame.</returns>
             <remarks>
             This method is different from <see cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/> in that it depends directly on the
             interaction(s) driving the action (including the default interaction if no specific interaction
             has been added to the action or binding).
            
             For example, let's say the action is bound to the space bar and that the binding has a
             <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> assigned to it. In the frame where the space bar
             is pressed, <see cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/> will be true (because the button/key is now pressed)
             but <c>WasPerformedThisFrame</c> will still be false (because the hold has not been performed yet).
             Only after the hold time has expired will <c>WasPerformedThisFrame</c> be true and only in the frame
             where the hold performed.
            
             This is different from checking <see cref="P:UnityEngine.InputSystem.InputAction.phase"/> directly as the action might have already progressed
             to a different phase after performing. In other words, even if an action performed in a frame, <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>
             might no longer be <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>, whereas <c>WasPerformedThisFrame</c> will remain
             true for the entirety of the frame regardless of what else the action does.
            
             Unlike <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>, which will reset when the action goes back to waiting
             state, this property will stay true for the duration of the current frame (that is, until the next
             <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> runs) as long as the action was triggered at least once.
            
             <example>
             <code>
             var warp = playerInput.actions["Warp"];
             if (warp.WasPerformedThisFrame())
                 InitiateWarp();
             </code>
             </example>
            
             This method will disregard whether the action is currently enabled or disabled. It will keep returning
             true for the duration of the frame even if the action was subsequently disabled in the frame.
            
             The meaning of "frame" is either the current "dynamic" update (<c>MonoBehaviour.Update</c>) or the current
             fixed update (<c>MonoBehaviour.FixedUpdate</c>) depending on the value of the <see cref="P:UnityEngine.InputSystem.InputSettings.updateMode"/> setting.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.GetTimeoutCompletionPercentage">
             <summary>
             Return the completion percentage of the timeout (if any) running on the current interaction.
             </summary>
             <returns>A value &gt;= 0 (no progress) and &lt;= 1 (finished) indicating the level of completion
             of the currently running timeout.</returns>
             <remarks>
             This method is useful, for example, when providing UI feedback for an ongoing action. If, say,
             you have a <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> on a binding, you might want to show a
             progress indicator in the UI and need to know how far into the hold the action
             current is. Once the hold has been started, this method will return how far into the hold
             the action currently is.
            
             Note that if an interaction performs and stays performed (see <see cref="M:UnityEngine.InputSystem.InputInteractionContext.PerformedAndStayPerformed"/>),
             the completion percentage will remain at 1 until the interaction is canceled.
            
             Also note that completion is based on the progression of time and not dependent on input
             updates. This means that if, for example, the timeout for a <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/>
             has expired according the current time but the expiration has not yet been processed by
             an input update (thus causing the hold to perform), the returned completion percentage
             will still be 1. In other words, there isn't always a correlation between the current
             completion percentage and <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>.
            
             The meaning of the timeout is dependent on the interaction in play. For a <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/>,
             the timeout represents "completion" (that is, the time until a "hold" is considered to be performed), whereas
             for a <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/> it represents "time to failure" (that is, the remaining time window
             that the interaction can be completed within).
            
             Note that an interaction might run multiple timeouts in succession. One such example is <see cref="T:UnityEngine.InputSystem.Interactions.MultiTapInteraction"/>.
             In this case, progression towards a single timeout does not necessarily mean progression towards completion
             of the whole interaction. An interaction can call <see cref="M:UnityEngine.InputSystem.InputInteractionContext.SetTotalTimeoutCompletionTime(System.Single)"/>
             to inform the Input System of the total length of timeouts to run. If this is done, the result of the
             <c>GetTimeoutCompletionPercentage</c> method will return a value reflecting the progression with respect
             to total time.
            
             <example>
             <code>
             // Scale a UI element in response to the completion of a hold on the gamepad's A button.
            
             Transform uiObjectToScale;
            
             InputAction holdAction;
            
             void OnEnable()
             {
                 if (holdAction == null)
                 {
                     // Create hold action with a 2 second timeout.
                     // NOTE: Here we create the action in code. You can, of course, grab the action from an .inputactions
                     //       asset created in the editor instead.
                     holdAction = new InputAction(type: InputActionType.Button, interactions: "hold(duration=2)");
            
                     // Show the UI object when the hold starts and hide it when it ends.
                     holdAction.started += _ =&gt; uiObjectToScale.SetActive(true);
                     holdAction.canceled += _ =&gt; uiObjectToScale.SetActive(false);
            
                     // If you want to play a visual effect when the action performs, you can initiate from
                     // the performed callback.
                     holdAction.performed += _ =&gt; /* InitiateVisualEffectWhenHoldIsComplete() */;
                 }
            
                 holdAction.Enable();
            
                 // Hide the UI object until the action is started.
                 uiObjectToScale.gameObject.SetActive(false);
             }
            
             void OnDisable()
             {
                 holdAction.Disable();
             }
            
             void Update()
             {
                 var completion = holdAction.GetTimeoutCompletionPercentage();
                 uiObjectToScale.localScale = new Vector3(1, completion, 1);
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.IInputInteraction"/>
             <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.SetTimeout(System.Single)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.SetTotalTimeoutCompletionTime(System.Single)"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputAction.m_ActionIndexInState">
            <summary>
            Index of the action in the <see cref="T:UnityEngine.InputSystem.InputActionState"/> associated with the
            action's <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.
            </summary>
            <remarks>
            This is not necessarily the same as the index of the action in its map.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.actionMap"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputAction.m_ActionMap">
            <summary>
            The action map that owns the action.
            </summary>
            <remarks>
            This is not serialized. The action map will restore this back references after deserialization.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.isSingletonAction">
            <summary>
            Whether the action is a loose action created in code (e.g. as a property on a component).
            </summary>
            <remarks>
            Singleton actions are not contained in maps visible to the user. Internally, we do create
            a map for them that contains just the singleton action. To the action system, there are no
            actions without action maps.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputAction.CallbackContext">
            <summary>
            Information provided to action callbacks about what triggered an action.
            </summary>
            <remarks>
            This struct should not be held on to past the duration of the callback.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.performed"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.started"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.canceled"/>
            <seealso cref="E:UnityEngine.InputSystem.InputActionMap.actionTriggered"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.phase">
            <summary>
            Current phase of the action. Equivalent to accessing <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>
            on <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.action"/>.
            </summary>
            <value>Current phase of the action.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.started"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.performed"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.canceled"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.started">
            <summary>
            Whether the <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.action"/> has just been started.
            </summary>
            <value>If true, the action was just started.</value>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.performed">
            <summary>
            Whether the <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.action"/> has just been performed.
            </summary>
            <value>If true, the action was just performed.</value>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.canceled">
            <summary>
            Whether the <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.action"/> has just been canceled.
            </summary>
            <value>If true, the action was just canceled.</value>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.action">
            <summary>
            The action that got triggered.
            </summary>
            <value>Action that got triggered.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.control">
             <summary>
             The control that triggered the action.
             </summary>
             <value>Control that triggered the action.</value>
             <remarks>
             In case of a composite binding, this is the control of the composite that activated the
             composite as a whole. For example, in case of a WASD-style binding, it could be the W key.
            
             Note that an action may also change its <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.phase"/> in response to a timeout.
             For example, a <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/> will cancel itself if the
             button control is not released within a certain time. When this happens, the <c>control</c>
             property will be the control that last fed input into the action.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.controls"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.interaction">
            <summary>
            The interaction that triggered the action or <c>null</c> if the binding that triggered does not
            have any particular interaction set on it.
            </summary>
            <value>Interaction that triggered the callback.</value>
            <remarks>
            <example>
            <code>
            void FirePerformed(InputAction.CallbackContext context)
            {
                // If SlowTap interaction was performed, perform a charged
                // firing. Otherwise, fire normally.
                if (context.interaction is SlowTapInteraction)
                    FireChargedProjectile();
                else
                    FireNormalProjectile();
            }
            </code>
            </example>
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.interactions"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.time">
            <summary>
            The time at which the action got triggered.
            </summary>
            <value>Time relative to <c>Time.realtimeSinceStartup</c> at which
            the action got triggered.</value>
            <remarks>
            This is usually determined by the timestamp of the input event that activated a control
            bound to the action. What this means is that this is normally <em>not</em> the
            value of <c>Time.realtimeSinceStartup</c> when the input system calls the
            callback but rather the time at which the input was generated that triggered
            the action.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.startTime">
             <summary>
             Time at which the action was started.
             </summary>
             <value>Value relative to <c>Time.realtimeSinceStartup</c> when the action
             changed to <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.started"/>.</value>
             <remarks>
             This is only relevant for actions that go through distinct a <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
             cycle as driven by <see cref="T:UnityEngine.InputSystem.IInputInteraction">interactions</see>.
            
             The value of this property is that of <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.time"/> when <see
             cref="E:UnityEngine.InputSystem.InputAction.started"/> was called. See the <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.time"/>
             property for how the timestamp works.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.duration">
             <summary>
             Time difference between <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.time"/> and <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.startTime"/>.
             </summary>
             <value>Difference between <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.time"/> and <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.startTime"/>.</value>
             <remarks>
             This property can be used, for example, to determine how long a button
             was held down.
            
             <example>
             <code>
             // Let's create a button action bound to the A button
             // on the gamepad.
             var action = new InputAction(
                 type: InputActionType.Button,
                 binding: "&lt;Gamepad&gt;/buttonSouth");
            
             // When the action is performed (which will happen when the
             // button is pressed and then released) we take the duration
             // of the press to determine how many projectiles to spawn.
             action.performed +=
                 context =>
                 {
                     const float kSpawnRate = 3; // 3 projectiles per second
                     var projectileCount = kSpawnRate * context.duration;
                     for (var i = 0; i &lt; projectileCount; ++i)
                     {
                         var projectile = UnityEngine.Object.Instantiate(projectile);
                         // Apply other changes to the projectile...
                     }
                 };
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.valueType">
             <summary>
             Type of value returned by <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject"/> and expected
             by <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>.
             </summary>
             <value>Type of object returned when reading a value.</value>
             <remarks>
             The type of value returned by an action is usually determined by the
             <see cref="T:UnityEngine.InputSystem.InputControl"/> that triggered the action, i.e. by the
             control referenced from <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.control"/>.
            
             However, if the binding that triggered is a composite, then the composite
             will determine values and not the individual control that triggered (that
             one just feeds values into the composite).
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.valueType"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBindingComposite.valueType"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputAction.CallbackContext.valueSizeInBytes">
             <summary>
             Size of values returned by <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>.
             </summary>
             <value>Size of value returned when reading.</value>
             <remarks>
             All input values passed around by the system are required to be "blittable",
             i.e. they cannot contain references, cannot be heap objects themselves, and
             must be trivially mem-copyable. This means that any value can be read out
             and retained in a raw byte buffer.
            
             The value of this property determines how many bytes will be written
             by <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBindingComposite.valueSizeInBytes"/>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)">
            <summary>
            Read the value of the action as a raw byte buffer. This allows reading
            values without having to know value types but also, unlike <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject"/>,
            without allocating GC heap memory.
            </summary>
            <param name="buffer">Memory buffer to read the value into.</param>
            <param name="bufferSize">Size of buffer allocated at <paramref name="buffer"/>. Must be
            at least <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.valueSizeInBytes"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="bufferSize"/> is too small.</exception>
            <remarks>
            <example>
            <code>
            // Read a Vector2 using the raw memory ReadValue API.
            // Here we just read into a local variable which we could
            // just as well (and more easily) do using ReadValue&lt;Vector2&gt;.
            // Still, it serves as a demonstration for how the API
            // operates in general.
            unsafe
            {
                var value = default(Vector2);
                var valuePtr = UnsafeUtility.AddressOf(ref value);
                context.ReadValue(buffer, UnsafeUtility.SizeOf&lt;Vector2&gt;());
            }
            </code>
            </example>
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueIntoBuffer(UnityEngine.InputSystem.InputControl,System.Void*,System.Int32)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1">
            <summary>
            Read the value of the action.
            </summary>
            <typeparam name="TValue">Type of value to read. This must correspond to the
            expected by either <see cref="P:UnityEngine.InputSystem.InputAction.CallbackContext.control"/> or, if it is a composite, by the
            <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/> in use.</typeparam>
            <returns>The value read from the action.</returns>
            <exception cref="T:System.InvalidOperationException">The given type <typeparamref name="TValue"/>
            does not match the value type expected by the control or binding composite.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue(System.Void*,System.Int32)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsButton">
            <summary>
            Read the current value of the action as a <c>float</c> and return true if it is equal to
            or greater than the button press threshold.
            </summary>
            <returns>True if the action is considered in "pressed" state, false otherwise.</returns>
            <remarks>
            If the currently active control is a <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>, the <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
            of the button will be taken into account (if set). If there is no custom button press point, the
            global <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> will be used.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
            <seealso cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValueAsObject">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/> except that it is not necessary to
            know the type of value at compile time.
            </summary>
            <returns>The current value from the binding that triggered the action or <c>null</c> if the action
            is not currently in progress.</returns>
            <remarks>
            This method allocates GC heap memory. Using it during normal gameplay will lead
            to frame-rate instabilities.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.CallbackContext.ReadValue``1"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.ReadValueAsObject"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputAction.CallbackContext.ToString">
            <summary>
            Return a string representation of the context useful for debugging.
            </summary>
            <returns>String representation of the context.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState">
             <summary>
             Dynamic execution state of one or more <see cref="T:UnityEngine.InputSystem.InputActionMap">action maps</see> and
             all the actions they contain.
             </summary>
             <remarks>
             The aim of this class is to both put all the dynamic execution state into one place as well
             as to organize state in tight, GC-optimized arrays. Also, by moving state out of individual
             <see cref="T:UnityEngine.InputSystem.InputActionMap">action maps</see>, we can combine the state of several maps
             into one single object with a single set of arrays. Ideally, if you have a single action
             asset in the game, you get a single InputActionState that contains the entire dynamic
             execution state for your game's actions.
            
             Note that this class allocates unmanaged memory. It has to be disposed of or it will leak
             memory!
            
             An instance of this class is also used for singleton actions by means of the hidden action
             map we create for those actions. In that case, there will be both a hidden map instance
             as well as an action state for every separate singleton action. This makes singleton actions
             relatively expensive.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.maps">
            <summary>
            Array of all maps added to the state.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.controls">
             <summary>
             List of all resolved controls.
             </summary>
             <remarks>
             As we don't know in advance how many controls a binding may match (if any), we bump the size of
             this array in increments during resolution. This means it may be end up being larger than the total
             number of used controls and have empty entries at the end. Use <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.controlCount"/> and not
             <c>.Length</c> to find the actual number of controls.
            
             All bound controls are included in the array regardless of whether only a partial set of actions
             is currently enabled. What ultimately decides whether controls get triggered or not is whether we
             have installed state monitors for them or not.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.interactions">
             <summary>
             Array of instantiated interaction objects.
             </summary>
             <remarks>
             Every binding that has interactions corresponds to a slice of this array.
            
             Indices match between this and interaction states in <see cref="F:UnityEngine.InputSystem.InputActionState.memory"/>.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.processors">
            <summary>
            Processor objects instantiated for the bindings in the state.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.composites">
            <summary>
            Array of instantiated composite objects.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.memory">
            <summary>
            Block of unmanaged memory that holds the dynamic execution state of the actions and their controls.
            </summary>
            <remarks>
            We keep several arrays of structured data in a single block of unmanaged memory.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.Initialize(UnityEngine.InputSystem.InputBindingResolver)">
            <summary>
            Initialize execution state with given resolved binding information.
            </summary>
            <param name="resolver"></param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.Clone">
            <summary>
            Create a copy of the state.
            </summary>
            <returns></returns>
            <remarks>
            The copy is non-functional in so far as it cannot be used to keep track of changes made to
            any associated actions. However, it can be used to freeze the binding resolution state of
            a particular set of enabled actions. This is used by <see cref="T:UnityEngine.InputSystem.Utilities.InputActionTrace"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.IsUsingDevice(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Check if the state is currently using a control from the given device.
            </summary>
            <param name="device">Any input device.</param>
            <returns>True if any of the maps in the state has the device in its <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>
            list or if any of the device's controls are contained in <see cref="F:UnityEngine.InputSystem.InputActionState.controls"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.HasEnabledActions">
            <summary>
            Check whether the state has any actions that are currently enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.RestoreActionStatesAfterReResolvingBindings(UnityEngine.InputSystem.InputActionState.UnmanagedMemory,UnityEngine.InputSystem.InputControlList{UnityEngine.InputSystem.InputControl},System.Boolean)">
             <summary>
             Synchronize the current action states based on what they were before.
             </summary>
             <param name="oldState"></param>
             <remarks>
             We do this when we have to temporarily disable actions in order to re-resolve bindings.
            
             Note that we do NOT restore action states perfectly. I.e. will we will not preserve trigger
             and interaction states exactly to what they were before. Given that the bound controls may change,
             it would be non-trivial to reliably correlate the old and the new state. Instead, we simply
             reenable all the actions and controls that were enabled before and then let the next update
             take it from there.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ResetActionState(System.Int32,UnityEngine.InputSystem.InputActionPhase,System.Boolean)">
            <summary>
            Reset the trigger state of the given action such that the action has no record of being triggered.
            </summary>
            <param name="actionIndex">Action whose state to reset.</param>
            <param name="toPhase">Phase to reset the action to. Must be either <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>
            or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Disabled"/>. Other phases cannot be transitioned to through resets.</param>
            <param name="hardReset">If true, also wipe state such as for <see cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/> which normally
            persists even if an action is disabled.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ToCombinedMapAndControlAndBindingIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Bit pack the mapIndex, controlIndex, bindingIndex and complexity components into a single long monitor index value.
            </summary>
            <param name="mapIndex">The mapIndex value to pack.</param>
            <param name="controlIndex">The controlIndex value to pack.</param>
            <param name="bindingIndex">The bindingIndex value to pack..</param>
            <remarks>
            We mangle the various indices we use into a single long for association with state change
            monitors. While we could look up map and binding indices from control indices, keeping
            all the information together avoids having to unnecessarily jump around in memory to grab
            the various pieces of data.
            The complexity component is implicitly derived and does not need to be passed as an argument.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.SplitUpMapAndControlAndBindingIndex(System.Int64,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Extract the mapIndex, controlIndex and bindingIndex components from the provided bit packed argument (monitor index).
            </summary>
            <param name="mapControlAndBindingIndex">Represents a monitor index, which is a bit packed field containing multiple components.</param>
            <param name="mapIndex">Will hold the extracted mapIndex value after the function completes.</param>
            <param name="controlIndex">Will hold the extracted controlIndex value after the function completes.</param>
            <param name="bindingIndex">Will hold the extracted bindingIndex value after the function completes.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.GetComplexityFromMonitorIndex(System.Int64)">
            <summary>
            Extract the 'complexity' component from the provided bit packed argument (monitor index).
            </summary>
            <param name="mapControlAndBindingIndex">Represents a monitor index, which is a bit packed field containing multiple components.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ProcessControlStateChange(System.Int32,System.Int32,System.Int32,System.Double,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Process a state change that has happened in one of the controls attached
             to this action map state.
             </summary>
             <param name="mapIndex">Index of the action map to which the binding belongs.</param>
             <param name="controlIndex">Index of the control that changed state.</param>
             <param name="bindingIndex">Index of the binding associated with the given control.</param>
             <param name="time">The timestamp associated with the state change (comes from the state change event).</param>
             <param name="eventPtr">Event (if any) that triggered the state change.</param>
             <remarks>
             This is where we end up if one of the state monitors we've put in the system has triggered.
             From here we go back to the associated binding and then let it figure out what the state change
             means for it.
            
             Note that we get called for any change in state even if the change in state does not actually
             result in a change of value on the respective control.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ShouldIgnoreInputOnCompositeBinding(UnityEngine.InputSystem.InputActionState.BindingState*,UnityEngine.InputSystem.LowLevel.InputEvent*)">
             <summary>
             Whether the given state change on a composite binding should be ignored.
             </summary>
             <param name="binding"></param>
             <param name="eventPtr"></param>
             <returns></returns>
             <remarks>
             Each state event may change the state of arbitrary many controls on a device and thus may trigger
             several bindings at once that are part of the same composite binding. We still want to trigger the
             composite binding only once for the event.
            
             To do so, we store the ID of the event on the binding and ignore events if they have the same
             ID as the one we've already recorded.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.IsConflictingInput(UnityEngine.InputSystem.InputActionState.TriggerState@,System.Int32)">
             <summary>
             Whether the given control state should be ignored.
             </summary>
             <param name="trigger"></param>
             <param name="actionIndex"></param>
             <returns></returns>
             <remarks>
             If an action has multiple controls bound to it, control state changes on the action may conflict with each other.
             If that happens, we resolve the conflict by always sticking to the most actuated control.
            
             Pass-through actions (<see cref="!:InputAction.passThrough"/>) will always bypass conflict resolution and respond
             to every value change.
            
             Actions that are resolved to only a single control will early out of conflict resolution.
            
             Actions that are bound to multiple controls but have only one control actuated will early out of conflict
             resolution as well.
            
             Note that conflict resolution here is entirely tied to magnitude. This ignores other qualities that the value
             of a control may have. For example, one 2D vector may have a similar magnitude to another yet point in an
             entirely different direction.
            
             There are other conflict resolution mechanisms that could be used. For example, we could average the values
             from all controls. However, it would not necessarily result in more useful conflict resolution and would
             at the same time be much more expensive.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ProcessDefaultInteraction(UnityEngine.InputSystem.InputActionState.TriggerState@,System.Int32)">
             <summary>
             When there is no interaction on an action, this method perform the default interaction logic that we
             run when a bound control changes value.
             </summary>
             <param name="trigger">Control trigger state.</param>
             <param name="actionIndex"></param>
             <remarks>
             The default interaction does not have its own <see cref="T:UnityEngine.InputSystem.InputActionState.InteractionState"/>. Whatever we do in here,
             we store directly on the action state.
            
             The default interaction is basically a sort of optimization where we don't require having an explicit
             interaction object. Conceptually, it can be thought of, however, as putting this interaction on any
             binding that doesn't have any other interaction on it.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ChangePhaseOfInteraction(UnityEngine.InputSystem.InputActionPhase,UnityEngine.InputSystem.InputActionState.TriggerState@,UnityEngine.InputSystem.InputActionPhase,System.Boolean)">
             <summary>
             Perform a phase change on the given interaction. Only visible to observers
             if it happens to change the phase of the action, too.
             </summary>
             <param name="newPhase">New phase to transition the interaction to.</param>
             <param name="trigger">Information about the binding and control that triggered the phase change.</param>
             <param name="phaseAfterPerformed">If <paramref name="newPhase"/> is <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>,
             this determines which phase to transition to after the action has been performed. This would usually be
             <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/> (default), <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> (if the action is supposed
             to be oscillate between started and performed), or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> (if the action is
             supposed to perform over and over again until canceled).</param>
             <param name="processNextInteractionOnCancel">Indicates if the system should try and change the phase of other
             interactions on the same action that are already started or performed after cancelling this interaction. This should be
             false when resetting interactions.</param>
             <remarks>
             Multiple interactions on the same binding can be started concurrently but the
             first interaction that starts will get to drive an action until it either cancels
             or performs the action.
            
             If an interaction driving an action performs it, all interactions will reset and
             go back waiting.
            
             If an interaction driving an action cancels it, the next interaction in the list which
             has already started will get to drive the action (example: a TapInteraction and a
             SlowTapInteraction both start and the TapInteraction gets to drive the action because
             it comes first; then the TapInteraction cancels because the button is held for too
             long and the SlowTapInteraction will get to drive the action next).
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ChangePhaseOfAction(UnityEngine.InputSystem.InputActionPhase,UnityEngine.InputSystem.InputActionState.TriggerState@,UnityEngine.InputSystem.InputActionPhase)">
             <summary>
             Change the current phase of the action referenced by <paramref name="trigger"/> to <paramref name="newPhase"/>.
             </summary>
             <param name="newPhase">New phase to transition to.</param>
             <param name="trigger">Trigger that caused the change in phase.</param>
             <param name="phaseAfterPerformedOrCanceled"></param>
             <remarks>
             The change in phase is visible to observers, i.e. on the various callbacks and notifications.
            
             If <paramref name="newPhase"/> is <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>,
             the action will subsequently immediately transition to <paramref name="phaseAfterPerformedOrCanceled"/>
             (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/> by default). This change is not visible to observers, i.e. there won't
             be another run through callbacks.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ReadCompositePartValue``2(System.Int32,System.Int32,System.Boolean*,System.Int32@,``1)">
             <summary>
             Read the value of the given part of a composite binding.
             </summary>
             <param name="bindingIndex">Index of the composite binding in <see cref="P:UnityEngine.InputSystem.InputActionState.bindingStates"/>.</param>
             <param name="partNumber">Index of the part. Note that part indices start at 1!</param>
             <typeparam name="TValue">Value type to read. Must correspond to the value of bound controls or an exception will
             be thrown.</typeparam>
             <returns>Greatest value from among the bound controls for the given part.</returns>
             <remarks>
             Composites are composed of "parts". Each part has an associated name (e.g. "negative" or "positive") which is
             referenced by <see cref="P:UnityEngine.InputSystem.InputBinding.name"/> of bindings that are part of the composite. However, multiple
             bindings may reference the same part (e.g. there could be a binding for "W" and another binding for "UpArrow"
             and both would reference the "Up" part).
            
             However, a given composite will only be interested in a single value for any given part. What we do is give
             a composite an integer key for every part. When it asks for a value for the given part, we go through all
             bindings that reference the given part and return the greatest value from among the controls of all those
             bindings.
            
             <example>
             <code>
             // Read a float value from the second part of the composite binding at index 3.
             ReadCompositePartValue&lt;float&gt;(3, 2);
             </code>
             </example>
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.InteractionState">
            <summary>
            Records the current state of a single interaction attached to a binding.
            Each interaction keeps track of its own trigger control and phase progression.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.BindingState">
            <summary>
            Runtime state for a single binding.
            </summary>
            <remarks>
            Correlated to the <see cref="T:UnityEngine.InputSystem.InputBinding"/> it corresponds to by the index in the binding
            array.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.controlStartIndex">
            <summary>
            Index into <see cref="F:UnityEngine.InputSystem.InputActionState.controls"/> of first control associated with the binding.
            </summary>
            <remarks>
            For composites, this is the index of the first control that is bound by any of the parts in the composite.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.controlCount">
            <summary>
            Number of controls associated with this binding.
            </summary>
            <remarks>
            For composites, this is the total number of controls bound by all parts of the composite combined.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.interactionStartIndex">
            <summary>
            Index into <see cref="P:UnityEngine.InputSystem.InputActionState.interactionStates"/> of first interaction associated with the binding.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.interactionCount">
            <summary>
            Number of interactions associated with this binding.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.actionIndex">
             <summary>
             Index of the action being triggered by the binding (if any).
             </summary>
             <remarks>
             For bindings that don't trigger actions, this is <see cref="F:UnityEngine.InputSystem.InputActionState.kInvalidIndex"/>.
            
             For bindings that are part of a composite, we force this to be the action set on the composite itself.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.compositeOrCompositeBindingIndex">
            <summary>
            If this is a composite binding, this is the index of the composite in <see cref="F:UnityEngine.InputSystem.InputActionState.composites"/>.
            If the binding is part of a composite, this is the index of the binding that is the composite.
            If the binding is neither a composite nor part of a composite, this is <see cref="F:UnityEngine.InputSystem.InputActionState.kInvalidIndex"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.BindingState.triggerEventIdForComposite">
            <summary>
            <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.eventId">ID</see> of the event that last triggered the binding.
            </summary>
            <remarks>
            We only store this for composites ATM.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.TriggerState">
            <summary>
            Record of an input control change and its related data.
            </summary>
            <remarks>
            This serves a dual purpose. One is, trigger states represent control actuations while we process them. The
            other is to represent the current actuation state of an action as a whole. The latter is stored in <see cref="P:UnityEngine.InputSystem.InputActionState.actionStates"/>
            while the former is passed around as temporary instances on the stack.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.phase">
            <summary>
            Phase being triggered by the control value change.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.time">
            <summary>
            The time the binding got triggered.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.startTime">
            <summary>
            The time when the binding moved into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.magnitude">
             <summary>
             Amount of actuation on the control.
             </summary>
             <remarks>
             This is only valid if <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.haveMagnitude"/> is true.
            
             Note that this may differ from the actuation stored for <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.controlIndex"/> in <see
             cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.controlMagnitudes"/> if the binding is a composite.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.haveMagnitude">
            <summary>
            Whether <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.magnitude"/> has been set.
            </summary>
            <remarks>
            Magnitude computation is expensive so we only want to do it once. Also, we sometimes need to compare
            a current magnitude to a magnitude value from a previous frame and the magnitude of the control
            may have already changed.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.mapIndex">
            <summary>
            Index of the action map in <see cref="F:UnityEngine.InputSystem.InputActionState.maps"/> that contains the binding that triggered.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.controlIndex">
            <summary>
            Index of the control currently driving the action or <see cref="F:UnityEngine.InputSystem.InputActionState.kInvalidIndex"/> if none.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.bindingIndex">
            <summary>
            Index into <see cref="P:UnityEngine.InputSystem.InputActionState.bindingStates"/> for the binding that triggered.
            </summary>
            <remarks>
            This corresponds 1:1 to an <see cref="T:UnityEngine.InputSystem.InputBinding"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.interactionIndex">
            <summary>
            Index into <see cref="P:UnityEngine.InputSystem.InputActionState.interactionStates"/> for the interaction that triggered.
            </summary>
            <remarks>
            Is <see cref="F:UnityEngine.InputSystem.InputActionState.kInvalidIndex"/> if there is no interaction present on the binding.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.lastPerformedInUpdate">
            <summary>
            Update step count (<see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdate.s_UpdateStepCount"/>) in which action triggered/performed last.
            Zero if the action did not trigger yet. Also reset to zero when the action is disabled.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.isPassThrough">
            <summary>
            Whether the action associated with the trigger state is marked as pass-through.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.isButton">
            <summary>
            Whether the action associated with the trigger state is a button-type action.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.InputActionType.Button"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.mayNeedConflictResolution">
             <summary>
             Whether the action may potentially see multiple concurrent actuations from its bindings
             and wants them resolved automatically.
             </summary>
             <remarks>
             We use this to gate some of the more expensive checks that are pointless to
             perform if we don't have to disambiguate input from concurrent sources.
            
             Always disabled if <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.isPassThrough"/> is true.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.TriggerState.hasMultipleConcurrentActuations">
            <summary>
            Whether the action currently has several concurrent actuations from its bindings.
            </summary>
            <remarks>
            This is only used when automatic conflict resolution is enabled (<see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.mayNeedConflictResolution"/>).
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.TriggerState.Flags.HaveMagnitude">
            <summary>
            Whether <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.magnitude"/> has been set.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.TriggerState.Flags.PassThrough">
            <summary>
            Whether the action associated with the trigger state is marked as pass-through.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.TriggerState.Flags.MayNeedConflictResolution">
            <summary>
            Whether the action has more than one control bound to it.
            </summary>
            <remarks>
            An action may have arbitrary many bindings yet may still resolve only to a single control
            at runtime. In that case, this flag is NOT set. We only set it if binding resolution for
            an action indeed ended up with multiple controls able to trigger the same action.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.TriggerState.Flags.HasMultipleConcurrentActuations">
            <summary>
            Whether there are currently multiple bound controls that are actuated.
            </summary>
            <remarks>
            This is only used if <see cref="P:UnityEngine.InputSystem.InputActionState.TriggerState.mayNeedConflictResolution"/> is true.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.TriggerState.Flags.Button">
            <summary>
            Whether the action associated with the trigger state is a button-type action.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.InputActionType.Button"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.ActionMapIndices">
            <summary>
            Tells us where the data for a single action map is found in the
            various arrays.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.UnmanagedMemory">
             <summary>
             Unmanaged memory kept for action maps.
             </summary>
             <remarks>
             Most of the dynamic execution state for actions we keep in a single block of unmanaged memory.
             Essentially, only the C# heap objects (like IInputInteraction and such) we keep in managed arrays.
             Aside from being able to condense the data into a single block of memory and not having to have
             it spread out on the GC heap, we gain the advantage of being able to freely allocate and re-allocate
             these blocks without creating garbage on the GC heap.
            
             The data here is set up by <see cref="T:UnityEngine.InputSystem.InputBindingResolver"/>.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.mapCount">
            <summary>
            Number of action maps and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.mapIndices"/> and <see cref="F:UnityEngine.InputSystem.InputActionState.maps"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionCount">
            <summary>
            Total number of actions (i.e. from all maps combined) and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionStates"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.interactionCount">
            <summary>
            Total number of interactions and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.interactionStates"/> and <see cref="F:UnityEngine.InputSystem.InputActionState.interactions"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.bindingCount">
            <summary>
            Total number of bindings and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.bindingStates"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.controlCount">
            <summary>
            Total number of bound controls and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.controls"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.compositeCount">
            <summary>
            Total number of composite bindings and entries in <see cref="F:UnityEngine.InputSystem.InputActionState.composites"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.sizeInBytes">
            <summary>
            Total size of allocated unmanaged memory.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionStates">
            <summary>
            Trigger state of all actions added to the state.
            </summary>
            <remarks>
            This array also tells which actions are enabled or disabled. Any action with phase
            <see cref="F:UnityEngine.InputSystem.InputActionPhase.Disabled"/> is disabled.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.bindingStates">
            <summary>
            State of all bindings added to the state.
            </summary>
            <remarks>
            For the most part, this is read-only information set up during resolution.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.interactionStates">
            <summary>
            State of all interactions on bindings in the action map.
            </summary>
            <remarks>
            Any interaction mentioned on any of the bindings gets its own execution state record
            in here. The interactions for any one binding are grouped together.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.controlMagnitudes">
             <summary>
             Current remembered level of actuation of each of the controls in <see cref="F:UnityEngine.InputSystem.InputActionState.controls"/>.
             </summary>
             <remarks>
             This array is NOT kept strictly up to date. In fact, we only use it for conflict resolution
             between multiple bound controls at the moment. Meaning that in the majority of cases, the magnitude
             stored for a control here will NOT be up to date.
            
             Also note that for controls that are part of composites, this will NOT be the magnitude of the
             control but rather be the magnitude of the entire compound.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionBindingIndicesAndCounts">
            <summary>
            Array of pair of ints, one pair for each action (same index as <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionStates"/>). First int
            is the index into <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionBindingIndices"/> where bindings of action are found and second int
            is the count of bindings on action.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionBindingIndices">
            <summary>
            Array of indices into <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.bindingStates"/>. The indices for every action are laid out sequentially.
            The array slice corresponding to each action can be determined by looking it up in <see cref="F:UnityEngine.InputSystem.InputActionState.UnmanagedMemory.actionBindingIndicesAndCounts"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionState.GlobalState">
             <summary>
             Global state containing a list of weak references to all action map states currently in the system.
             </summary>
             <remarks>
             When the control setup in the system changes, we need a way for control resolution that
             has already been done to be invalidated and redone. We also want a way to find all
             currently enabled actions in the system.
            
             Both of these needs are served by this global list.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.CompactGlobalList">
            <summary>
            Remove any entries for states that have been reclaimed by GC.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.ResetGlobals">
            <summary>
            Nuke global state we have to keep track of action map states.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.OnDeviceChange(UnityEngine.InputSystem.InputDevice,UnityEngine.InputSystem.InputDeviceChange)">
             <summary>
             Deal with the fact that the control setup in the system may change at any time and can affect
             actions that had their controls already resolved.
             </summary>
             <remarks>
             Note that this method can NOT deal with changes other than the control setup in the system
             changing. Specifically, it will NOT handle configuration changes in action maps (e.g. bindings
             being altered) correctly.
            
             We get called from <see cref="T:UnityEngine.InputSystem.InputManager"/> directly rather than hooking into <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/>
             so that we're not adding needless calls for device changes that are not of interest to us.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionState.DestroyAllActionMapStates">
            <summary>
            Forcibly destroy all states currently on the global list.
            </summary>
            <remarks>
            We do this when exiting play mode in the editor to make sure we are cleaning up our
            unmanaged memory allocations.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.PlayerNotifications">
            <summary>
            Determines how the triggering of an action or other input-related events are relayed to other GameObjects.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerNotifications.SendMessages">
             <summary>
             Use <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)"/> to send a message to the <see cref="T:UnityEngine.GameObject"/>
             that <see cref="T:UnityEngine.InputSystem.PlayerInput"/> belongs to.
            
             The message name will be the name of the action (e.g. "Jump"; it will not include the action map name),
             and the object will be the <see cref="T:UnityEngine.InputSystem.PlayerInput"/> on which the action was triggered.
            
             If the notification is for an action that was triggered, <see cref="T:UnityEngine.SendMessageOptions"/> will be
             <see cref="F:UnityEngine.SendMessageOptions.RequireReceiver"/> (i.e. an error will be logged if there is no corresponding
             method). Otherwise it will be <see cref="F:UnityEngine.SendMessageOptions.DontRequireReceiver"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerNotifications.BroadcastMessages">
            <summary>
            Like <see cref="F:UnityEngine.InputSystem.PlayerNotifications.SendMessages"/> but instead of using <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)"/>,
            use <see cref="M:UnityEngine.GameObject.BroadcastMessage(System.String,System.Object)"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerNotifications.InvokeUnityEvents">
             <summary>
             Have a separate <a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html">UnityEvent</a> for each notification.
             Allows wiring up target methods to invoke such that the connection is persisted in Unity serialized data.
            
             See <see cref="P:UnityEngine.InputSystem.PlayerInput.actionEvents"/> and related callbacks such as <see cref="P:UnityEngine.InputSystem.PlayerInput.controlsChangedEvent"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PlayerNotifications.InvokeCSharpEvents">
            <summary>
            Use plain C# callbacks.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.TouchPhase">
            <summary>
            Indicates where in its lifecycle a given touch is.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.None">
            <summary>
            No activity has been registered on the touch yet.
            </summary>
            <remarks>
            A given touch state will generally not go back to None once there has been input for it. Meaning that
            it generally indicates a default-initialized touch record.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.Began">
            <summary>
            A touch has just begun, i.e. a finger has touched the screen.. Only the first touch input in any given touch will have this phase.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.Moved">
            <summary>
            An ongoing touch has changed position.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.Ended">
            <summary>
            An ongoing touch has just ended, i.e. the respective finger has been lifted off of the screen. Only the last touch input in a
            given touch will have this phase.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.Canceled">
            <summary>
            An ongoing touch has been cancelled, i.e. ended in a way other than through user interaction. This happens, for example, if
            focus is moved away from the application while the touch is ongoing.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.TouchPhase.Stationary">
            <summary>
            An ongoing touch has not been moved (not received any input) in a frame.
            </summary>
            <remarks>
            This phase is not used by <see cref="T:UnityEngine.InputSystem.Touchscreen"/>. This means that <see cref="T:UnityEngine.InputSystem.Controls.TouchControl"/> will not generally
            return this value for <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>. It is, however, used by <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Touchscreen">
             <summary>
             A multi-touch surface.
             </summary>
             <remarks>
             Touchscreen is somewhat different from most other device implementations in that it does not usually
             consume input in the form of a full device snapshot but rather consumes input sent to it in the form
             of events containing a <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/> each. This is unusual as <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/>
             uses a memory format different from <see cref="P:UnityEngine.InputSystem.LowLevel.TouchState.Format"/>. However, when a <c>Touchscreen</c>
             sees an event containing a <see cref="T:UnityEngine.InputSystem.LowLevel.TouchState"/>, it will handle that event on a special code path.
            
             This allows <c>Touchscreen</c> to decide on its own which control in <see cref="P:UnityEngine.InputSystem.Touchscreen.touches"/> to store
             a touch at and to perform things such as tap detection (see <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.tap"/> and
             <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.tapCount"/>) and primary touch handling (see <see cref="P:UnityEngine.InputSystem.Touchscreen.primaryTouch"/>).
            
             <example>
             <code>
             // Create a touchscreen device.
             var touchscreen = InputSystem.AddDevice&lt;Touchscreen&gt;();
            
             // Send a touch to the device.
             InputSystem.QueueStateEvent(touchscreen,
                 new TouchState
                 {
                     phase = TouchPhase.Began,
                     // Must have a valid, non-zero touch ID. Touchscreen will not operate
                     // correctly if we don't set IDs properly.
                     touchId = 1,
                     position = new Vector2(123, 234),
                     // Delta will be computed by Touchscreen automatically.
                 });
             </code>
             </example>
            
             Note that this class presents a fairly low-level touch API. When working with touch from script code,
             it is recommended to use the higher-level <see cref="T:UnityEngine.InputSystem.EnhancedTouch.Touch"/> API instead.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Touchscreen.primaryTouch">
             <summary>
             Synthetic control that has the data for the touch that is deemed the "primary" touch at the moment.
             </summary>
             <value>Control tracking the screen's primary touch.</value>
             <remarks>
             This touch duplicates touch data from whichever touch is deemed the primary touch at the moment.
             When going from no fingers down to any finger down, the first finger to touch the screen is
             deemed the "primary touch". It stays the primary touch until the last finger is released.
            
             Note that unlike the touch from which it originates, the primary touch will be kept ongoing for
             as long as there is still a finger on the screen. Put another way, <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
             of <c>primaryTouch</c> will only transition to <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/> once the last finger
             has been lifted off the screen.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Touchscreen.touches">
            <summary>
            Array of all <see cref="T:UnityEngine.InputSystem.Controls.TouchControl"/>s on the device.
            </summary>
            <value>All <see cref="T:UnityEngine.InputSystem.Controls.TouchControl"/>s on the screen.</value>
            <remarks>
            By default, a touchscreen will allocate 10 touch controls. This can be changed
            by modifying the "Touchscreen" layout itself or by derived layouts. In practice,
            this means that this array will usually have a fixed length of 10 entries but
            it may deviate from that.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Touchscreen.current">
            <summary>
            The touchscreen that was added or updated last or null if there is no
            touchscreen connected to the system.
            </summary>
            <value>Current touch screen.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Touchscreen.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Touchscreen.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Touchscreen.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Touchscreen.OnStateEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Called whenever a new state event is received.
            </summary>
            <param name="eventPtr"></param>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionProperty">
             <summary>
             A serializable property type that can either reference an action externally defined
             in an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> or define a new action directly on the property.
             </summary>
             <remarks>
             This struct is meant to be used for serialized fields in <c>MonoBehaviour</c> and
             <c>ScriptableObject</c> classes. It has a custom property drawer attached to it
             that allows to switch between using the property as a reference and using it
             to define an action in place.
            
             <example>
             <code>
             public class MyBehavior : MonoBehaviour
             {
                 // This can be edited in the inspector to either reference an existing
                 // action or to define an action directly on the component.
                 public InputActionProperty myAction;
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputAction"/>
             <seealso cref="T:UnityEngine.InputSystem.InputActionReference"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionProperty.action">
            <summary>
            The action held on to by the property.
            </summary>
            <value>The action object contained in the property.</value>
            <remarks>
            This property will return <c>null</c> if the property is using a <see cref="P:UnityEngine.InputSystem.InputActionProperty.reference"/> and
            the referenced action cannot be found. Also, it will be <c>null</c> if the property
            has been manually initialized with a <c>null</c> <see cref="T:UnityEngine.InputSystem.InputAction"/> using
            <see cref="M:UnityEngine.InputSystem.InputActionProperty.#ctor(UnityEngine.InputSystem.InputAction)"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionProperty.reference">
            <summary>
            If the property contains a reference to the action, this property returns
            the reference. Otherwise it returns <c>null</c>.
            </summary>
            <value>Reference to external input action, if defined.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.#ctor(UnityEngine.InputSystem.InputAction)">
            <summary>
            Initialize the property to contain the given action.
            </summary>
            <param name="action">An action.</param>
            <remarks>
            When the struct is serialized, it will serialize the given action as part of it.
            The <see cref="P:UnityEngine.InputSystem.InputActionProperty.reference"/> property will return <c>null</c>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.#ctor(UnityEngine.InputSystem.InputActionReference)">
            <summary>
            Initialize the property to use the given action reference.
            </summary>
            <param name="reference">Reference to an <see cref="T:UnityEngine.InputSystem.InputAction"/>.</param>
            <remarks>
            When the struct is serialized, it will only serialize a reference to
            the given <paramref name="reference"/> object.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputActionProperty)">
            <summary>
            Compare two action properties to see whether they refer to the same action.
            </summary>
            <param name="other">Another action property.</param>
            <returns>True if both properties refer to the same action.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputAction)">
            <summary>
            Check whether the property refers to the same action.
            </summary>
            <param name="other">An action.</param>
            <returns>True if <see cref="P:UnityEngine.InputSystem.InputActionProperty.action"/> is the same as <paramref name="other"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputActionReference)">
            <summary>
            Check whether the property references the same action.
            </summary>
            <param name="other">An action reference.</param>
            <returns>True if the property and <paramref name="other"/> reference the same action.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.Equals(System.Object)">
            <summary>
            Check whether the given object is an InputActionProperty referencing the same action.
            </summary>
            <param name="obj">An object or <c>null</c>.</param>
            <returns>True if the given <paramref name="obj"/> is an InputActionProperty equivalent to this one.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputActionProperty)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.GetHashCode">
            <summary>
            Compute a hash code for the object.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.op_Equality(UnityEngine.InputSystem.InputActionProperty,UnityEngine.InputSystem.InputActionProperty)">
            <summary>
            Compare the two properties for equivalence.
            </summary>
            <param name="left">The first property.</param>
            <param name="right">The second property.</param>
            <returns>True if the two action properties are equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputActionProperty)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionProperty.op_Inequality(UnityEngine.InputSystem.InputActionProperty,UnityEngine.InputSystem.InputActionProperty)">
            <summary>
            Compare the two properties for not being equivalent.
            </summary>
            <param name="left">The first property.</param>
            <param name="right">The second property.</param>
            <returns>True if the two action properties are not equivalent.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionProperty.Equals(UnityEngine.InputSystem.InputActionProperty)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputDeviceChange">
             <summary>
             Indicates what type of change related to an <see cref="T:UnityEngine.InputSystem.InputDevice">input device</see> occurred.
             </summary>
             <remarks>
             Use <see cref="E:UnityEngine.InputSystem.InputSystem.onDeviceChange"/> to receive notifications about changes
             to the input device setup in the system.
            
             <example>
             <code>
             InputSystem.onDeviceChange +=
                 (device, change) =>
                 {
                     switch (change)
                     {
                         case InputDeviceChange.Added:
                             Debug.Log($"Device {device} was added");
                             break;
                         case InputDeviceChange.Removed:
                             Debug.Log($"Device {device} was removed");
                             break;
                     }
                 };
             </code>
             </example>
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Added">
             <summary>
             A new device was added to the system. This is triggered <em>after</em> the device
             has already been added, i.e. it already appears on <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.
            
             See also <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/> and <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Removed">
             <summary>
             An existing device was removed from the system. This is triggered <em>after</em> the
             device has already been removed, i.e. it already has been cleared from <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.
            
             Other than when a device is removed programmatically, this happens when a device
             is unplugged from the system. Subsequent to the notification, the system will remove
             the <see cref="T:UnityEngine.InputSystem.InputDevice"/> instance from its list and remove the device's
             recorded input state.
            
             See also <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Disconnected">
             <summary>
             A device reported by the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime"/> was <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Removed"/> but was
             retained by the system as <see cref="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices">disconnected</see>.
            
             See also <see cref="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Reconnected">
             <summary>
             A device that was previously retained as <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Disconnected"/> has been re-discovered
             and has been <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Added"/> to the system again.
            
             See also <see cref="P:UnityEngine.InputSystem.InputSystem.disconnectedDevices"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Enabled">
             <summary>
             An existing device was re-enabled after having been <see cref="F:UnityEngine.InputSystem.InputDeviceChange.Disabled"/>.
            
             See also <see cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/> and <see cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.Disabled">
             <summary>
             An existing device was disabled.
            
             See also <see cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/> and <see cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.UsageChanged">
             <summary>
             The usages on a device have changed.
            
             This may signal, for example, that what was the right hand XR controller before
             is now the left hand controller.
            
             See also <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/> and
             <see cref="P:UnityEngine.InputSystem.InputControl.usages"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.ConfigurationChanged">
             <summary>
             The configuration of a device has changed.
            
             This may signal, for example, that the layout used by the keyboard has changed or
             that, on a console, a gamepad has changed which player ID(s) it is assigned to.
            
             See also <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/> and <see cref="M:UnityEngine.InputSystem.InputSystem.QueueConfigChangeEvent(UnityEngine.InputSystem.InputDevice,System.Double)"/>.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.SoftReset">
             <summary>
             Device is being "soft" reset but in a way that excludes <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.dontReset"/>
             controls such as mouse positions. This can happen during application focus changes
             (see <see cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>) or when <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
             is called explicitly.
            
             This notification is sent before the actual reset happens.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDeviceChange.HardReset">
             <summary>
             Device is being "hard" reset, i.e. every control is reset to its default value. This happens only
             when explicitly forced through <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>.
            
             This notification is sent before the actual reset happens.
             </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionAsset">
             <summary>
             An asset that contains action maps and control schemes.
             </summary>
             <remarks>
             InputActionAssets can be created in code but are usually stored in JSON format on
             disk with the ".inputactions" extension. Unity imports them with a custom
             importer.
            
             To create an InputActionAsset in code, use the <c>Singleton</c> API and populate the
             asset with the methods found in <see cref="T:UnityEngine.InputSystem.InputActionSetupExtensions"/>. Alternatively,
             you can use <see cref="M:UnityEngine.InputSystem.InputActionAsset.FromJson(System.String)"/> to load an InputActionAsset directly from a string in JSON format.
            
             <example>
             <code>
             // Create and configure an asset in code.
             var asset1 = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
             var actionMap1 = asset1.AddActionMap("map1");
             action1Map.AddAction("action1", binding: "&lt;Keyboard&gt;/space");
             </code>
             </example>
            
             If you use the API to modify an InputActionAsset while in Play mode,
             it does not survive the transition back to Edit Mode. Unity tracks and reloads modified assets
             from disk when exiting Play mode. This is done so that you can realistically test the input
             related functionality of your application i.e. control rebinding etc, without inadvertently changing
             the input asset.
            
             Each asset can contain arbitrary many action maps that you can enable and disable individually
             (see <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/> and <see cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/>) or in bulk
             (see <see cref="M:UnityEngine.InputSystem.InputActionAsset.Enable"/> and <see cref="M:UnityEngine.InputSystem.InputActionAsset.Disable"/>). The name of each action map must be unique.
             The list of action maps can be queried from <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>.
            
             InputActionAssets can only define <see cref="T:UnityEngine.InputSystem.InputControlScheme"/>s. They can be added to
             an asset with <see cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
             and can be queried from <see cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>.
            
             Be aware that input action assets do not separate between static (configuration) data and dynamic
             (instance) data. For audio, for example, <c>AudioClip</c> represents the static,
             shared data portion of audio playback whereas <c>AudioSource"</c> represents the
             dynamic, per-instance audio playback portion (referencing the clip through <c>AudioSource.clip</c>).
            
             For input, such a split is less beneficial as the same input is generally not exercised
             multiple times in parallel. Keeping both static and dynamic data together simplifies
             using the system.
            
             However, there are scenarios where you indeed want to take the same input action and
             exercise it multiple times in parallel. A prominent example of such a use case is
             local multiplayer where each player gets the same set of actions but is controlling
             them with a different device (or devices) each. This is easily achieved by simply
             using <c>UnityEngine.Object.Instantiate</c> to instantiate the input action
             asset multiple times. <see cref="T:UnityEngine.InputSystem.PlayerInput"/> will automatically do so in its
             internals.
            
             Note also that all action maps in an asset share binding state. This means that if
             one map in an asset has to resolve its bindings, all maps in the asset have to.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionAsset.Extension">
            <summary>
            File extension (without the dot) for InputActionAssets in JSON format.
            </summary>
            <value>File extension for InputActionAsset source files.</value>
            <remarks>
            Files with this extension will automatically be imported by Unity as
            InputActionAssets.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.enabled">
            <summary>
            True if any action in the asset is currently enabled.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.Enable"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.actionMaps">
            <summary>
            List of action maps defined in the asset.
            </summary>
            <value>Action maps contained in the asset.</value>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddActionMap(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveActionMap(UnityEngine.InputSystem.InputActionAsset,UnityEngine.InputSystem.InputActionMap)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FindActionMap(System.String,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes">
            <summary>
            List of control schemes defined in the asset.
            </summary>
            <value>Control schemes defined for the asset.</value>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.RemoveControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.bindings">
            <summary>
            Iterate over all bindings in the asset.
            </summary>
            <remarks>
            This iterates over all action maps in <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/> and, within each
            map, over the set of <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.bindingMask">
             <summary>
             Binding mask to apply to all action maps and actions in the asset.
             </summary>
             <value>Optional mask that determines which bindings in the asset to enable.</value>
             <remarks>
             Binding masks can be applied at three different levels: for an entire asset through
             this property, for a specific map through <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>,
             and for single actions through <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>. By default,
             none of the masks will be set (i.e. they will be <c>null</c>).
            
             When an action is enabled, all the binding masks that apply to it are taken into
             account. Specifically, this means that any given binding on the action will be
             enabled only if it matches the mask applied to the asset, the mask applied
             to the map that contains the action, and the mask applied to the action itself.
             All the masks are individually optional.
            
             Masks are matched against bindings using <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.
            
             Note that if you modify the masks applicable to an action while it is
             enabled, the action's <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> will get updated immediately to
             respect the mask. To avoid repeated binding resolution, it is most efficient
             to apply binding masks before enabling actions.
            
             Binding masks are non-destructive. All the bindings on the action are left
             in place. Setting a mask will not affect the value of the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             and <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> properties.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.MaskByGroup(System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.devices">
             <summary>
             Set of devices that bindings in the asset can bind to.
             </summary>
             <value>Optional set of devices to use by bindings in the asset.</value>
             <remarks>
             By default (with this property being <c>null</c>), bindings will bind to any of the
             controls available through <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>, i.e. controls from all
             devices in the system will be used.
            
             By setting this property, binding resolution can instead be restricted to just specific
             devices. This restriction can either be applied to an entire asset using this property
             or to specific action maps by using <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>. Note that if
             both this property and <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/> is set for a specific action
             map, the list of devices on the action map will take precedence and the list on the
             asset will be ignored for bindings in that action map.
            
             <example>
             <code>
             // Create an asset with a single action map and a single action with a
             // gamepad binding.
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
             var actionMap = new InputActionMap();
             var fireAction = actionMap.AddAction("Fire", binding: "&lt;Gamepad&gt;/buttonSouth");
             asset.AddActionMap(actionMap);
            
             // Let's assume we have two gamepads connected. If we enable the
             // action map now, the 'Fire' action will bind to both.
             actionMap.Enable();
            
             // This will print two controls.
             Debug.Log(string.Join("\n", fireAction.controls));
            
             // To restrict the setup to just the first gamepad, we can assign
             // to the 'devices' property (in this case, we could do so on either
             // the action map or on the asset; we choose the latter here).
             asset.devices = new InputDevice[] { Gamepad.all[0] };
            
             // Now this will print only one control.
             Debug.Log(string.Join("\n", fireAction.controls));
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionAsset.Item(System.String)">
             <summary>
             Look up an action by name or ID.
             </summary>
             <param name="actionNameOrId">Name of the action as either a "map/action" combination (e.g. "gameplay/fire") or
             a simple name. In the former case, the name is split at the '/' slash and the first part is used to find
             a map with that name and the second part is used to find an action with that name inside the map. In the
             latter case, all maps are searched in order and the first action that has the given name in any of the maps
             is returned. Note that name comparisons are case-insensitive.
            
             Alternatively, the given string can be a GUID as given by <see cref="P:UnityEngine.InputSystem.InputAction.id"/>.</param>
             <returns>The action with the corresponding name or null if no matching action could be found.</returns>
             <remarks>
             This method is equivalent to <see cref="M:UnityEngine.InputSystem.InputActionAsset.FindAction(System.String,System.Boolean)"/> except that it throws
             <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if no action with the given name or ID
             could be found.
             </remarks>
             <exception cref="T:System.Collections.Generic.KeyNotFoundException">No action was found matching <paramref name="actionNameOrId"/>.</exception>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionNameOrId"/> is <c>null</c> or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FindAction(System.String,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.ToJson">
             <summary>
             Return a JSON representation of the asset.
             </summary>
             <returns>A string in JSON format that represents the static/configuration data present
             in the asset.</returns>
             <remarks>
             This will not save dynamic execution state such as callbacks installed on
             <see cref="T:UnityEngine.InputSystem.InputAction">actions</see> or enabled/disabled states of individual
             maps and actions.
            
             Use <see cref="M:UnityEngine.InputSystem.InputActionAsset.LoadFromJson(System.String)"/> to deserialize the JSON data back into an InputActionAsset.
            
             Be aware that the format used by this method is <em>different</em> than what you
             get if you call <c>JsonUtility.ToJson</c> on an InputActionAsset instance. In other
             words, the JSON format is not identical to the Unity serialized object representation
             of the asset.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FromJson(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.LoadFromJson(System.String)">
             <summary>
             Replace the contents of the asset with the data in the given JSON string.
             </summary>
             <param name="json">JSON contents of an <c>.inputactions</c> asset.</param>
             <remarks>
             <c>.inputactions</c> assets are stored in JSON format. This method allows reading
             the JSON source text of such an asset into an existing <c>InputActionMap</c> instance.
            
             <example>
             <code>
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
             asset.LoadFromJson(@"
             {
                 ""maps"" : [
                     {
                         ""name"" : ""gameplay"",
                         ""actions"" : [
                             { ""name"" : ""fire"", ""type"" : ""button"" },
                             { ""name"" : ""look"", ""type"" : ""value"" },
                             { ""name"" : ""move"", ""type"" : ""value"" }
                         ],
                         ""bindings"" : [
                             { ""path"" : ""&lt;Gamepad&gt;/buttonSouth"", ""action"" : ""fire"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/leftTrigger"", ""action"" : ""fire"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/leftStick"", ""action"" : ""move"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/rightStick"", ""action"" : ""look"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""dpad"", ""action"" : ""move"", ""groups"" : ""Gamepad"", ""isComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/a"", ""name"" : ""left"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/d"", ""name"" : ""right"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/w"", ""name"" : ""up"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/s"", ""name"" : ""down"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Mouse&gt;/delta"", ""action"" : ""look"", ""groups"" : ""Keyboard&amp;Mouse"" },
                             { ""path"" : ""&lt;Mouse&gt;/leftButton"", ""action"" : ""fire"", ""groups"" : ""Keyboard&amp;Mouse"" }
                         ]
                     },
                     {
                         ""name"" : ""ui"",
                         ""actions"" : [
                             { ""name"" : ""navigate"" }
                         ],
                         ""bindings"" : [
                             { ""path"" : ""&lt;Gamepad&gt;/dpad"", ""action"" : ""navigate"", ""groups"" : ""Gamepad"" }
                         ]
                     }
                 ],
                 ""controlSchemes"" : [
                     {
                         ""name"" : ""Gamepad"",
                         ""bindingGroup"" : ""Gamepad"",
                         ""devices"" : [
                             { ""devicePath"" : ""&lt;Gamepad&gt;"" }
                         ]
                     },
                     {
                         ""name"" : ""Keyboard&amp;Mouse"",
                         ""bindingGroup"" : ""Keyboard&amp;Mouse"",
                         ""devices"" : [
                             { ""devicePath"" : ""&lt;Keyboard&gt;"" },
                             { ""devicePath"" : ""&lt;Mouse&gt;"" }
                         ]
                     }
                 ]
             }");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is <c>null</c> or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FromJson(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.ToJson"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FromJson(System.String)">
             <summary>
             Replace the contents of the asset with the data in the given JSON string.
             </summary>
             <param name="json">JSON contents of an <c>.inputactions</c> asset.</param>
             <returns>The InputActionAsset instance created from the given JSON string.</returns>
             <remarks>
             <c>.inputactions</c> assets are stored in JSON format. This method allows turning
             the JSON source text of such an asset into a new <c>InputActionMap</c> instance.
            
             Be aware that the format used by this method is <em>different</em> than what you
             get if you call <c>JsonUtility.ToJson</c> on an InputActionAsset instance. In other
             words, the JSON format is not identical to the Unity serialized object representation
             of the asset.
            
             <example>
             <code>
             var asset = InputActionAsset.FromJson(@"
             {
                 ""maps"" : [
                     {
                         ""name"" : ""gameplay"",
                         ""actions"" : [
                             { ""name"" : ""fire"", ""type"" : ""button"" },
                             { ""name"" : ""look"", ""type"" : ""value"" },
                             { ""name"" : ""move"", ""type"" : ""value"" }
                         ],
                         ""bindings"" : [
                             { ""path"" : ""&lt;Gamepad&gt;/buttonSouth"", ""action"" : ""fire"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/leftTrigger"", ""action"" : ""fire"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/leftStick"", ""action"" : ""move"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""&lt;Gamepad&gt;/rightStick"", ""action"" : ""look"", ""groups"" : ""Gamepad"" },
                             { ""path"" : ""dpad"", ""action"" : ""move"", ""groups"" : ""Gamepad"", ""isComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/a"", ""name"" : ""left"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/d"", ""name"" : ""right"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/w"", ""name"" : ""up"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Keyboard&gt;/s"", ""name"" : ""down"", ""action"" : ""move"", ""groups"" : ""Keyboard&amp;Mouse"", ""isPartOfComposite"" : true },
                             { ""path"" : ""&lt;Mouse&gt;/delta"", ""action"" : ""look"", ""groups"" : ""Keyboard&amp;Mouse"" },
                             { ""path"" : ""&lt;Mouse&gt;/leftButton"", ""action"" : ""fire"", ""groups"" : ""Keyboard&amp;Mouse"" }
                         ]
                     },
                     {
                         ""name"" : ""ui"",
                         ""actions"" : [
                             { ""name"" : ""navigate"" }
                         ],
                         ""bindings"" : [
                             { ""path"" : ""&lt;Gamepad&gt;/dpad"", ""action"" : ""navigate"", ""groups"" : ""Gamepad"" }
                         ]
                     }
                 ],
                 ""controlSchemes"" : [
                     {
                         ""name"" : ""Gamepad"",
                         ""bindingGroup"" : ""Gamepad"",
                         ""devices"" : [
                             { ""devicePath"" : ""&lt;Gamepad&gt;"" }
                         ]
                     },
                     {
                         ""name"" : ""Keyboard&amp;Mouse"",
                         ""bindingGroup"" : ""Keyboard&amp;Mouse"",
                         ""devices"" : [
                             { ""devicePath"" : ""&lt;Keyboard&gt;"" },
                             { ""devicePath"" : ""&lt;Mouse&gt;"" }
                         ]
                     }
                 ]
             }");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is <c>null</c> or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.LoadFromJson(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.ToJson"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindAction(System.String,System.Boolean)">
             <summary>
             Find an <see cref="T:UnityEngine.InputSystem.InputAction"/> by its name in one of the <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s
             in the asset.
             </summary>
             <param name="actionNameOrId">Name of the action as either a "map/action" combination (e.g. "gameplay/fire") or
             a simple name. In the former case, the name is split at the '/' slash and the first part is used to find
             a map with that name and the second part is used to find an action with that name inside the map. In the
             latter case, all maps are searched in order and the first action that has the given name in any of the maps
             is returned. Note that name comparisons are case-insensitive.
            
             Alternatively, the given string can be a GUID as given by <see cref="P:UnityEngine.InputSystem.InputAction.id"/>.</param>
             <param name="throwIfNotFound">If <c>true</c>, instead of returning <c>null</c> when the action
             cannot be found, throw <c>ArgumentException</c>.</param>
             <returns>The action with the corresponding name or <c>null</c> if no matching action could be found.</returns>
             <remarks>
             Note that no lookup structures are used internally to speed the operation up. Instead, the search is done
             linearly. For repeated access of an action, it is thus generally best to look up actions once ahead of
             time and cache the result.
            
             If multiple actions have the same name and <paramref name="actionNameOrId"/> is not an ID and not an
             action name qualified by a map name (that is, in the form of <c>"mapName/actionName"</c>), the action that
             is returned will be from the first map in <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/> that has an action with the given name.
             An exception is if, of the multiple actions with the same name, some are enabled and some are disabled. In
             this case, the first action that is enabled is returned.
            
             <example>
             <code>
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
            
             var map1 = new InputActionMap("map1");
             var map2 = new InputActionMap("map2");
            
             asset.AddActionMap(map1);
             asset.AddActionMap(map2);
            
             var action1 = map1.AddAction("action1");
             var action2 = map1.AddAction("action2");
             var action3 = map2.AddAction("action3");
            
             // Search all maps in the asset for any action that has the given name.
             asset.FindAction("action1") // Returns action1.
             asset.FindAction("action2") // Returns action2
             asset.FindAction("action3") // Returns action3.
            
             // Search for a specific action in a specific map.
             asset.FindAction("map1/action1") // Returns action1.
             asset.FindAction("map2/action2") // Returns action2.
             asset.FindAction("map3/action3") // Returns action3.
            
             // Search by unique action ID.
             asset.FindAction(action1.id.ToString()) // Returns action1.
             asset.FindAction(action2.id.ToString()) // Returns action2.
             asset.FindAction(action3.id.ToString()) // Returns action3.
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionNameOrId"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">Thrown if <paramref name="throwIfNotFound"/> is true and the
             action could not be found. -Or- If <paramref name="actionNameOrId"/> contains a slash but is missing
             either the action or the map name.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindBinding(UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputAction@)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindActionMap(System.String,System.Boolean)">
            <summary>
            Find an <see cref="T:UnityEngine.InputSystem.InputActionMap"/> in the asset by its name or ID.
            </summary>
            <param name="nameOrId">Name or ID (see <see cref="P:UnityEngine.InputSystem.InputActionMap.id"/>) of the action map
            to look for. Matching is case-insensitive.</param>
            <param name="throwIfNotFound">If true, instead of returning <c>null</c>, throw <c>ArgumentException</c>.</param>
            <returns>The <see cref="T:UnityEngine.InputSystem.InputActionMap"/> with a name or ID matching <paramref name="nameOrId"/> or
            <c>null</c> if no matching map could be found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="nameOrId"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="throwIfNotFound"/> is <c>true</c>, thrown if
            the action map cannot be found.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FindActionMap(System.Guid)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindActionMap(System.Guid)">
            <summary>
            Find an <see cref="T:UnityEngine.InputSystem.InputActionMap"/> in the asset by its ID.
            </summary>
            <param name="id">ID (see <see cref="P:UnityEngine.InputSystem.InputActionMap.id"/>) of the action map
            to look for.</param>
            <returns>The <see cref="T:UnityEngine.InputSystem.InputActionMap"/> with ID matching <paramref name="id"/> or
            <c>null</c> if no map in the asset has the given ID.</returns>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FindActionMap(System.String,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindAction(System.Guid)">
            <summary>
            Find an action by its ID (see <see cref="P:UnityEngine.InputSystem.InputAction.id"/>).
            </summary>
            <param name="guid">ID of the action to look for.</param>
            <returns>The action in the asset with the given ID or null if no action
            in the asset has the given ID.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindControlSchemeIndex(System.String)">
            <summary>
            Find the control scheme with the given name and return its index
            in <see cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>.
            </summary>
            <param name="name">Name of the control scheme. Matching is case-insensitive.</param>
            <returns>The index of the given control scheme or -1 if no control scheme
            with the given name could be found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c>
            or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.FindControlScheme(System.String)">
            <summary>
            Find the control scheme with the given name and return it.
            </summary>
            <param name="name">Name of the control scheme. Matching is case-insensitive.</param>
            <returns>The control scheme with the given name or null if no scheme
            with the given name could be found in the asset.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c>
            or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.IsUsableWithDevice(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Return true if the asset contains bindings (in any of its action maps) that are usable
            with the given <paramref name="device"/>.
            </summary>
            <param name="device">An arbitrary input device.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            // Find out if the actions of the given PlayerInput can be used with
            // a gamepad.
            if (playerInput.actions.IsUsableWithDevice(Gamepad.all[0]))
                /* ... */;
            </code>
            </example>
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.IsUsableWithDevice(UnityEngine.InputSystem.InputDevice)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControlScheme.SupportsDevice(UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.Enable">
            <summary>
            Enable all action maps in the asset.
            </summary>
            <remarks>
            This method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/> on
            all maps in <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.Disable">
            <summary>
            Disable all action maps in the asset.
            </summary>
            <remarks>
            This method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/> on
            all maps in <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.Contains(UnityEngine.InputSystem.InputAction)">
            <summary>
            Return <c>true</c> if the given action is part of the asset.
            </summary>
            <param name="action">An action. Can be null.</param>
            <returns>True if the given action is part of the asset, false otherwise.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.GetEnumerator">
             <summary>
             Enumerate all actions in the asset.
             </summary>
             <returns>An enumerator going over the actions in the asset.</returns>
             <remarks>
             Actions will be enumerated one action map in <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
             after the other. The actions from each map will be yielded in turn.
            
             This method will allocate GC heap memory.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionAsset.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate all actions in the asset.
            </summary>
            <returns>An enumerator going over the actions in the asset.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.GetEnumerator"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionAsset.m_SharedStateForAllMaps">
            <summary>
            Shared state for all action maps in the asset.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputController">
             <summary>
             An XInput-compatible game controller.
             </summary>
             <remarks>
             Note that on non-Microsoft platforms, XInput controllers will not actually use the XInput interface
             but will rather be interfaced with through different APIs -- on OSX, for example, HID is used to
             interface with Xbox controlllers. In those cases, XInput-specific functionality (like <see cref="T:UnityEngine.InputSystem.XInput.XInputController.Capabilities"/>)
             will not be available.
            
             On Windows, XInput controllers will be reported with <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.interfaceName"/>
             set to <c>"XInput"</c> and with a JSON representation of <a
             href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_capabilities">XINPUT_CAPABILITIES</a>
             available in <see cref="P:UnityEngine.InputSystem.Layouts.InputDeviceDescription.capabilities"/>. This means that you match on those
             <c>subType</c> and/or <c>flags</c> for example.
            
             <example>
             <code>
             // Create an XInput-specific guitar layout subtype.
             // NOTE: Works only on Windows.
             InputSystem.RegisterLayout(@"
                 {
                     ""name"" : ""XInputGuitar"",
                     ""displayName"" : ""Guitar"",
                     ""extend"" : ""XInputController"",
                     ""device"" : {
                         ""interface"" : ""XInput"",
                         ""capabilities"" : [
                             { ""path"" : ""subType"", ""value"" : ""6"" }
                         ]
                     }
                 }
             ");
             </code>
             </example>
            
             Now, when an XInput controller is connected and reports itself with the
             subtype "Guitar", it is turned into an "XInputGuitar" instead of an
             "XInputController".
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.XInput.XInputController.menu">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.startButton"/>.
            </summary>
            <value>Same control as <see cref="P:UnityEngine.InputSystem.Gamepad.startButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.XInput.XInputController.view">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Gamepad.selectButton"/>
            </summary>
            <value>Same control as <see cref="P:UnityEngine.InputSystem.Gamepad.selectButton"/>.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.XInput.XInputController.subType">
            <summary>
            What specific kind of XInput controller this is.
            </summary>
            <value>XInput device subtype.</value>
            <remarks>
            When the controller is picked up through interfaces other than XInput or through old versions of
            XInput, this will always be <see cref="F:UnityEngine.InputSystem.XInput.XInputController.DeviceSubType.Unknown"/>. Put another way, this value is
            meaningful only on recent Microsoft platforms.
            </remarks>
            <seealso href="https://docs.microsoft.com/en-us/windows/win32/xinput/xinput-and-controller-subtypes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.XInput.XInputController.flags">
            <summary>
            Return the device flags as reported by XInput.
            </summary>
            <value>XInput device flags.</value>
            <seealso href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_capabilities"/>
        </member>
        <member name="M:UnityEngine.InputSystem.XInput.XInputController.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputController.DeviceType">
            <summary>
            Controller type enumeration in <c>Type</c> field of <c>XINPUT_CAPABILITIES</c>.
            </summary>
            <remarks>
            See <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_capabilities">MSDN</a>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputController.DeviceSubType">
            <summary>
            Controller subtype enumeration in <c>SubType</c> field of <c>XINPUT_CAPABILITIES</c>.
            </summary>
            <remarks>
            See <a href="https://docs.microsoft.com/en-us/windows/win32/xinput/xinput-and-controller-subtypes">MSDN</a>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputController.DeviceFlags">
            <summary>
            Controller flags in <c>Flags</c> field of <c>XINPUT_CAPABILITIES</c>.
            </summary>
            <remarks>
            See <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_capabilities">MSDN</a>.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.IXboxOneRumble">
            <summary>
            Extended dual motor gamepad rumble that adds left and right trigger motors.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputSupport">
            <summary>
            Adds support for XInput controllers.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.XInput.XInputControllerWindows">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.XInput.XInputController"/> compatible game controller connected to a Windows desktop machine.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBindingResolver">
             <summary>
             Heart of the binding resolution machinery. Consumes lists of bindings
             and spits out out a list of resolved bindings together with their needed
             execution state.
             </summary>
             <remarks>
             One or more <see cref="T:UnityEngine.InputSystem.InputActionMap">action maps</see> can be added to the same
             resolver. The result is a combination of the binding state of all maps.
            
             The data set up by a resolver is for consumption by <see cref="T:UnityEngine.InputSystem.InputActionState"/>.
             Essentially, InputBindingResolver does all the wiring and <see cref="T:UnityEngine.InputSystem.InputActionState"/>
             does all the actual execution based on the resulting data.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionState.Initialize(UnityEngine.InputSystem.InputBindingResolver)"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputBindingResolver.bindingMask">
             <summary>
             Binding mask used to globally mask out bindings.
             </summary>
             <remarks>
             This is empty by default.
            
             The bindings of each map will be <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)">matched</see> against this
             binding. Any bindings that don't match will get skipped and not resolved to controls.
            
             Note that regardless of whether a binding will be resolved to controls or not, it will get
             an entry in <see cref="F:UnityEngine.InputSystem.InputBindingResolver.memory"/>. Otherwise we would have to have a more complicated
             mapping from <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> to a binding state in <see cref="F:UnityEngine.InputSystem.InputBindingResolver.memory"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingResolver.Dispose">
            <summary>
            Release native memory held by the resolver.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingResolver.StartWithPreviousResolve(UnityEngine.InputSystem.InputActionState,System.Boolean)">
            <summary>
            Steal the already allocated arrays from the given state.
            </summary>
            <param name="state">Action map state that was previously created.</param>
            <param name="isFullResolve">If false, the only thing that is allowed to change in the re-resolution
            is the list of controls. In other words, devices may have been added or removed but otherwise the configuration
            is exactly the same as in the last resolve. If true, anything may have changed and the resolver will only reuse
            allocations but not contents.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingResolver.AddActionMap(UnityEngine.InputSystem.InputActionMap)">
            <summary>
            Resolve and add all bindings and actions from the given map.
            </summary>
            <param name="actionMap"></param>
            <remarks>
            This is where all binding resolution happens for actions. The method walks through the binding array
            in <paramref name="actionMap"/> and adds any controls, interactions, processors, and composites as it goes.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.PenButton">
            <summary>
            Enumeration of buttons on a <see cref="T:UnityEngine.InputSystem.Pen"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Tip">
            <summary>
            Button at the tip of a pen.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Pen.tip"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Eraser">
            <summary>
            Button located end of pen opposite to <see cref="F:UnityEngine.InputSystem.PenButton.Tip"/>.
            </summary>
            <remarks>
            Pens do not necessarily have an eraser. If a pen doesn't, the respective button
            does nothing and will always be unpressed.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Pen.eraser"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.BarrelFirst">
            <summary>
            First button on the side of the pen.
            </summary>
            <see cref="P:UnityEngine.InputSystem.Pen.firstBarrelButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.BarrelSecond">
            <summary>
            Second button on the side of the pen.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Pen.secondBarrelButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.InRange">
            <summary>
            Artificial button that indicates whether the pen is in detection range or not.
            </summary>
            <remarks>
            Range detection may not be supported by a pen/tablet.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Pen.inRange"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.BarrelThird">
            <summary>
            Third button on the side of the pen.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.Pen.thirdBarrelButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.BarrelFourth">
            <summary>
            Fourth button on the side of the pen.
            </summary>
            <see cref="P:UnityEngine.InputSystem.Pen.fourthBarrelButton"/>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Barrel1">
            <summary>
            Synonym for <see cref="F:UnityEngine.InputSystem.PenButton.BarrelFirst"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Barrel2">
            <summary>
            Synonym for <see cref="F:UnityEngine.InputSystem.PenButton.BarrelSecond"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Barrel3">
            <summary>
            Synonym for <see cref="F:UnityEngine.InputSystem.PenButton.BarrelThird"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.PenButton.Barrel4">
            <summary>
            Synonym for <see cref="F:UnityEngine.InputSystem.PenButton.BarrelFourth"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Pen">
             <summary>
             Represents a pen/stylus input device.
             </summary>
             <remarks>
             Unlike mice but like touch, pens are absolute pointing devices moving across a fixed
             surface area.
            
             The <see cref="P:UnityEngine.InputSystem.Pen.tip"/> acts as a button that is considered pressed as long as the pen is in contact with the
             tablet surface.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.tip">
            <summary>
            The tip button of the pen.
            </summary>
            <value>Control representing the tip button.</value>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.Tip"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.eraser">
            <summary>
            The eraser button of the pen, i.e. the button on the end opposite to the tip.
            </summary>
            <value>Control representing the eraser button.</value>
            <remarks>
            If the pen does not have an eraser button, this control will still be present
            but will not trigger.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.Eraser"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.firstBarrelButton">
            <summary>
            The button on the side of the pen barrel and located closer to the tip of the pen.
            </summary>
            <value>Control representing the first side button.</value>
            <remarks>
            If the pen does not have barrel buttons, this control will still be present
            but will not trigger.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.BarrelFirst"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.secondBarrelButton">
            <summary>
            The button on the side of the pen barrel and located closer to the eraser end of the pen.
            </summary>
            <value>Control representing the second side button.</value>
            <remarks>
            If the pen does not have barrel buttons, this control will still be present
            but will not trigger.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.BarrelSecond"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.thirdBarrelButton">
            <summary>
            Third button the side of the pen barrel.
            </summary>
            <value>Control representing the third side button.</value>
            <remarks>
            If the pen does not have a third barrel buttons, this control will still be present
            but will not trigger.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.BarrelThird"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.fourthBarrelButton">
            <summary>
            Fourth button the side of the pen barrel.
            </summary>
            <value>Control representing the fourth side button.</value>
            <remarks>
            If the pen does not have a fourth barrel buttons, this control will still be present
            but will not trigger.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.PenButton.BarrelFourth"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.inRange">
             <summary>
             Button control that indicates whether the pen is in range of the tablet surface or not.
             </summary>
             <remarks>
             This is a synthetic control (<see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>).
            
             If range detection is not supported by the pen, this button will always be "pressed".
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.PenButton.InRange"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.tilt">
            <summary>
            Orientation of the pen relative to the tablet surface, i.e. the amount by which it is leaning
            over along the X and Y axis.
            </summary>
            <value>Control presenting the amount the pen is leaning over.</value>
            <remarks>
            X axis goes from [-1..1] left to right with -1 and 1 meaning the pen is flush with the tablet surface. Y axis
            goes from [-1..1] bottom to top.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.twist">
             <summary>
             Rotation of the pointer around its own axis. 0 means the pointer is facing away from the user (12 'o clock position)
             and ~1 means the pointer has been rotated clockwise almost one full rotation.
             </summary>
             <value>Control representing the twist of the pen around itself.</value>
             <remarks>
             Twist is generally only supported by pens and even among pens, twist support is rare. An example product that
             supports twist is the Wacom Art Pen.
            
             The axis of rotation is the vector facing away from the pointer surface when the pointer is facing straight up
             (i.e. the surface normal of the pointer surface). When the pointer is tilted, the rotation axis is tilted along
             with it.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.current">
            <summary>
            The pen that was active or connected last or <c>null</c> if there is no pen.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Pen.Item(UnityEngine.InputSystem.PenButton)">
            <summary>
            Return the given pen button.
            </summary>
            <param name="button">Pen button to return.</param>
            <exception cref="T:System.ArgumentException"><paramref name="button"/> is not a valid pen button.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Pen.MakeCurrent">
            <summary>
            Make this the last used pen, i.e. <see cref="P:UnityEngine.InputSystem.Pen.current"/>.
            </summary>
            <remarks>
            This is called automatically by the system when a pen is added or receives
            input.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Pen.OnRemoved">
            <summary>
            Called when the pen is removed from the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Pen.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.InputSettings">
             <summary>
             Project-wide input settings.
             </summary>
             <remarks>
             Several aspects of the input system can be customized to tailor how the system functions to the
             specific needs of a project. These settings are collected in this class. There is one global
             settings object active at any one time. It can be accessed and set through <see cref="P:UnityEngine.InputSystem.InputSystem.settings"/>.
            
             Changing a setting on the object takes effect immediately. It also triggers the
             <see cref="E:UnityEngine.InputSystem.InputSystem.onSettingsChange"/> callback.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.settings"/>
             <seealso cref="E:UnityEngine.InputSystem.InputSystem.onSettingsChange"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSettings.iOSSettings">
            <summary>
            Project-wide input settings for the iOS/tvOS platform.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.iOSSettings.motionUsage">
            <summary>
            Setting for access to the device's motion sensors (such as <see cref="T:UnityEngine.InputSystem.StepCounter"/>).
            </summary>
            <remarks>
            Alternatively, you can manually add <c>Privacy - Motion Usage Description</c> to the Info.plist file.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.StepCounter"/>
            <seealso href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsmotionusagedescription"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.iOS">
            <summary>
            iOS/tvOS-specific settings.
            </summary>
            <remarks>
            This is only accessible in the editor or in iOS/tvOS players.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.updateMode">
             <summary>
             Allows you to control how the input system handles updates. In other words, how and when pending input events are processed.
             </summary>
             <value>When to run input updates.</value>
             <remarks>
             By default, input updates will automatically be triggered as part of the player loop.
             If <c>updateMode</c> is set to <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInDynamicUpdate"/>
             (the default), then right at the beginning of a dynamic update (i.e. before all
             <c>MonoBehaviour.Update</c> methods are called), input is processed. And if <c>updateMode</c>
             is set to <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInFixedUpdate"/>, then right at the beginning
             of each fixed update (i.e. before all <c>MonoBehaviour.FixedUpdate</c> methods are
             called), input is processed.
            
             Additionally, if there are devices that need updates right before rendering (see <see
             cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>), an extra update will be run right before
             rendering. This special update will only consume input on devices that have
             <see cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/> set to <c>true</c>.
            
             You can run updates manually using <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>. Doing so
             outside of tests is only recommended, however, if <c>updateMode</c> is set to
             <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsManually"/> (in which case it is actually required
             for input to be processed at all).
            
             Note that in the editor, input updates will also run before each editor update
             (i.e. as part of <c>EditorApplication.update</c>). Player and editor input state
             are kept separate, though, so any input consumed in editor updates will not be visible
             in player updates and vice versa.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.compensateForScreenOrientation">
             <summary>
             If true, sensors that deliver rotation values on handheld devices will automatically adjust
             rotations when the screen orientation changes.
             </summary>
             <remarks>
             This is enabled by default.
            
             If enabled, rotation values will be rotated around Z. In <see cref="F:UnityEngine.ScreenOrientation.Portrait"/>, values
             remain unchanged. In <see cref="F:UnityEngine.ScreenOrientation.PortraitUpsideDown"/>, they will be rotated by 180 degrees.
             In <see cref="F:UnityEngine.ScreenOrientation.LandscapeLeft"/> by 90 degrees, and in <see cref="F:UnityEngine.ScreenOrientation.LandscapeRight"/>
             by 270 degrees.
            
             Sensors affected by this setting are <see cref="T:UnityEngine.InputSystem.Accelerometer"/>, <see cref="T:UnityEngine.Compass"/>, and <see cref="T:UnityEngine.InputSystem.Gyroscope"/>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.CompensateDirectionProcessor"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.filterNoiseOnCurrent">
             <summary>
             Currently: Option is deprecated and has no influence on the system. Filtering on noise is always enabled.
             Previously: Whether to not make a device <c>.current</c> (see <see cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>)
             when there is only noise in the input.
             </summary>
             <remarks>
             We add extra processing every time input is
             received on a device that is considered noisy. These devices are those that
             have at least one control that is marked as <see cref="P:UnityEngine.InputSystem.InputControl.noisy"/>.
             A good example is the PS4 controller which has a gyroscope sensor built into
             the device. Whereas sticks and buttons on the device require user interaction
             to produce non-default values, the gyro will produce varying values even if
             the device just sits there without user interaction.
            
             Without noise filtering, a PS4 controller will thus continually make itself
             current as it will send a continuous stream of input even when not actively
             used by the player. By toggling this property on, each input event will be
             run through a noise mask. Only if state has changed outside of memory areas
             marked as noise will the input be considered valid user interaction and the
             device will be made current. Note that in this process, the system does
             <em>not</em> determine whether non-noisy controls on the device have actually
             changed value. All the system establishes is whether such controls have changed
             <em>state</em>. However, processing such as for deadzones may cause values
             to not effectively change even though the non-noisy state of the device has
             changed.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultDeadzoneMin">
             <summary>
             Default value used when nothing is set explicitly on <see cref="F:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor.min"/>
             or <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.min"/>.
             </summary>
             <value>Default lower limit for deadzones.</value>
             <remarks>
             "Deadzones" refer to limits established for the range of values accepted as input
             on a control. If the value for the control falls outside the range, i.e. below the
             given minimum or above the given maximum, the value is clamped to the respective
             limit.
            
             This property configures the default lower bound of the value range.
            
             Note that deadzones will by default re-normalize values after clamping. This means that
             inputs at the lower and upper end are dropped and that the range in-between is re-normalized
             to [0..1].
            
             Note that deadzones preserve the sign of inputs. This means that both the upper and
             the lower deadzone bound extend to both the positive and the negative range. For example,
             a deadzone min of 0.1 will clamp values between -0.1 and +0.1.
            
             The most common example of where deadzones are used are the sticks on gamepads, i.e.
             <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>. Sticks will
             usually be wobbly to some extent (just how wobbly varies greatly between different
             types of controllers -- which means that often deadzones need to be configured on a
             per-device type basis). Using deadzones, stick motion at the extreme ends of the spectrum
             can be filtered out and noise in these areas can effectively be eliminated this way.
            
             The default value for this property is 0.125.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultDeadzoneMax">
             <summary>
             Default value used when nothing is set explicitly on <see cref="F:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor.max"/>
             or <see cref="F:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor.max"/>.
             </summary>
             <value>Default upper limit for deadzones.</value>
             <remarks>
             "Deadzones" refer to limits established for the range of values accepted as input
             on a control. If the value for the control falls outside the range, i.e. below the
             given minimum or above the given maximum, the value is clamped to the respective
             limit.
            
             This property configures the default upper bound of the value range.
            
             Note that deadzones will by default re-normalize values after clamping. This means that
             inputs at the lower and upper end are dropped and that the range in-between is re-normalized
             to [0..1].
            
             Note that deadzones preserve the sign of inputs. This means that both the upper and
             the lower deadzone bound extend to both the positive and the negative range. For example,
             a deadzone max of 0.95 will clamp values of &gt;0.95 and &lt;-0.95.
            
             The most common example of where deadzones are used are the sticks on gamepads, i.e.
             <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/> and <see cref="P:UnityEngine.InputSystem.Gamepad.rightStick"/>. Sticks will
             usually be wobbly to some extent (just how wobbly varies greatly between different
             types of controllers -- which means that often deadzones need to be configured on a
             per-device type basis). Using deadzones, stick motion at the extreme ends of the spectrum
             can be filtered out and noise in these areas can effectively be eliminated this way.
            
             The default value for this property is 0.925.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Processors.StickDeadzoneProcessor"/>
             <seealso cref="T:UnityEngine.InputSystem.Processors.AxisDeadzoneProcessor"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint">
             <summary>
             The default value threshold for when a button is considered pressed. Used if
             no explicit thresholds are set on parameters such as <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
             or <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/>.
             </summary>
             <value>Default button press threshold.</value>
             <remarks>
             In the input system, each button constitutes a full floating-point value. Pure
             toggle buttons, such as <see cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/> for example, will simply
             alternate between 0 (not pressed) and 1 (pressed). However, buttons may also have
             ranges, such as <see cref="P:UnityEngine.InputSystem.Gamepad.leftTrigger"/> for example. When used in a context
             where a clear distinction between pressed and not pressed is required, we need a value
             beyond which we consider the button pressed.
            
             By setting this property, the default value for this can be configured. If a button
             has a value equal to or greater than the button press point, it is considered pressed.
            
             The default value is 0.5.
            
             Any value will implicitly be clamped to <c>0.0001f</c> as allowing a value of 0 would
             cause all buttons in their default state to already be pressed.
            
             Lowering the button press point will make triggers feel more like hair-triggers (akin
             to using the hair-trigger feature on Xbox Elite controllers). However, it may make using
             the directional buttons (i.e. <see cref="P:UnityEngine.InputSystem.Controls.StickControl.up"/> etc) be fickle as
             solely moving in only one direction with sticks isn't easy. To counteract that, the button
             press points on the stick buttons can be raised.
            
             Another solution is to simply lower the press points on the triggers specifically.
            
             <example>
             <code>
             InputSystem.RegisterLayoutOverride(@"
                 {
                     ""name"" : ""HairTriggers"",
                     ""extend"" : ""Gamepad"",
                     ""controls"" [
                         { ""name"" : ""leftTrigger"", ""parameters"" : ""pressPoint=0.1"" },
                         { ""name"" : ""rightTrigger"", ""parameters"" : ""pressPoint=0.1"" }
                     ]
                 }
             ");
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.buttonReleaseThreshold"/>
             <seealso cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>
             <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
             <seealso cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/>
             <seealso cref="F:UnityEngine.InputSystem.Interactions.TapInteraction.pressPoint"/>
             <seealso cref="F:UnityEngine.InputSystem.Interactions.SlowTapInteraction.pressPoint"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValueAsButton(System.Int32)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.buttonReleaseThreshold">
             <summary>
             The percentage of <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> at which a button that was pressed
             is considered released again.
             </summary>
             <remarks>
             This setting helps avoid flickering around the button press point by introducing something akin to a
             "dead zone" below <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>. Once a button has been pressed to a magnitude
             of at least <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>, it is considered pressed and keeps being considered pressed
             until its magnitude falls back to a value of or below <see cref="P:UnityEngine.InputSystem.InputSettings.buttonReleaseThreshold"/> percent of
             <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
            
             This is a percentage rather than a fixed value so it allows computing release
             points even when the press point has been customized. If, for example, a <see cref="T:UnityEngine.InputSystem.Interactions.PressInteraction"/>
             sets a custom <see cref="F:UnityEngine.InputSystem.Interactions.PressInteraction.pressPoint"/>, the respective release point
             can still be computed from the percentage set here.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultTapTime">
             <summary>
             Default time (in seconds) within which a press and release has to occur for it
             to be registered as a "tap".
             </summary>
             <value>Default upper limit on press durations for them to register as taps.</value>
             <remarks>
             A tap is considered as a quick press-and-release on a button-like input control.
             This property determines just how quick the press-and-release has to be, i.e. what
             the maximum time is that can elapse between the button being pressed and released
             again. If the delay between press and release is greater than this time, the
             input does not qualify as a tap.
            
             The default tap time is 0.2 seconds.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultSlowTapTime">
             <summary>
             Allows you to specify the default minimum duration required of a press-and-release interaction to evaluate to a slow-tap-interaction.
             </summary>
             <value>The default minimum duration that the button-like input control must remain in pressed state for the interaction to evaluate to a slow-tap-interaction.</value>
             <remarks>
             A slow-tap-interaction is considered as a press-and-release sequence on a button-like input control.
             This property determines the lower bound of the duration that must elapse between the button being pressed and released again.
             If the delay between press and release is less than this duration, the input does not qualify as a slow-tap-interaction.
            
             The default slow-tap time is 0.5 seconds.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.defaultHoldTime">
             <summary>
             Allows you to specify the default minimum duration required of a press-and-release interaction to evaluate to a hold-interaction.
             </summary>
             <value>The default minimum duration that the button-like input control must remain in pressed state for the interaction to evaluate to a hold-interaction.</value>
             <remarks>
             A hold-interaction is considered as a press-and-release sequence on a button-like input control.
             This property determines the lower bound of the duration that must elapse between the button being pressed and released again.
             If the delay between press and release is less than this duration, the input does not qualify as a hold-interaction.
            
             The default hold time is 0.4 seconds.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.tapRadius">
             <summary>
             Allows you to specify the default maximum radius that a touch contact may be moved from its origin to evaluate to a tap-interaction.
             </summary>
             <value>The default maximum radius (in pixels) that a touch contact may be moved from its origin to evaluate to a tap-interaction.</value>
             <remarks>
             A tap-interaction or slow-tap-interaction is considered as a press-and-release sequence.
             If the associated touch contact is moved a distance equal or greater to the value of this setting,
             the input sequence do not qualify as a tap-interaction.
            
             The default tap-radius is 5 pixels.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.SlowTapInteraction"/>
             <seealso cref="T:UnityEngine.InputSystem.Interactions.MultiTapInteraction"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.multiTapDelayTime">
             <summary>
             Allows you to specify the maximum duration that may pass between taps in order to evaluate to a multi-tap-interaction.
             </summary>
             <value>The default maximum duration (in seconds) that may pass between taps in order to evaluate to a multi-tap-interaction.</value>
             <remarks>
             A multi-tap interaction is considered as multiple press-and-release sequences.
             This property defines the maximum duration that may pass between these press-and-release sequences.
             If consecutive taps (press-and-release sequences) occur with a inter-sequence duration exceeding
             this property, the interaction do not qualify as a multi-tap-interaction.
            
             The default multi-tap delay time is 0.75 seconds.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultTapTime"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior">
             <summary>
             When <c>Application.runInBackground</c> is true, this property determines what happens when application focus changes
             (see <a href="https://docs.unity3d.com/ScriptReference/Application-isFocused.html">Application.isFocused</a>) changes and how we handle
             input while running the background.
             </summary>
             <value>What to do with input while not having focus. Set to <see cref="F:UnityEngine.InputSystem.InputSettings.BackgroundBehavior.ResetAndDisableNonBackgroundDevices"/> by default.</value>
             <remarks>
             If <c>Application.runInBackground</c> is false, the value of this property is ignored. In that case, nothing happens when
             focus is lost. However, when focus is regained, <see cref="M:UnityEngine.InputSystem.InputSystem.TrySyncDevice(UnityEngine.InputSystem.InputDevice)"/> is called on all devices.
            
             Note that in the editor as well as in development standalone players, <c>Application.runInBackground</c> will effectively always be
             turned on. The editor keeps the player loop running regardless of Game View focus for as long as the editor is active and in play mode
             and development players will implicitly turn on the setting during the build process.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.editorInputBehaviorInPlayMode"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.editorInputBehaviorInPlayMode">
             <summary>
             Determines how player focus is handled in the editor with respect to input.
             </summary>
             <remarks>
             This setting only has an effect while in play mode (see <a href="https://docs.unity3d.com/ScriptReference/Application-isPlaying.html">Application.isPlaying</a>).
             While not in play mode, all input is invariably routed to the editor.
            
             The editor generally treats Game View focus as equivalent to application focus (see <a href="https://docs.unity3d.com/ScriptReference/Application-isFocused.html">Application.isFocused</a>).
             In other words, as long as any Game View has focus, the player is considered to have input focus. As soon as focus is transferred to a non-Game View
             <c>EditorWindow</c> or the editor as a whole loses focus, the player is considered to have lost input focus.
            
             However, unlike in built players, the editor will keep running the player loop while in play mode regardless of whether a Game View is focused
             or not. This essentially equates to <a href="https://docs.unity3d.com/ScriptReference/Application-runInBackground.html">Application.runInBackground</a> always
             being true in the editor.
            
             To accommodate this behavior, this setting determines where input is routed while the player loop is running with no Game View being focused. As such,
             it also dictates which input reaches the editor (if any) while the game is playing.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.maxEventBytesPerUpdate">
             <summary>
             Upper limit on the amount of bytes worth of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s processed in a single
             <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
             </summary>
             <remarks>
             This setting establishes a bound on the amount of input event data processed in a single
             update and thus limits throughput allowed for input. This prevents long stalls from
             leading to long delays in input processing.
            
             When the limit is exceeded, all events remaining in the buffer are thrown away (the
             <see cref="T:UnityEngine.InputSystem.LowLevel.InputEventBuffer"/> is reset) and an error is logged. After that, the current
             update will abort and early out.
            
             Setting this property to 0 or a negative value will disable the limit.
            
             The default value is 5MB.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
             <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.sizeInBytes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.maxQueuedEventsPerUpdate">
             <summary>
             Upper limit on the number of <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/>s that can be queued within one
             <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>.
             <remarks>
             This settings establishes an upper limit on the number of events that can be queued
             using <see cref="M:UnityEngine.InputSystem.InputSystem.QueueEvent(UnityEngine.InputSystem.LowLevel.InputEventPtr)"/> during a single update. This prevents infinite
             loops where an action callback queues an event that causes the action callback to
             be called again which queues an event...
            
             Note that this limit only applies while the input system is updating. There is no limit
             on the number of events that can be queued outside of this time, but those will be queued
             into the next frame where the <see cref="P:UnityEngine.InputSystem.InputSettings.maxEventBytesPerUpdate"/> setting will apply.
            
             The default value is 1000.
             </remarks>
             </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.supportedDevices">
             <summary>
             List of device layouts used by the project.
             </summary>
             <remarks>
             This would usually be one of the high-level abstract device layouts. For example, for
             a game that supports touch, gamepad, and keyboard&amp;mouse, the list would be
             <c>{ "Touchscreen", "Gamepad", "Mouse", "Keyboard" }</c>. However, nothing prevents the
             the user from adding something a lot more specific. A game that can only be played
             with a DualShock controller could make this list just be <c>{ "DualShockGamepad" }</c>,
             for example.
            
             In the editor, we use the information to filter what we display to the user by automatically
             filtering out irrelevant controls in the control picker and such.
            
             The information is also used when a new device is discovered. If the device is not listed
             as supported by the project, it is ignored.
            
             The list is empty by default. An empty list indicates that no restrictions are placed on what
             devices are supported. In this editor, this means that all possible devices and controls are
             shown.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.disableRedundantEventsMerging">
             <summary>
             Disables merging of redundant input events (at the moment, only mouse events).
             Disable it if you want to get all events.
             </summary>
             <remarks>
             When using a high frequency mouse, the number of mouse move events in each frame can be
             very large, which can have a negative effect on performance. To help with this,
             merging events can be used which coalesces consecutive mouse move events into a single
             input action update.
            
             For example, if there are one hundred mouse events, but they are all position updates
             with no clicks, and there is an input action callback handler for the mouse position, that
             callback handler will only be called one time in the current frame. Delta and scroll
             values for the mouse will still be accumulated across all mouse events.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputSettings.shortcutKeysConsumeInput">
            <summary>
            Improves shortcut key support by making composite controls consume control input
            </summary>
            <remarks>
            Actions are exclusively triggered and will consume/block other actions sharing the same input.
            E.g. when pressing the 'Shift+B' keys, the associated action would trigger but any action bound to just the 'B' key would be prevented from triggering at the same time.
            Please note that enabling this will cause actions with composite bindings to consume input and block any other actions which are enabled and sharing the same controls.
            Input consumption is performed in priority order, with the action containing the greatest number of bindings checked first.
            Therefore actions requiring fewer keypresses will not be triggered if an action using more keypresses is triggered and has overlapping controls.
            This works for shortcut keys, however in other cases this might not give the desired result, especially where there are actions with the exact same number of composite controls, in which case it is non-deterministic which action will be triggered.
            These conflicts may occur even between actions which belong to different Action Maps e.g. if using an UIInputModule with the Arrow Keys bound to the Navigate Action in the UI Action Map, this would interfere with other Action Maps using those keys.
            However conflicts would not occur between actions which belong to different Action Assets.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputSettings.SetInternalFeatureFlag(System.String,System.Boolean)">
            <summary>
            Enable or disable an internal feature by its name.
            </summary>
            <param name="featureName">Name of the feature.</param>
            <param name="enabled">Whether to enable or disable the feature.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="featureName"/> is <c>null</c> or empty.</exception>
            <remarks>
            This method is intended for experimental features. These must be enabled/disabled from code.
            Setting or unsetting a feature flag will not be persisted in an <c>.inputsettings</c> file.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSettings.UpdateMode">
             <summary>
             How the input system should update.
             </summary>
             <remarks>
             By default, the input system will run event processing as part of the player loop. In the default configuration,
             the processing will happens once before every every dynamic update (<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">Update</a>),
             i.e. <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInDynamicUpdate"/> is the default behavior.
            
             There are two types of updates not governed by UpdateMode. One is <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.Editor"/> which
             will always be enabled in the editor and govern input updates for <see cref="T:UnityEditor.EditorWindow"/>s in
             sync to <see cref="F:UnityEditor.EditorApplication.update"/>.
            
             The other update type is <see cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>. This type of update is enabled and disabled
             automatically in response to whether devices are present requiring this type of update (<see
             cref="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender"/>). This update does not consume extra state.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.Update"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.InputUpdateType"/>
             <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html"/>
             <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInDynamicUpdate">
             <summary>
             Automatically run input updates right before every <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">Update</a>.
            
             In this mode, no processing happens specifically for fixed updates. Querying input state in
             <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">FixedUpdate</a> will result in errors being logged in the editor and in
             development builds. In release player builds, the value of the dynamic update state is returned.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInFixedUpdate">
             <summary>
             Automatically input run updates right before every <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">FixedUpdate</a>.
            
             In this mode, no processing happens specifically for dynamic updates. Querying input state in
             <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">Update</a> will result in errors being logged in the editor and in
             development builds. In release player builds, the value of the fixed update state is returned.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsManually">
             <summary>
             Do not run updates automatically. In this mode, <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> must be called
             manually to update input.
            
             This mode is most useful for placing input updates in the frame explicitly at an exact location.
            
             Note that failing to call <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/> may result in a lot of events
             accumulating or some input getting lost.
             </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSettings.BackgroundBehavior">
            <summary>
            Determines how the applications behaves when running in the background. See <see cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>.
            </summary>
            <seealso href="https://docs.unity3d.com/ScriptReference/Application-isFocused.html"/>
            <seealso href="https://docs.unity3d.com/ScriptReference/Application-runInBackground.html"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.editorInputBehaviorInPlayMode"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.BackgroundBehavior.ResetAndDisableNonBackgroundDevices">
             <summary>
             When the application loses focus, issue a <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/> call on every <see cref="T:UnityEngine.InputSystem.InputDevice"/> that is
             not marked as <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/> and then disable the device (see <see cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
             and <see cref="P:UnityEngine.InputSystem.InputDevice.enabled"/>). Devices that <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/> will not be touched and will
             keep running as is.
            
             In effect, this setting will "soft-reset" all devices that cannot receive input while the application does
             not have focus. That is, it will reset all controls that are not marked as <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.dontReset"/>
             to their default state.
            
             When the application comes back into focus, all devices that have been reset and disabled will be re-enabled and a synchronization
             request (see <see cref="T:UnityEngine.InputSystem.LowLevel.RequestSyncCommand"/>) will be sent to each device.
            
             Devices that are added while the application is running in the background are treated like devices that were already present
             when losing focus. That is, if they cannot run in the background, they will be disabled until focus comes back.
            
             Note that the resets will cancel <see cref="T:UnityEngine.InputSystem.InputAction"/>s that are in progress from controls on devices that are being reset.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.BackgroundBehavior.ResetAndDisableAllDevices">
            <summary>
            Like <see cref="F:UnityEngine.InputSystem.InputSettings.BackgroundBehavior.ResetAndDisableNonBackgroundDevices"/> but instead treat all devices as having <see cref="P:UnityEngine.InputSystem.InputDevice.canRunInBackground"/>
            return false. This effectively means that all input is silenced while the application is running in the background.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.BackgroundBehavior.IgnoreFocus">
            <summary>
            Ignore all changes in focus and leave devices untouched. This also disables focus checks in <see cref="T:UnityEngine.InputSystem.UI.InputSystemUIInputModule"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputSettings.EditorInputBehaviorInPlayMode">
            <summary>
            Determines how player focus is handled with respect to input when we are in play mode in the editor.
            See <see cref="P:UnityEngine.InputSystem.InputSettings.editorInputBehaviorInPlayMode"/>. The setting does not have an effect
            when the editor is not in play mode.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.EditorInputBehaviorInPlayMode.PointersAndKeyboardsRespectGameViewFocus">
             <summary>
             When the game view does not have focus, input from <see cref="T:UnityEngine.InputSystem.Pointer"/> devices (such as <see cref="T:UnityEngine.InputSystem.Mouse"/> and <see cref="T:UnityEngine.InputSystem.Touchscreen"/>)
             is routed to the editor and not visible in player code. Input from devices such as <see cref="T:UnityEngine.InputSystem.Gamepad"/>s will continue to
             go to the game regardless of which <c>EditorWindow</c> is focused.
            
             This is the default. It makes sure that the devices that are used with the editor UI respect <c>EditorWindow</c> focus and thus
             do not lead to accidental inputs affecting the game. While at the same time letting all other input get through to the game.
             It does, however, mean that no other <c>EditorWindow</c> can tap input from these devices (such as <see cref="T:UnityEngine.InputSystem.Gamepad"/>s and <see cref="N:UnityEngine.InputSystem.HID"/>s).
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.EditorInputBehaviorInPlayMode.AllDevicesRespectGameViewFocus">
            <summary>
            When the game view does not have focus, all input is routed to the editor (and thus <c>EditorWindow</c>s). No input
            is received in the game regardless of the type of device generating it.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputSettings.EditorInputBehaviorInPlayMode.AllDeviceInputAlwaysGoesToGameView">
            <summary>
            All input is going to the game at all times. This most closely aligns input behavior in the editor with that in players. <see cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
            will be respected as in the player and devices may thus be disabled in the runtime based on Game View focus.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputAnalytics.StartupEventData">
             <summary>
             Data about what configuration we start up with.
             </summary>
             <remarks>
             Has data about the devices present at startup so that we can know what's being
             used out there. Also has data about devices we couldn't recognize.
            
             Note that we exclude devices that are always present (e.g. keyboard and mouse
             on desktops or touchscreen on phones).
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputAnalytics.FirstUserInteractionEventData">
            <summary>
            Data about when after startup the user first interacted with the application.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputAnalytics.ShutdownEventData">
            <summary>
            Data about what level of data we pumped through the system throughout its lifetime.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.IInputActionCollection">
            <summary>
            A collection of input actions (see <see cref="T:UnityEngine.InputSystem.InputAction"/>).
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.InputActionMap"/>
            <seealso cref="T:UnityEngine.InputSystem.InputActionAsset"/>
        </member>
        <member name="P:UnityEngine.InputSystem.IInputActionCollection.bindingMask">
             <summary>
             Optional mask applied to all bindings in the collection.
             </summary>
             <remarks>
             If this is not null, only bindings that match the mask will be used.
            
             Modifying this property while any of the actions in the collection are enabled will
             lead to the actions getting disabled temporarily and then re-enabled.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.IInputActionCollection.devices">
             <summary>
             Devices to use with the actions in this collection.
             </summary>
             <remarks>
             If this is set, actions in the collection will exclusively bind to devices
             in the given list. For example, if two gamepads are present in the system yet
             only one gamepad is listed here, then a "&lt;Gamepad&gt;/leftStick" binding will
             only bind to the gamepad in the list and not to the one that is only available
             globally.
            
             Modifying this property after bindings in the collection have already been resolved,
             will lead to <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> getting refreshed. If any of the actions
             in the collection are currently in progress (see <see cref="P:UnityEngine.InputSystem.InputAction.phase"/>),
             the actions will remain unaffected and in progress except if the controls currently
             driving them (see <see cref="P:UnityEngine.InputSystem.InputAction.activeControl"/>) are no longer part of any
             of the selected devices. In that case, the action is <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.IInputActionCollection.controlSchemes">
            <summary>
            List of control schemes defined for the set of actions.
            </summary>
            <remarks>
            Control schemes are optional and the list may be empty.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputActionCollection.Contains(UnityEngine.InputSystem.InputAction)">
            <summary>
            Check whether the given action is contained in this collection.
            </summary>
            <param name="action">An arbitrary input action.</param>
            <returns>True if the given action is contained in the collection, false if not.</returns>
            <remarks>
            Calling this method will not allocate GC memory (unlike when iterating generically
            over the collection). Also, a collection may have a faster containment check rather than
            having to search through all its actions.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputActionCollection.Enable">
            <summary>
            Enable all actions in the collection.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputActionCollection.Disable">
            <summary>
            Disable all actions in the collection.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
        </member>
        <member name="T:UnityEngine.InputSystem.IInputActionCollection2">
            <summary>
            An extended version of <see cref="T:UnityEngine.InputSystem.IInputActionCollection"/>.
            </summary>
            <remarks>
            This interface will be merged into <see cref="T:UnityEngine.InputSystem.IInputActionCollection"/> in a future (major) version.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.IInputActionCollection2.bindings">
            <summary>
            Iterate over all bindings in the collection of actions.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputActionCollection2.FindAction(System.String,System.Boolean)">
             <summary>
             Find an <see cref="T:UnityEngine.InputSystem.InputAction"/> in the collection by its <see cref="P:UnityEngine.InputSystem.InputAction.name"/> or
             by its <see cref="P:UnityEngine.InputSystem.InputAction.id"/> (in string form).
             </summary>
             <param name="actionNameOrId">Name of the action as either a "map/action" combination (e.g. "gameplay/fire") or
             a simple name. In the former case, the name is split at the '/' slash and the first part is used to find
             a map with that name and the second part is used to find an action with that name inside the map. In the
             latter case, all maps are searched in order and the first action that has the given name in any of the maps
             is returned. Note that name comparisons are case-insensitive.
            
             Alternatively, the given string can be a GUID as given by <see cref="P:UnityEngine.InputSystem.InputAction.id"/>.</param>
             <param name="throwIfNotFound">If <c>true</c>, instead of returning <c>null</c> when the action
             cannot be found, throw <c>ArgumentException</c>.</param>
             <returns>The action with the corresponding name or <c>null</c> if no matching action could be found.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionNameOrId"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">Thrown if <paramref name="throwIfNotFound"/> is true and the
             action could not be found. -Or- If <paramref name="actionNameOrId"/> contains a slash but is missing
             either the action or the map name.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputActionCollection2.FindBinding(UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputAction@)">
             <summary>
             Find the index of the first binding that matches the given mask.
             </summary>
             <param name="mask">A binding. See <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> for details.</param>
             <param name="action">Receives the action on which the binding was found. If none was found,
             will be set to <c>null</c>.</param>
             <returns>Index into <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/> of the binding
             that matches <paramref name="mask"/>. If no binding matches, will return -1.</returns>
             <remarks>
             For details about matching bindings by a mask, see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.
            
             <example>
             <code>
             var index = playerInput.actions.FindBinding(
                 new InputBinding { path = "&lt;Gamepad&gt;/buttonSouth" },
                 out var action);
            
             if (index != -1)
                 Debug.Log($"The A button is bound to {action}");
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="P:UnityEngine.InputSystem.IInputActionCollection2.bindings"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Joystick">
             <summary>
             A joystick with an arbitrary number of buttons and axes.
             </summary>
             <remarks>
             Joysticks are somewhat hard to classify as there is little commonality other
             than that there is one main stick 2D control and at least one button. From the
             input system perspective, everything that is not a <see cref="T:UnityEngine.InputSystem.Gamepad"/> and
             that has at least one <see cref="P:UnityEngine.InputSystem.Joystick.stick"/> and one <see cref="P:UnityEngine.InputSystem.Joystick.trigger"/> control
             is considered a candidate for being a joystick.
            
             Optionally, a joystick may also have the ability to <see cref="P:UnityEngine.InputSystem.Joystick.twist"/>, i.e.
             for the stick to rotate around its own axis, and at least one <see cref="P:UnityEngine.InputSystem.Joystick.hatswitch"/>.
            
             Note that devices based on Joystick may have many more controls. Joystick
             itself only defines a minimum required to separate joysticks as a concept
             from other types of devices.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.trigger">
            <summary>
            The primary trigger button of the joystick.
            </summary>
            <value>Control representing the primary trigger button.</value>
            <remarks>
            This is the <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/> type control on the joystick
            that has the <see cref="F:UnityEngine.InputSystem.CommonUsages.PrimaryTrigger"/> usage.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.stick">
            <summary>
            The 2D axis of the stick itself.
            </summary>
            <value>Control representing the main joystick axis.</value>
            <remarks>
            This is the <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/> type control on the joystick
            that has the <see cref="F:UnityEngine.InputSystem.CommonUsages.Primary2DMotion"/> usage.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.twist">
            <summary>
            An optional control representing the rotation of the stick around its
            own axis (i.e. side-to-side circular motion). If not supported, will be
            <c>null</c>.
            </summary>
            <value>Control representing the twist motion of the joystick.</value>
            <remarks>
            This is the <see cref="T:UnityEngine.InputSystem.Controls.AxisControl"/> type control on the joystick
            that has the <see cref="F:UnityEngine.InputSystem.CommonUsages.Twist"/> usage.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.hatswitch">
            <summary>
            An optional control representing a four-way "hat switch" on the
            joystick. If not supported, will be <c>null</c>.
            </summary>
            <value>Control representing a hatswitch on the joystick.</value>
            <remarks>
            Hat switches are usually thumb-operated four-way switches that operate
            much like the "d-pad" on a gamepad (see <see cref="P:UnityEngine.InputSystem.Gamepad.dpad"/>).
            If present, this is the <see cref="T:UnityEngine.InputSystem.Controls.Vector2Control"/> type control on the
            joystick that has the <see cref="F:UnityEngine.InputSystem.CommonUsages.Hatswitch"/> usage.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.current">
            <summary>
            The joystick that was added or used last. Null if there is none.
            </summary>
            <value>Joystick that was added or used last.</value>
            <remarks>
            See <see cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/> for details about when a device
            is made current.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.Joystick.all"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Joystick.all">
             <summary>
             A list of joysticks currently connected to the system.
             </summary>
             <value>All currently connected joystick.</value>
             <remarks>
             Does not cause GC allocation.
            
             Do <em>not</em> hold on to the value returned by this getter but rather query it whenever
             you need it. Whenever the joystick setup changes, the value returned by this getter
             is invalidated.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Joystick.current"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Joystick.FinishSetup">
            <summary>
            Called when the joystick has been created but before it is added
            to the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Joystick.MakeCurrent">
            <summary>
            Make the joystick the <see cref="P:UnityEngine.InputSystem.Joystick.current"/> one.
            </summary>
            <remarks>
            This is called automatically by the input system when a device
            receives input or is added to the system. See <see cref="M:UnityEngine.InputSystem.InputDevice.MakeCurrent"/>
            for details.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Joystick.OnAdded">
            <summary>
            Called when the joystick is added to the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Joystick.OnRemoved">
            <summary>
            Called when the joystick is removed from the system.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.DefaultInputActions">
             <summary>
             A default <see cref="T:UnityEngine.InputSystem.InputAction"/> setup.
             </summary>
             <remarks>
             This class is auto-generated from the <c>DefaultAction.inputactions</c> asset that comes with the Input System.
            
             <example>
             <code>
             // Instantiate the default action set.
             var actions = new DefaultInputActions();
            
             // One way to use the actions:
             actions.Player.Enable();
             actions.Player.Fire.performed += _ => Fire();
             // Or:
             if (actions.Player.Fire.WasPressedThisFrame())
                 Fire();
            
             // Another way is with PlayerInput, for example:
             var playerInput = AddComponent&lt;PlayerInput&gt;();
             playerInput.actions = actions.asset;
             </code>
             </example>
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputExtensions">
            <summary>
            Various useful extension methods.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputExtensions.IsInProgress(UnityEngine.InputSystem.InputActionPhase)">
            <summary>
            Return true if the given phase is <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> or <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
            </summary>
            <param name="phase">An action phase.</param>
            <returns>True if the phase is started or performed.</returns>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputExtensions.IsEndedOrCanceled(UnityEngine.InputSystem.TouchPhase)">
            <summary>
            Return true if the given phase is <see cref="F:UnityEngine.InputSystem.TouchPhase.Canceled"/> or <see cref="F:UnityEngine.InputSystem.TouchPhase.Ended"/>, i.e.
            if a touch with that phase would no longer be ongoing.
            </summary>
            <param name="phase">A touch phase.</param>
            <returns>True if the phase indicates a touch that has ended.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputExtensions.IsActive(UnityEngine.InputSystem.TouchPhase)">
            <summary>
            Return true if the given phase is <see cref="F:UnityEngine.InputSystem.TouchPhase.Began"/>, <see cref="F:UnityEngine.TouchPhase.Moved"/>, or
            <see cref="F:UnityEngine.InputSystem.TouchPhase.Stationary"/>, i.e. if a touch with that phase would indicate an ongoing touch.
            </summary>
            <param name="phase">A touch phase.</param>
            <returns>True if the phase indicates a touch that is ongoing.</returns>
            <seealso cref="P:UnityEngine.InputSystem.Controls.TouchControl.phase"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputExtensions.IsModifierKey(UnityEngine.InputSystem.Key)">
            <summary>
            Check if a <see cref="T:UnityEngine.InputSystem.Key"/> enum value represents a modifier key.
            </summary>
            <param name="key">The key enum value you want to check.</param>
            <returns><c>true</c> if <paramref name="key"/> represents a modifier key, else <c>false</c>.</returns>
            <remarks>
            Modifier keys are any keys you can hold down to modify the output of other keys pressed simultaneously,
            such as the "shift" or "control" keys.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputExtensions.IsTextInputKey(UnityEngine.InputSystem.Key)">
            <summary>
            Check if a <see cref="T:UnityEngine.InputSystem.Key"/> enum value represents key generating text input.
            </summary>
            <param name="key">The key enum value you want to check.</param>
            <returns><c>true</c> if <paramref name="key"/> represents a key generating non-whitespace text input, else <c>false</c>.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionChange">
            <summary>
            Indicates what type of change related to an <see cref="T:UnityEngine.InputSystem.InputAction">input action</see> occurred.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputSystem.onActionChange"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionEnabled">
            <summary>
            An individual action was enabled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionDisabled">
            <summary>
            An individual action was disabled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Disable"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionMapEnabled">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.InputActionMap">action map</see> was enabled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionMapDisabled">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.InputActionMap">action map</see> was disabled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionStarted">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.InputAction"/> was started.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
            <seealso cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionPerformed">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.InputAction"/> was performed.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
            <seealso cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.ActionCanceled">
            <summary>
            An <see cref="T:UnityEngine.InputSystem.InputAction"/> was canceled.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
            <seealso cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.BoundControlsAboutToChange">
            <summary>
            Bindings on an action or set of actions are about to be re-resolved. This is called while <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>
            for actions are still untouched and thus still reflect the old binding state of each action.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.controls"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionChange.BoundControlsChanged">
            <summary>
            Bindings on an action or set of actions have been resolved. This is called after <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>
            have been updated.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.controls"/>
        </member>
        <member name="T:UnityEngine.InputSystem.Key">
             <summary>
             Enumeration of key codes.
             </summary>
             <remarks>
             Named according to the US keyboard layout which is used as a reference layout. Note, however,
             that keys are identified by physical location, not by the characters they generate. This means,
             for example, that <see cref="F:UnityEngine.InputSystem.Key.A"/> is always the key to the right of <see cref="F:UnityEngine.InputSystem.Key.CapsLock"/>,
             regardless of which key (if any) produces the "a" character on the current keyboard layout.
            
             To find the text character (if any) generated by a key according to the currently active keyboard
             layout, use the <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/> property of <see cref="T:UnityEngine.InputSystem.Controls.KeyControl"/>.
            
             <example>
             <code>
             // Look up key by key code.
             var aKey = Keyboard.current[Key.A];
            
             // Find out which text is produced by the key.
             Debug.Log($"The '{aKey.keyCode}' key produces '{aKey.displayName}' as text input");
             </code>
             </example>
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.None">
            <summary>
            Invalid key. Does not represent a key on the keyboard and is only used to have a
            default for the Key enumeration not represent any specific key.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Space">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.spaceKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Enter">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.enterKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Tab">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.tabKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Backquote">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.backquoteKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Quote">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.quoteKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Semicolon">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.semicolonKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Comma">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.commaKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Period">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.periodKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Slash">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.slashKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Backslash">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.backslashKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftBracket">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftBracketKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightBracket">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightBracketKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Minus">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.minusKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Equals">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.equalsKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.A">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.aKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.B">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.bKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.C">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.cKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.D">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.dKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.E">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.eKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.fKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.G">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.gKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.H">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.hKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.I">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.iKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.J">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.jKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.K">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.kKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.L">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.lKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.M">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.mKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.N">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.nKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.O">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.P">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.pKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Q">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.qKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.R">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.S">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.sKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.T">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.tKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.U">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.uKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.V">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.vKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.W">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.wKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.X">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.xKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Y">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.yKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Z">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit1">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit1Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit2">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit2Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit3">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit3Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit4">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit4Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit5">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit5Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit6">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit6Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit7">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit7Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit8">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit8Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit9">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit9Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Digit0">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.digit0Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftShift">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightShift">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightShiftKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftAlt">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftAltKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightAlt">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightAltKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.AltGr">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.RightAlt"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftCtrl">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftCtrlKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightCtrl">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightCtrlKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftMeta">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftMetaKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightMeta">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightMetaKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftWindows">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.LeftMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightWindows">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.RightMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftApple">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.LeftMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightApple">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.RightMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftCommand">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.LeftMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightCommand">
            <summary>
            Same as <see cref="F:UnityEngine.InputSystem.Key.RightMeta"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.ContextMenu">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.contextMenuKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Escape">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.escapeKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.LeftArrow">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.leftArrowKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.RightArrow">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.rightArrowKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.UpArrow">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.upArrowKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.DownArrow">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.downArrowKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Backspace">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.backspaceKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.PageDown">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.pageDownKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.PageUp">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.pageUpKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Home">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.homeKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.End">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.endKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Insert">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.insertKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Delete">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.deleteKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.CapsLock">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.capsLockKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumLock">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numLockKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.PrintScreen">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.printScreenKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.ScrollLock">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.scrollLockKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Pause">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.pauseKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadEnter">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadDivide">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadDivideKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadMultiply">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMultiplyKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadPlus">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadPlusKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadMinus">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMinusKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadPeriod">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadPeriodKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.NumpadEquals">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEqualsKey"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad0">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad0Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad1">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad1Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad2">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad2Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad3">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad3Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad4">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad4Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad5">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad5Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad6">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad6Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad7">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad7Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad8">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad8Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.Numpad9">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.numpad9Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F1">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f1Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F2">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f2Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F3">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f3Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F4">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f4Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F5">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f5Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F6">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f6Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F7">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f7Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F8">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f8Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F9">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f9Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F10">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f10Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F11">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f11Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.F12">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.f12Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.OEM1">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oem1Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.OEM2">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oem2Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.OEM3">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oem3Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.OEM4">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oem4Key"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.Key.OEM5">
            <summary>
            The <see cref="P:UnityEngine.InputSystem.Keyboard.oem5Key"/>.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.Keyboard">
             <summary>
             Represents a standard, physical PC-type keyboard.
             </summary>
             <remarks>
             Keyboards allow for both individual button input as well as text input. To receive button
             input, use the individual <see cref="T:UnityEngine.InputSystem.Controls.KeyControl"/>-type controls present on the keyboard.
             For example, <see cref="P:UnityEngine.InputSystem.Keyboard.aKey"/>. To receive text input, use the <see cref="E:UnityEngine.InputSystem.Keyboard.onTextInput"/>
             callback.
            
             The naming/identification of keys is agnostic to keyboard layouts. This means that <see cref="P:UnityEngine.InputSystem.Keyboard.aKey"/>,
             for example, will always be the key to the right of <see cref="P:UnityEngine.InputSystem.Keyboard.capsLockKey"/> regardless of where
             the current keyboard language layout puts the "a" character. This also means that having a
             binding to <c>"&lt;Keyboard&gt;/a"</c> on an <see cref="T:UnityEngine.InputSystem.InputAction"/>, for example, will
             bind to the same key regardless of locale -- an important feature, for example, for getting
             stable WASD bindings.
            
             To find what text character (if any) is produced by a key, you can use the key's <see
             cref="P:UnityEngine.InputSystem.InputControl.displayName"/> property. This can also be used in bindings.
             <c>"&lt;Keyboard&gt;/#(a)"</c>, for example, will bind to the key that produces the "a"
             character according to the currently active keyboard layout.
            
             To find out which keyboard layout is currently active, you can use the <see cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>
             property. Note that keyboard layout names are platform-dependent.
            
             Note that keyboard devices will always have key controls added for all keys in the
             <see cref="T:UnityEngine.InputSystem.Key"/> enumeration -- whether they are actually present on the physical
             keyboard or not. It is thus not possible to find out this way whether the underlying
             keyboard has certain keys or not.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.Keyboard.KeyCount">
            <summary>
            Total number of key controls on a keyboard, i.e. the number of controls
            in <see cref="P:UnityEngine.InputSystem.Keyboard.allKeys"/>.
            </summary>
            <value>Total number of key controls.</value>
        </member>
        <member name="E:UnityEngine.InputSystem.Keyboard.onTextInput">
             <summary>
             Event that is fired for every single character entered on the keyboard.
             </summary>
             <value>Triggered whenever the keyboard receives text input.</value>
             <remarks>
             <example>
             <code>
             // Let's say we want to do a typing game. We could define a component
             // something along those lines to match the typed input.
             public class MatchTextByTyping : MonoBehaviour
             {
                 public string text
                 {
                     get => m_Text;
                     set
                     {
                         m_Text = value;
                         m_Position = 0;
                     }
                 }
            
                 public Action onTextTypedCorrectly { get; set; }
                 public Action onTextTypedIncorrectly { get; set; }
            
                 private int m_Position;
                 private string m_Text;
            
                 protected void OnEnable()
                 {
                     Keyboard.current.onTextInput += OnTextInput;
                 }
            
                 protected void OnDisable()
                 {
                     Keyboard.current.onTextInput -= OnTextInput;
                 }
            
                 private void OnTextInput(char ch)
                 {
                     if (m_Text == null || m_Position >= m_Text.Length)
                         return;
            
                     if (m_Text[m_Position] == ch)
                     {
                         ++m_Position;
                         if (m_Position == m_Text.Length)
                             onTextTypeCorrectly?.Invoke();
                     }
                     else
                     {
                         m_Text = null;
                         m_Position = 0;
            
                         onTextTypedIncorrectly?.Invoke();
                     }
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="E:UnityEngine.InputSystem.Keyboard.onIMECompositionChange">
             <summary>
             An event that is fired to get IME composition strings.  Fired once for every change,
             sends the entire string to date, and sends a blank string whenever a composition is submitted or reset.
             </summary>
             <remarks>
             Some languages use complex input methods which involve opening windows to insert characters.
             Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text.
            
             See <see cref="M:UnityEngine.InputSystem.Keyboard.SetIMEEnabled(System.Boolean)"/> for turning IME on/off
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.SetIMEEnabled(System.Boolean)">
             <summary>
             Activates/deactivates IME composition while typing.  This decides whether or not to use the OS supplied IME system.
             </summary>
             <remarks>
            
             Some languages use complex input methods which involve opening windows to insert characters.
             Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text.
             Setting this to On, will enable the OS-level IME system when the user presses keystrokes.
            
             See <see cref="M:UnityEngine.InputSystem.Keyboard.SetIMECursorPosition(UnityEngine.Vector2)"/>, <see cref="E:UnityEngine.InputSystem.Keyboard.onIMECompositionChange"/>,
             <see cref="P:UnityEngine.InputSystem.Keyboard.imeSelected"/> for more IME settings and data.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.SetIMECursorPosition(UnityEngine.Vector2)">
             <summary>
             Sets the cursor position for IME composition dialogs.  Units are from the upper left, in pixels, moving down and to the right.
             </summary>
             <remarks>
             Some languages use complex input methods which involve opening windows to insert characters.
             Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text.
            
             See <see cref="M:UnityEngine.InputSystem.Keyboard.SetIMEEnabled(System.Boolean)"/> for turning IME on/off
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.keyboardLayout">
             <summary>
             The name of the layout currently used by the keyboard.
             </summary>
             <remarks>
             Note that keyboard layout names are platform-specific.
            
             The value of this property reflects the currently used layout and thus changes
             whenever the layout of the system or the one for the application is changed.
            
             To determine what a key represents in the current layout, use <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.anyKey">
            <summary>
            A synthetic button control that is considered pressed if any key on the keyboard is pressed.
            </summary>
            <value>Control representing the synthetic "anyKey".</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.spaceKey">
            <summary>
            The space bar key.
            </summary>
            <value>Control representing the space bar key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.enterKey">
            <summary>
            The enter/return key in the main key block.
            </summary>
            <value>Control representing the enter key.</value>
            <remarks>
            This key is distinct from the enter key on the numpad which is <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.tabKey">
            <summary>
            The tab key.
            </summary>
            <value>Control representing the tab key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.backquoteKey">
            <summary>
            The ` key. The leftmost key in the row of digits. Directly above <see cref="P:UnityEngine.InputSystem.Keyboard.tabKey"/>.
            </summary>
            <value>Control representing the backtick/quote key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.quoteKey">
            <summary>
            The ' key. The key immediately to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.enterKey"/>.
            </summary>
            <value>Control representing the quote key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.semicolonKey">
            <summary>
            The ';' key. The key immediately to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.quoteKey"/>.
            </summary>
            <value>Control representing the semicolon key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.commaKey">
            <summary>
            The ',' key. Third key to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.rightShiftKey"/>.
            </summary>
            <value>Control representing the comma key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.periodKey">
            <summary>
            The '.' key. Second key to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.rightShiftKey"/>.
            </summary>
            <value>Control representing the period key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.slashKey">
            <summary>
            The '/' key. The key immediately to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.rightShiftKey"/>.
            </summary>
            <value>Control representing the forward slash key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.backslashKey">
            <summary>
            The '\' key. The key immediately to the right of <see cref="P:UnityEngine.InputSystem.Keyboard.rightBracketKey"/> and
            next to or above <see cref="P:UnityEngine.InputSystem.Keyboard.enterKey"/>.
            </summary>
            <value>Control representing the backslash key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftBracketKey">
            <summary>
            The '[' key. The key immediately to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.rightBracketKey"/>.
            </summary>
            <value>Control representing the left bracket key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightBracketKey">
            <summary>
            The ']' key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftBracketKey"/> to the left and
            <see cref="P:UnityEngine.InputSystem.Keyboard.backslashKey"/> to the right.
            </summary>
            <value>Control representing the right bracket key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.minusKey">
            <summary>
            The '-' key. The second key to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.backspaceKey"/>.
            </summary>
            <value>Control representing the minus key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.equalsKey">
            <summary>
            The '=' key in the main key block. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.minusKey"/> to the left
            and <see cref="P:UnityEngine.InputSystem.Keyboard.backspaceKey"/> to the right.
            </summary>
            <value>Control representing the equals key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.aKey">
            <summary>
            The 'a' key. The key immediately to the right of <see cref="P:UnityEngine.InputSystem.Keyboard.capsLockKey"/>.
            </summary>
            <value>Control representing the a key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.bKey">
            <summary>
            The 'b' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.vKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.nKey"/>
            to the right in the bottom-most row of alphabetic characters.
            </summary>
            <value>Control representing the b key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.cKey">
            <summary>
            The 'c' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.xKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.vKey"/>
            to the right in the bottom-most row of alphabetic characters.
            </summary>
            <value>Control representing the c key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.dKey">
            <summary>
            The 'd' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.sKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.fKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the d key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.eKey">
            <summary>
            The 'e' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.wKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.rKey"/>
            to the right in the topmost row of alphabetic characters.
            </summary>
            <value>Control representing the e key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.fKey">
            <summary>
            The 'f' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.dKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.gKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the f key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.gKey">
            <summary>
            The 'g' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.fKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.hKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the g key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.hKey">
            <summary>
            The 'h' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.gKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.jKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the h key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.iKey">
            <summary>
            The 'i' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.uKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.oKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.jKey">
            <summary>
            The 'j' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.hKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.kKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the j key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.kKey">
            <summary>
            The 'k' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.jKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.lKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the k key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.lKey">
            <summary>
            The 'l' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.kKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.semicolonKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the l key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.mKey">
            <summary>
            The 'm' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.nKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.commaKey"/>
            to the right in the bottom row of alphabetic characters.
            </summary>
            <value>Control representing the m key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.nKey">
            <summary>
            The 'n' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.bKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.mKey"/> to
            the right in the bottom row of alphabetic characters.
            </summary>
            <value>Control representing the n key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oKey">
            <summary>
            The 'o' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.iKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.pKey"/> to
            the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the o key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.pKey">
            <summary>
            The 'p' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.oKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.leftBracketKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the p key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.qKey">
            <summary>
            The 'q' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.tabKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.wKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the q key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rKey">
            <summary>
            The 'r' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.eKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.tKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the r key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.sKey">
            <summary>
            The 's' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.aKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.dKey"/>
            to the right in the middle row of alphabetic characters.
            </summary>
            <value>Control representing the s key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.tKey">
            <summary>
            The 't' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.rKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.yKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the t key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.uKey">
            <summary>
            The 'u' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.yKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.iKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the u key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.vKey">
            <summary>
            The 'v' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.cKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.bKey"/>
            to the right in the bottom row of alphabetic characters.
            </summary>
            <value>Control representing the v key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.wKey">
            <summary>
            The 'w' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.qKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.eKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the w key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.xKey">
            <summary>
            The 'x' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.cKey"/>
            to the right in the bottom row of alphabetic characters.
            </summary>
            <value>Control representing the x key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.yKey">
            <summary>
            The 'y' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.tKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.uKey"/>
            to the right in the top row of alphabetic characters.
            </summary>
            <value>Control representing the y key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.zKey">
            <summary>
            The 'z' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.xKey"/>
            to the right in the bottom row of alphabetic characters.
            </summary>
            <value>Control representing the z key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit1Key">
            <summary>
            The '1' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.backquoteKey"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit2Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 1 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit2Key">
            <summary>
            The '2' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit1Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit3Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 2 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit3Key">
            <summary>
            The '3' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit2Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit4Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 3 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit4Key">
            <summary>
            The '4' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit3Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit5Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 4 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit5Key">
            <summary>
            The '5' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit4Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit6Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 5 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit6Key">
            <summary>
            The '6' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit5Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit7Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 6 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit7Key">
            <summary>
            The '7' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit6Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit8Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 7 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit8Key">
            <summary>
            The '8' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit7Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit9Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 8 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit9Key">
            <summary>
            The '9' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit8Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.digit0Key"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 9 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.digit0Key">
            <summary>
            The '0' key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.digit9Key"/> to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.minusKey"/>
            to the right in the row of digit characters.
            </summary>
            <value>Control representing the 0 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftShiftKey">
            <summary>
            The shift key on the left side of the keyboard.
            </summary>
            <value>Control representing the left shift key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightShiftKey">
            <summary>
            The shift key on the right side of the keyboard.
            </summary>
            <value>Control representing the right shift key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftAltKey">
            <summary>
            The alt/option key on the left side of the keyboard.
            </summary>
            <value>Control representing the left alt/option key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightAltKey">
            <summary>
            The alt/option key on the right side of the keyboard.
            </summary>
            <value>Control representing the right alt/option key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftCtrlKey">
            <summary>
            The control/ctrl key on the left side of the keyboard.
            </summary>
            <value>Control representing the left control key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightCtrlKey">
            <summary>
            The control/ctrl key on the right side of the keyboard.
            </summary>
            <remarks>This key is usually not present on Mac laptops.</remarks>
            <value>Control representing the right control key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftMetaKey">
            <summary>
            The system "meta" key (Windows key on PC, Apple/command key on Mac) on the left
            side of the keyboard.
            </summary>
            <value>Control representing the left system meta key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightMetaKey">
            <summary>
            The system "meta" key (Windows key on PC, Apple/command key on Mac) on the right
            side of the keyboard.
            </summary>
            <value>Control representing the right system meta key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftWindowsKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.leftMetaKey"/>. Windows system key on left side of keyboard.
            </summary>
            <value>Control representing the left Windows system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightWindowsKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.rightMetaKey"/>. Windows system key on right side of keyboard.
            </summary>
            <value>Control representing the right Windows system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftAppleKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.leftMetaKey"/>. Apple/command system key on left side of keyboard.
            </summary>
            <value>Control representing the left Apple/command system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightAppleKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.rightMetaKey"/>. Apple/command system key on right side of keyboard.
            </summary>
            <value>Control representing the right Apple/command system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftCommandKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.leftMetaKey"/>. Apple/command system key on left side of keyboard.
            </summary>
            <value>Control representing the left Apple/command system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightCommandKey">
            <summary>
            Same as <see cref="P:UnityEngine.InputSystem.Keyboard.rightMetaKey"/>. Apple/command system key on right side of keyboard.
            </summary>
            <value>Control representing the right Apple/command system key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.contextMenuKey">
            <summary>
            The context menu key. This key is generally only found on PC keyboards. If present,
            the key is found in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.rightWindowsKey"/> to the left and the
            <see cref="P:UnityEngine.InputSystem.Keyboard.rightCtrlKey"/> to the right. It's intention is to bring up the context
            menu according to the current selection.
            </summary>
            <value>Control representing the context menu key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.escapeKey">
            <summary>
            The escape key, i.e. the key generally in the top left corner of the keyboard.
            Usually to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.f1Key"/>.
            </summary>
            <value>Control representing the escape key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.leftArrowKey">
            <summary>
            The left arrow key. Usually in a block by itself and generally to the left
            of <see cref="P:UnityEngine.InputSystem.Keyboard.downArrowKey"/>.
            </summary>
            <value>Control representing the left arrow key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.rightArrowKey">
            <summary>
            The right arrow key. Usually in a block by itself and generally to the right
            of <see cref="P:UnityEngine.InputSystem.Keyboard.downArrowKey"/>
            </summary>
            <value>Control representing the right arrow key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.upArrowKey">
            <summary>
            The up arrow key. Usually in a block by itself and generally on top of the
            <see cref="P:UnityEngine.InputSystem.Keyboard.downArrowKey"/>.
            </summary>
            <value>Control representing the up arrow key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.downArrowKey">
            <summary>
            The down arrow key. Usually in a block by itself and generally below the
            <see cref="P:UnityEngine.InputSystem.Keyboard.upArrowKey"/> and in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftArrowKey"/> to the
            left and <see cref="P:UnityEngine.InputSystem.Keyboard.rightArrowKey"/> to the right.
            </summary>
            <value>Control representing the down arrow key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.backspaceKey">
            <summary>
            The backspace key (usually labeled "delete" on Mac). The rightmost key
            in the top digit row with <see cref="P:UnityEngine.InputSystem.Keyboard.equalsKey"/> to the left.
            </summary>
            <value>Control representing the backspace key.</value>
            <remarks>
            On the Mac, this key may be labeled "delete" which however is a
            key different from <see cref="P:UnityEngine.InputSystem.Keyboard.deleteKey"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.pageDownKey">
            <summary>
            The page down key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.endKey"/>
            to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.pageUpKey"/> above it.
            </summary>
            <value>Control representing the page down key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.pageUpKey">
            <summary>
            The page up key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.homeKey"/>
            to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.pageDownKey"/> below it.
            </summary>
            <value>Control representing the page up key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.homeKey">
            <summary>
            The 'home' key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.pageUpKey"/>
            to the right and <see cref="P:UnityEngine.InputSystem.Keyboard.insertKey"/> to the left.
            </summary>
            <value>Control representing the insert key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.endKey">
            <summary>
            The 'end' key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.deleteKey"/>
            to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.pageDownKey"/> to the right.
            </summary>
            <value>Control representing the end key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.insertKey">
            <summary>
            The 'insert' key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.homeKey"/>
            to its right and <see cref="P:UnityEngine.InputSystem.Keyboard.deleteKey"/> sitting below it.
            </summary>
            <value>Control representing the insert key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.deleteKey">
            <summary>
            The 'delete' key. Usually in a separate block with <see cref="P:UnityEngine.InputSystem.Keyboard.endKey"/>
            to its right and <see cref="P:UnityEngine.InputSystem.Keyboard.insertKey"/> sitting above it.
            </summary>
            <value>Control representing the delete key.</value>
            <remarks>
            On the Mac, the <see cref="P:UnityEngine.InputSystem.Keyboard.backspaceKey"/> is also labeled "delete".
            However, this is not this key.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.capsLockKey">
            <summary>
            The Caps Lock key. The key below <see cref="P:UnityEngine.InputSystem.Keyboard.tabKey"/> and above
            <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/>.
            </summary>
            <value>Control representing the caps lock key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.scrollLockKey">
            <summary>
            The Scroll Lock key. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.printScreenKey"/>
            to the left and the <see cref="P:UnityEngine.InputSystem.Keyboard.pauseKey"/> to the right. May also
            be labeled "F14".
            </summary>
            <value>Control representing the scroll lock key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numLockKey">
            <summary>
            The Num Lock key. The key sitting in the top left corner of the
            numpad and which usually toggles the numpad between generating
            digits and triggering functions like "insert" etc. instead.
            </summary>
            <value>Control representing the num lock key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.printScreenKey">
            <summary>
            The Print Screen key. The key sitting in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f12Key"/>
            to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.scrollLockKey"/> to the right. May also
            be labeled "F13".
            </summary>
            <value>Control representing the print screen key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.pauseKey">
            <summary>
            The pause/break key. The key sitting to the left of <see cref="P:UnityEngine.InputSystem.Keyboard.scrollLockKey"/>.
            May also be labeled "F15".
            </summary>
            <value>Control representing the pause/break key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey">
            <summary>
            The enter key on the numpad. The key sitting in the bottom right corner
            of the numpad.
            </summary>
            <value>Control representing the numpad enter key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadDivideKey">
            <summary>
            The divide ('/') key on the numpad. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEqualsKey"/>
            to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMultiplyKey"/> to the right.
            </summary>
            <value>Control representing the numpad divide key.</value>
            <remarks>
            PC keyboards usually have a 17-key numpad layout that differs from the 18-key layout
            we use for reference. The 18-key layout is usually found on Mac keyboards. The numpad
            divide key usually is the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEqualsKey"/> on PC keyboards.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadMultiplyKey">
            <summary>
            The multiply ('*') key on the numpad. The key in the upper right corner of the numpad
            with <see cref="P:UnityEngine.InputSystem.Keyboard.numpadDivideKey"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMultiplyKey"/>
            below it.
            </summary>
            <value>Control representing the numpad multiply key.</value>
            <remarks>
            PC keyboards usually have a 17-key numpad layout that differs from the 18-key layout
            we use for reference. The 18-key layout is usually found on Mac keyboards. The numpad
            multiply key usually is the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMinusKey"/> on PC keyboards.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadMinusKey">
            <summary>
            The minus ('-') key on the numpad. The key on the right side of the numpad with
            <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMultiplyKey"/> above it and <see cref="P:UnityEngine.InputSystem.Keyboard.numpadPlusKey"/> below it.
            </summary>
            <value>Control representing the numpad minus key.</value>
            <remarks>
            PC keyboards usually have a 17-key numpad layout that differs from the 18-key layout
            we use for reference. The 18-key layout is usually found on Mac keyboards. The numpad
            minus key is usually <em>not</em> present on PC keyboards. Instead, the 17-key layout
            has an elongated <see cref="P:UnityEngine.InputSystem.Keyboard.numpadPlusKey"/> that covers the space of two keys.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadPlusKey">
             <summary>
             The plus ('+') key on the numpad. The key on the right side of the numpad with
             <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMinusKey"/> above it and <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey"/> below it.
             </summary>
             <value>Control representing the numpad plus key.</value>
             <remarks>
             PC keyboards usually have a 17-key numpad layout that differs from the 18-key layout
             we use for reference. The 18-key layout is usually found on Mac keyboards.
            
             In particular, the plus key on the numpad is usually an elongated key that covers
             the space of two keys. These 17-key numpads do not usually have a <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEqualsKey"/>
             and the key above the plus key will usually be the numpad minus key.
            
             However, both on a 17-key and 18-key numpad, the plus key references the same physical key.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadPeriodKey">
            <summary>
            The period ('.') key on the numpad. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey"/>
            to the right and the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad0Key"/> to the left.
            </summary>
            <value>Control representing the numpad period key.</value>
            <remarks>
            This key is the same in 17-key and 18-key numpad layouts.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpadEqualsKey">
             <summary>
             The equals ('=') key on the numpad. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.numLockKey"/> to the left
             and <see cref="P:UnityEngine.InputSystem.Keyboard.numpadDivideKey"/> to the right in the top row of the numpad.
             </summary>
             <value>Control representing the numpad equals key.</value>
             <remarks>
             PC keyboards usually have a 17-key numpad layout that differs from the 18-key layout
             we use for reference. The 18-key layout is usually found on Mac keyboards.
            
             17-key numpad layouts do not usually have an equals key. On these PC keyboards, the
             equals key is usually the divide key.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad0Key">
            <summary>
            The 0 key on the numpad. The key in the bottom left corner of the numpad. Usually
            and elongated key.
            </summary>
            <value>Control representing the numpad 0 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad1Key">
            <summary>
            The 1 key on the numpad. The key on the left side of the numpad with <see cref="P:UnityEngine.InputSystem.Keyboard.numpad0Key"/>
            below it and <see cref="P:UnityEngine.InputSystem.Keyboard.numpad4Key"/> above it.
            </summary>
            <value>Control representing the numpad 1 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad2Key">
            <summary>
            The 2 key on the numpad. The key with the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad1Key"/> to its left and
            the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad3Key"/> to its right.
            </summary>
            <value>Control representing the numpad 2 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad3Key">
            <summary>
            The 3 key on the numpad. The key with the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad2Key"/> to its left and
            the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadEnterKey"/> to its right.
            </summary>
            <value>Control representing the numpad 3 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad4Key">
            <summary>
            The 4 key on the numpad. The key on the left side of the numpad with the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad1Key"/>
            below it and the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad7Key"/> above it.
            </summary>
            <value>Control representing the numpad 4 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad5Key">
            <summary>
            The 5 key on the numpad. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad4Key"/> to the left and the
            <see cref="P:UnityEngine.InputSystem.Keyboard.numpad6Key"/> to the right.
            </summary>
            <value>Control representing the numpad 5 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad6Key">
            <summary>
            The 6 key on the numpad. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad5Key"/> to the let and
            the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadPlusKey"/> to the right.
            </summary>
            <value>Control representing the numpad 6 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad7Key">
            <summary>
            The 7 key on the numpad. The key on the left side of the numpad with <see cref="P:UnityEngine.InputSystem.Keyboard.numpad4Key"/>
            below it and <see cref="P:UnityEngine.InputSystem.Keyboard.numLockKey"/> above it.
            </summary>
            <value>Control representing the numpad 7 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad8Key">
            <summary>
            The 8 key on the numpad. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad7Key"/> to the left and the
            <see cref="P:UnityEngine.InputSystem.Keyboard.numpad9Key"/> to the right.
            </summary>
            <value>Control representing the numpad 8 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.numpad9Key">
            <summary>
            The 9 key on the numpad. The key in-between the <see cref="P:UnityEngine.InputSystem.Keyboard.numpad8Key"/> to the left and
            the <see cref="P:UnityEngine.InputSystem.Keyboard.numpadMinusKey"/> to the right (or, on 17-key PC keyboard numpads, the elongated
            plus key).
            </summary>
            <value>Control representing the numpad 9 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f1Key">
            <summary>
            The F1 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.escapeKey"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f1Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F1 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f2Key">
            <summary>
            The F2 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f1Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f3Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F2 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f3Key">
            <summary>
            The F3 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f2Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f4Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F3 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f4Key">
            <summary>
            The F4 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f3Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f5Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F4 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f5Key">
            <summary>
            The F5 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f4Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f6Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F5 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f6Key">
            <summary>
            The F6 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f5Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f7Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F6 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f7Key">
            <summary>
            The F7 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f6Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f8Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F7 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f8Key">
            <summary>
            The F8 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f7Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f9Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F8 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f9Key">
            <summary>
            The F9 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f8Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f10Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F9 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f10Key">
            <summary>
            The F10 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f9Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f11Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F10 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f11Key">
            <summary>
            The F11 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f10Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.f12Key"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F11 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.f12Key">
            <summary>
            The F12 key. The key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.f11Key"/> to the left and <see cref="P:UnityEngine.InputSystem.Keyboard.printScreenKey"/>
            to the right in the topmost row of keys.
            </summary>
            <value>Control representing the F12 key.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oem1Key">
             <summary>
             First additional key on the keyboard.
             </summary>
             <value>Control representing <see cref="F:UnityEngine.InputSystem.Key.OEM1"/>.</value>
             <remarks>
             Keyboards may have additional keys that are not part of the standardized 104-key keyboard layout
             (105 in the case of an 18-key numpad). For example, many non-English keyboard layouts have an additional
             key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            
             Additional keys may be surfaced by the platform as "OEM" keys. There is no guarantee about where the
             keys are located and what symbols they produce. The OEM key controls are mainly there to surface the
             inputs but not with the intention of being used in standard bindings.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oem2Key">
             <summary>
             Second additional key on the keyboard.
             </summary>
             <value>Control representing <see cref="F:UnityEngine.InputSystem.Key.OEM2"/>.</value>
             <remarks>
             Keyboards may have additional keys that are not part of the standardized 104-key keyboard layout
             (105 in the case of an 18-key numpad). For example, many non-English keyboard layouts have an additional
             key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            
             Additional keys may be surfaced by the platform as "OEM" keys. There is no guarantee about where the
             keys are located and what symbols they produce. The OEM key controls are mainly there to surface the
             inputs but not with the intention of being used in standard bindings.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oem3Key">
             <summary>
             Third additional key on the keyboard.
             </summary>
             <value>Control representing <see cref="F:UnityEngine.InputSystem.Key.OEM3"/>.</value>
             <remarks>
             Keyboards may have additional keys that are not part of the standardized 104-key keyboard layout
             (105 in the case of an 18-key numpad). For example, many non-English keyboard layouts have an additional
             key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            
             Additional keys may be surfaced by the platform as "OEM" keys. There is no guarantee about where the
             keys are located and what symbols they produce. The OEM key controls are mainly there to surface the
             inputs but not with the intention of being used in standard bindings.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oem4Key">
             <summary>
             Fourth additional key on the keyboard.
             </summary>
             <value>Control representing <see cref="F:UnityEngine.InputSystem.Key.OEM4"/>.</value>
             <remarks>
             Keyboards may have additional keys that are not part of the standardized 104-key keyboard layout
             (105 in the case of an 18-key numpad). For example, many non-English keyboard layouts have an additional
             key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            
             Additional keys may be surfaced by the platform as "OEM" keys. There is no guarantee about where the
             keys are located and what symbols they produce. The OEM key controls are mainly there to surface the
             inputs but not with the intention of being used in standard bindings.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.oem5Key">
             <summary>
             Fifth additional key on the keyboard.
             </summary>
             <value>Control representing <see cref="F:UnityEngine.InputSystem.Key.OEM5"/>.</value>
             <remarks>
             Keyboards may have additional keys that are not part of the standardized 104-key keyboard layout
             (105 in the case of an 18-key numpad). For example, many non-English keyboard layouts have an additional
             key in-between <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.zKey"/>.
            
             Additional keys may be surfaced by the platform as "OEM" keys. There is no guarantee about where the
             keys are located and what symbols they produce. The OEM key controls are mainly there to surface the
             inputs but not with the intention of being used in standard bindings.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.shiftKey">
            <summary>
            An artificial combination of <see cref="P:UnityEngine.InputSystem.Keyboard.leftShiftKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.rightShiftKey"/> into one control.
            </summary>
            <value>Control representing a combined left and right shift key.</value>
            <remarks>
            This is a <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/> button which is considered pressed whenever the left and/or
            right shift key is pressed.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.ctrlKey">
            <summary>
            An artificial combination of <see cref="P:UnityEngine.InputSystem.Keyboard.leftCtrlKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.rightCtrlKey"/> into one control.
            </summary>
            <value>Control representing a combined left and right ctrl key.</value>
            <remarks>
            This is a <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/> button which is considered pressed whenever the left and/or
            right ctrl key is pressed.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.altKey">
            <summary>
            An artificial combination of <see cref="P:UnityEngine.InputSystem.Keyboard.leftAltKey"/> and <see cref="P:UnityEngine.InputSystem.Keyboard.rightAltKey"/> into one control.
            </summary>
            <value>Control representing a combined left and right alt key.</value>
            <remarks>
            This is a <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/> button which is considered pressed whenever the left and/or
            right alt key is pressed.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.imeSelected">
             <summary>
             True when IME composition is enabled.  Requires <see cref="M:UnityEngine.InputSystem.Keyboard.SetIMEEnabled(System.Boolean)"/> to be called to enable IME, and the user to enable it at the OS level.
             </summary>
             <remarks>
            
             Some languages use complex input methods which involve opening windows to insert characters.
             Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text.
            
             See <see cref="M:UnityEngine.InputSystem.Keyboard.SetIMEEnabled(System.Boolean)"/> for turning IME on/off
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.Item(UnityEngine.InputSystem.Key)">
            <summary>
            Look up a key control by its key code.
            </summary>
            <param name="key">Key code of key control to return.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given <paramref cref="!:key"/> is not valid.</exception>
            <remarks>
            This is equivalent to <c>allKeys[(int)key - 1]</c>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.allKeys">
            <summary>
            List of all key controls on the keyboard.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.current">
            <summary>
            The keyboard that was last used or added. Null if there is no keyboard.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.MakeCurrent">
            <summary>
            Make the keyboard the current keyboard (i.e. <see cref="P:UnityEngine.InputSystem.Keyboard.current"/>).
            </summary>
            <remarks>
            A keyboard will automatically be made current when receiving input or when
            added to the input system.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.OnRemoved">
            <summary>
            Called when the keyboard is removed from the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.FinishSetup">
            <summary>
            Called after the keyboard has been constructed but before it is added to
            the system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.RefreshConfiguration">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.OnTextInput(System.Char)">
            <summary>
            Called when text input on the keyboard is received.
            </summary>
            <param name="character">Character that has been entered.</param>
            <remarks>
            The system will call this automatically whenever a <see cref="T:UnityEngine.InputSystem.LowLevel.TextEvent"/> is
            received that targets the keyboard device.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Keyboard.FindKeyOnCurrentKeyboardLayout(System.String)">
             <summary>
             Return the key control that, according to the currently active keyboard layout (see <see cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>),
             is associated with the given text.
             </summary>
             <param name="displayName">Display name reported for the key according to the currently active keyboard layout.</param>
             <returns>The key control corresponding to the given text or <c>null</c> if no such key was found on the current
             keyboard layout.</returns>
             <remarks>
             In most cases, this means that the key inputs the given text when pressed. However, this does not have to be the
             case. Keys do not necessarily lead to character input.
            
             <example>
             // Find key that prints 'q' character (if any).
             Keyboard.current.FindKeyOnCurrentKeyboardLayout("q");
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Keyboard.keyboardLayout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.Keyboard.keys">
            <summary>
            Raw array of key controls on the keyboard.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.OSX.LowLevel.NimbusPlusHIDInputReport">
            <summary>
            Structure of HID input reports for SteelSeries Nimbus+ controllers supported
            via HID on OSX.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.OSX.LowLevel.NimbusPlusHIDInputReport.OSXVendorId">
            <summary>
            A dummy vendor ID made available by OSX when supporting Nimbus+ via HID.
            This is exposed by OSX instead of the true SteelSeries vendor ID 0x1038.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.OSX.LowLevel.NimbusPlusHIDInputReport.OSXProductId">
            <summary>
            A dummy product ID made available by OSX when supporting Nimbus+ via HID.
            This is exposed by OSX instead of the true Nimbus+ product ID 0x1422.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.OSX.NimbusGamepadHid">
            <summary>
            Steel Series Nimbus+ uses iOSGameController MFI when on iOS but
            is just a standard HID on OSX. Note that the gamepad is made available
            with incorrect VID/PID by OSX instead of the true VID/PID registred with
            USB.org for this device.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.OSX.NimbusGamepadHid.homeButton">
            <summary>
            The center button in the middle section of the controller.
            </summary>
            <remarks>
            Note that this button is also picked up by OS.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.OSX.NimbusGamepadHid.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.OSX.OSXSupport">
            <summary>
            A small helper class to aid in initializing and registering HID device layout builders.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.OSX.OSXSupport.Initialize">
            <summary>
            Registers HID device layouts for OSX.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlList`1">
             <summary>
             Keep a list of <see cref="T:UnityEngine.InputSystem.InputControl"/>s without allocating managed memory.
             </summary>
             <remarks>
             This struct is mainly used by methods such as <see cref="M:UnityEngine.InputSystem.InputSystem.FindControls(System.String)"/>
             or <see cref="M:UnityEngine.InputSystem.InputControlPath.TryFindControls``1(UnityEngine.InputSystem.InputControl,System.String,System.Int32,UnityEngine.InputSystem.InputControlList{``0}@)"/> to store an arbitrary length
             list of resulting matches without having to allocate GC heap memory.
            
             Requires the control setup in the system to not change while the list is being used. If devices are
             removed from the system, the list will no longer be valid. Also, only works with controls of devices that
             have been added to the system (<see cref="P:UnityEngine.InputSystem.InputDevice.added"/>). The reason for these constraints is
             that internally, the list only stores integer indices that are translates to <see cref="T:UnityEngine.InputSystem.InputControl"/>
             references on the fly. If the device setup in the system changes, the indices may become invalid.
            
             This struct allocates unmanaged memory and thus must be disposed or it will leak memory. By default
             allocates <c>Allocator.Persistent</c> memory. You can direct it to use another allocator by
             passing an <see cref="T:Unity.Collections.Allocator"/> value to one of the constructors.
            
             <example>
             <code>
             // Find all controls with the "Submit" usage in the system.
             // By wrapping it in a `using` block, the list of controls will automatically be disposed at the end.
             using (var controls = InputSystem.FindControls("*/{Submit}"))
                 /* ... */;
             </code>
             </example>
             </remarks>
             <typeparam name="TControl">Type of <see cref="T:UnityEngine.InputSystem.InputControl"/> to store in the list.</typeparam>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlList`1.Count">
            <summary>
            Current number of controls in the list.
            </summary>
            <value>Number of controls currently in the list.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlList`1.Capacity">
             <summary>
             Total number of controls that can currently be stored in the list.
             </summary>
             <value>Total size of array as currently allocated.</value>
             <remarks>
             This can be set ahead of time to avoid repeated allocations.
            
             <example>
             <code>
             // Add all keys from the keyboard to a list.
             var keys = Keyboard.current.allKeys;
             var list = new InputControlList&lt;KeyControl&gt;(keys.Count);
             list.AddRange(keys);
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlList`1.IsReadOnly">
            <summary>
            This is always false.
            </summary>
            <value>Always false.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlList`1.Item(System.Int32)">
            <summary>
            Return the control at the given index.
            </summary>
            <param name="index">Index of control.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0 or greater than or equal to <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/>
            </exception>
            <remarks>
            Internally, the list only stores indices. Resolution to <see cref="T:UnityEngine.InputSystem.InputControl">controls</see> happens
            dynamically by looking them up globally.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.#ctor(Unity.Collections.Allocator,System.Int32)">
            <summary>
            Construct a list that allocates unmanaged memory from the given allocator.
            </summary>
            <param name="allocator">Allocator to use for requesting unmanaged memory.</param>
            <param name="initialCapacity">If greater than zero, will immediately allocate
            memory and set <see cref="P:UnityEngine.InputSystem.InputControlList`1.Capacity"/> accordingly.</param>
            <example>
            <code>
            // Create a control list that allocates from the temporary memory allocator.
            using (var list = new InputControlList(Allocator.Temp))
            {
                // Add all gamepads to the list.
                InputSystem.FindControls("&lt;Gamepad&gt;", ref list);
            }
            </code>
            </example>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.#ctor(System.Collections.Generic.IEnumerable{`0},Unity.Collections.Allocator)">
            <summary>
            Construct a list and populate it with the given values.
            </summary>
            <param name="values">Sequence of values to populate the list with.</param>
            <param name="allocator">Allocator to use for requesting unmanaged memory.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.#ctor(`0[])">
            <summary>
            Construct a list and add the given values to it.
            </summary>
            <param name="values">Sequence of controls to add to the list.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.Resize(System.Int32)">
            <summary>
            Resizes the list to be exactly <paramref name="size"/> entries. If this is less than the
            current <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/>, additional entries are dropped. If it is more than the
            current <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/>, additional <c>null</c> entries are appended to the list.
            </summary>
            <param name="size">The new value for <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is negative.</exception>
            <remarks>
            <see cref="P:UnityEngine.InputSystem.InputControlList`1.Capacity"/> is increased if necessary. It will, however, not be decreased if it
            is larger than <paramref name="size"/> entries.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.Add(`0)">
             <summary>
             Add a control to the list.
             </summary>
             <param name="item">Control to add. Allowed to be <c>null</c>.</param>
             <remarks>
             If necessary, <see cref="P:UnityEngine.InputSystem.InputControlList`1.Capacity"/> will be increased.
            
             It is allowed to add nulls to the list. This can be useful, for example, when
             specific indices in the list correlate with specific matches and a given match
             needs to be marked as "matches nothing".
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlList`1.Remove(`0)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.AddSlice``1(``0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a slice of elements taken from the given list.
            </summary>
            <param name="list">List to take the slice of values from.</param>
            <param name="count">Number of elements to copy from <paramref name="list"/>.</param>
            <param name="destinationIndex">Starting index in the current control list to copy to.
            This can be beyond <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/> or even <see cref="P:UnityEngine.InputSystem.InputControlList`1.Capacity"/>. Memory is allocated
            as needed.</param>
            <param name="sourceIndex">Source index in <paramref name="list"/> to start copying from.
            <paramref name="count"/> elements are copied starting at <paramref name="sourceIndex"/>.</param>
            <typeparam name="TList">Type of list. This is a type parameter to avoid boxing in case the
            given list is a struct (such as InputControlList itself).</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">The range of <paramref name="count"/>
            and <paramref name="sourceIndex"/> is at least partially outside the range of values
            available in <paramref name="list"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.AddRange(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Add a sequence of controls to the list.
            </summary>
            <param name="list">Sequence of controls to add.</param>
            <param name="count">Number of controls from <paramref name="list"/> to add. If negative
            (default), all controls from <paramref name="list"/> will be added.</param>
            <param name="destinationIndex">Index in the control list to start inserting controls
            at. If negative (default), controls will be appended to the end of the control list.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <c>null</c>.</exception>
            <remarks>
            If <paramref name="count"/> is not supplied, <paramref name="list"/> will be iterated
            over twice.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.Remove(`0)">
            <summary>
            Remove a control from the list.
            </summary>
            <param name="item">Control to remove. Can be null.</param>
            <returns>True if the control was found in the list and removed, false otherwise.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputControlList`1.Add(`0)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the control at the given index.
            </summary>
            <param name="index">Index of control to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is negative or equal
            or greater than <see cref="P:UnityEngine.InputSystem.InputControlList`1.Count"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlList`1.ToArray(System.Boolean)">
            <summary>
            Convert the contents of the list to an array.
            </summary>
            <param name="dispose">If true, the control list will be disposed of as part of the operation, i.e.
            <see cref="M:UnityEngine.InputSystem.InputControlList`1.Dispose"/> will be called as a side-effect.</param>
            <returns>An array mirroring the contents of the list. Not null.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputInteractionContext">
            <summary>
            Information passed to <see cref="T:UnityEngine.InputSystem.IInputInteraction">interactions</see>
            when their associated controls trigger.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.IInputInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.action">
            <summary>
            The action associated with the binding.
            </summary>
            <remarks>
            If the binding is not associated with an action, this is <c>null</c>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.action"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.control">
            <summary>
            The bound control that changed its state to trigger the binding associated
            with the interaction.
            </summary>
            <remarks>
            In case the binding associated with the interaction is a composite, this is
            one of the controls that are part of the composite.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.phase">
            <summary>
            The phase the interaction is currently in.
            </summary>
            <remarks>
            Each interaction on a binding has its own phase independent of the action the binding is applied to.
            If an interaction gets to "drive" an action at a particular point in time, its phase will determine
            the phase of the action.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Started"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Waiting"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Performed"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Canceled"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.time">
            <summary>
            Time stamp of the input event that caused <see cref="P:UnityEngine.InputSystem.InputInteractionContext.control"/> to trigger a change in the
            state of <see cref="P:UnityEngine.InputSystem.InputInteractionContext.action"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.startTime">
            <summary>
            Timestamp of the <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> that caused the interaction to transition
            to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.timerHasExpired">
            <summary>
            Whether the interaction's <see cref="M:UnityEngine.InputSystem.IInputInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)"/> method has been called because
            a timer set by <see cref="M:UnityEngine.InputSystem.InputInteractionContext.SetTimeout(System.Single)"/> has expired.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.SetTimeout(System.Single)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.isWaiting">
            <summary>
            True if the interaction is waiting for input
            </summary>
            <remarks>
            By default, an interaction will return this this phase after every time it has been performed
            (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>). This can be changed by using <see cref="M:UnityEngine.InputSystem.InputInteractionContext.PerformedAndStayStarted"/>
            or <see cref="M:UnityEngine.InputSystem.InputInteractionContext.PerformedAndStayPerformed"/>.
            </remarks>
            <seealso cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputInteractionContext.isStarted">
            <summary>
            True if the interaction has been started.
            </summary>
            <seealso cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Started"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.ComputeMagnitude">
            <summary>
            Compute the current level of control actuation.
            </summary>
            <returns>The current level of control actuation (usually [0..1]) or -1 if the control is actuated
            but does not support computing magnitudes.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.ControlIsActuated(System.Single)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.ControlIsActuated(System.Single)">
            <summary>
            Return true if the control that triggered the interaction has been actuated beyond the given threshold.
            </summary>
            <param name="threshold">Threshold that must be reached for the control to be considered actuated. If this is zero,
            the threshold must be exceeded. If it is any positive value, the value must be at least matched.</param>
            <returns>True if the trigger control is actuated.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.IsActuated(UnityEngine.InputSystem.InputControl,System.Single)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.ComputeMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.Started">
             <summary>
             Mark the interaction has having begun.
             </summary>
             <remarks>
             Note that this affects the current interaction only. There may be multiple interactions on a binding
             and arbitrary many interactions may concurrently be in started state. However, only one interaction
             (usually the one that starts first) is allowed to drive the action's state as a whole. If an interaction
             that is currently driving an action is canceled, however, the next interaction in the list that has
             been started will take over and continue driving the action.
            
             <example>
             <code>
             public class MyInteraction : IInputInteraction&lt;float&gt;
             {
                 public void Process(ref IInputInteractionContext context)
                 {
                     if (context.isWaiting &amp;&amp; context.ControlIsActuated())
                     {
                         // We've waited for input and got it. Start the interaction.
                         context.Started();
                     }
                     else if (context.isStarted &amp;&amp; !context.ControlIsActuated())
                     {
                         // Interaction has been completed.
                         context.Performed();
                     }
                 }
            
                 public void Reset()
                 {
                     // No reset code needed. We're not keeping any state locally in the interaction.
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.Waiting">
            <summary>
            Put the interaction back into <see cref="F:UnityEngine.InputSystem.InputActionPhase.Waiting"/> state.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.phase"/>
            <seealso cref="T:UnityEngine.InputSystem.InputActionPhase"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Started"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Performed"/>
            <seealso cref="M:UnityEngine.InputSystem.InputInteractionContext.Canceled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.SetTimeout(System.Single)">
             <summary>
             Start a timeout that triggers within <paramref name="seconds"/>.
             </summary>
             <param name="seconds">Number of seconds before the timeout is triggered.</param>
             <remarks>
             An interaction might wait a set amount of time for something to happen and then
             do something depending on whether it did or did not happen. By calling this method,
             a timeout is installed such that in the input update that the timer expires in, the
             interaction's <see cref="M:UnityEngine.InputSystem.IInputInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)"/> method is called with <see cref="P:UnityEngine.InputSystem.InputInteractionContext.timerHasExpired"/>
             being true.
            
             Changing the phase of the interaction while a timeout is running will implicitly cancel
             the timeout.
            
             <example>
             <code>
             // Let's say we're writing a Process() method for an interaction that,
             // after a control has been actuated, waits for 1 second for it to be
             // released again. If that happens, the interaction performs. If not,
             // it cancels.
             public void Process(ref InputInteractionContext context)
             {
                 // timerHasExpired will be true if we get called when our timeout
                 // has expired.
                 if (context.timerHasExpired)
                 {
                     // The user did not release the control quickly enough.
                     // Our interaction is not successful, so cancel.
                     context.Canceled();
                     return;
                 }
            
                 if (context.ControlIsActuated())
                 {
                     if (!context.isStarted)
                     {
                         // The control has been actuated. We want to give the user a max
                         // of 1 second to release it. So we start the interaction now and then
                         // set the timeout.
                         context.Started();
                         context.SetTimeout(1);
                     }
                 }
                 else
                 {
                     // Control has been released. If we're currently waiting for a release,
                     // it has come in time before out timeout expired. In other words, the
                     // interaction has been successfully performed. We call Performed()
                     // which implicitly removes our ongoing timeout.
                     if (context.isStarted)
                         context.Performed();
                 }
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputInteractionContext.timerHasExpired"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.SetTotalTimeoutCompletionTime(System.Single)">
             <summary>
             Override the default timeout value used by <see cref="M:UnityEngine.InputSystem.InputAction.GetTimeoutCompletionPercentage"/>.
             </summary>
             <param name="seconds">Amount of total successive timeouts TODO</param>
             <exception cref="T:System.ArgumentException"></exception>
             <remarks>
             By default, timeout completion will be entirely determine by the timeout that is currently
             running, if any. However, some interactions (such as <see cref="T:UnityEngine.InputSystem.Interactions.MultiTapInteraction"/>)
             will have to run multiple timeouts in succession. Thus, completion of a single timeout is not
             the same as completion of the interaction.
            
             You can use this method to account for this.
            
             Whenever a timeout completes, the timeout duration will automatically be accumulated towards
             the total timeout completion time.
            
             <example>
             <code>
             // Let's say we're starting our first timeout and we know that we will run three timeouts
             // in succession of 2 seconds each. By calling SetTotalTimeoutCompletionTime(), we can account for this.
             SetTotalTimeoutCompletionTime(3 * 2);
            
             // Start the first timeout. When this timeout expires, it will automatically
             // count one second towards the total timeout completion time.
             SetTimeout(2);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputAction.GetTimeoutCompletionPercentage"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputInteractionContext.ReadValue``1">
            <summary>
            Read the value of the binding that triggered processing of the interaction.
            </summary>
            <typeparam name="TValue">Type of value to read from the binding. Must match the value type of the control
            or composite in effect for the binding.</typeparam>
            <returns>Value read from the binding.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputValue">
            <summary>
            Wraps around values provided by input actions.
            </summary>
            <remarks>
            This is a wrapper around <see cref="T:UnityEngine.InputSystem.InputAction.CallbackContext"/> chiefly for use
            with GameObject messages (i.e. <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)"/>). It exists
            so that action callback data can be represented as an object, can be reused, and shields
            the receiver from having to know about action callback specifics.
            </remarks>
            <seealso cref="T:UnityEngine.InputSystem.InputAction"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputValue.Get">
            <summary>
            Read the value as an object.
            </summary>
            <remarks>
            This method allocates GC memory and will thus created garbage. If used during gameplay,
            it will lead to GC spikes.
            </remarks>
            <returns>The current value in the form of a boxed object.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.Sensor">
             <summary>
             Base class representing any sensor kind of input device.
             </summary>
             <remarks>
             Sensors represent device environmental sensors, such as <see cref="T:UnityEngine.InputSystem.Accelerometer"/>s, <see cref="T:UnityEngine.InputSystem.Gyroscope"/>s,
             <see cref="T:UnityEngine.InputSystem.GravitySensor"/>s and others.
            
             Unlike other devices, sensor devices usually start out in a disabled state in order to reduce energy
             consumption (i.e. preserve battery life) when the sensors are not in fact used. To enable a specific sensor,
             call <see cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/> on the device instance.
            
             <example>
             <code>
             // Enable the gyroscope.
             InputSystem.EnableDevice(Gyroscope.current);
             </code>
             </example>
            
             Sensors are usually sampled automatically by the platform at regular intervals. For example, if a sensor
             is sampled at 50Hz, the platform will queue an event with an update at a rate of roughly 50 events per
             second. The default sampling rate for a sensor is usually platform-specific. A custom sampling frequency
             can be set through <see cref="P:UnityEngine.InputSystem.Sensor.samplingFrequency"/> but be aware that there may be limitations for how fast
             a given sensor can be sampled.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Sensor.samplingFrequency">
             <summary>
             The frequency (in Hertz) at which the underlying sensor will be refreshed and at which update
             events for it will be queued.
             </summary>
             <value>Times per second at which the sensor is refreshed.</value>
             <remarks>
             Note that when setting sampling frequencies, there may be limits on the range of frequencies
             supported by the underlying hardware/platform.
            
             To support querying sampling frequencies, a sensor device must implement <see cref="T:UnityEngine.InputSystem.LowLevel.QuerySamplingFrequencyCommand"/>.
             To support setting frequencies, it must implemenet <see cref="T:UnityEngine.InputSystem.LowLevel.SetSamplingFrequencyCommand"/>.
             </remarks>
             <exception cref="T:System.NotSupportedException">Thrown when reading the property and the underlying
             sensor does not support querying of sampling frequencies.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.Accelerometer">
             <summary>
             Input device representing an accelerometer sensor.
             </summary>
             <remarks>
             An accelerometer let's you measure the acceleration of a device, and can be useful to control content by moving a device around.
             Note that the accelerometer will report the acceleration measured on a device both due to moving the device around, and due gravity
             pulling the device down. You can use <see cref="T:UnityEngine.InputSystem.GravitySensor"/> and <see cref="T:UnityEngine.InputSystem.LinearAccelerationSensor"/> to get decoupled values
             for these.
            
             <example>
             <code>
             class MyBehavior : MonoBehaviour
             {
                 protected void OnEnable()
                 {
                     // All sensors start out disabled so they have to manually be enabled first.
                     InputSystem.EnableDevice(Accelerometer.current);
                 }
            
                 protected void OnDisable()
                 {
                     InputSystem.DisableDevice(Accelerometer.current);
                 }
            
                 protected void Update()
                 {
                     var acceleration = Accelerometer.current.acceleration.ReadValue();
                     //...
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Accelerometer.current">
            <summary>
            The accelerometer that was last added or had activity last.
            </summary>
            <value>Current accelerometer or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Accelerometer.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Accelerometer.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Accelerometer.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.Gyroscope">
            <summary>
            Input device representing a gyroscope sensor.
            </summary>
            <remarks>
            A gyroscope let's you measure the angular velocity of a device, and can be useful to control content by rotating a device.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Gyroscope.current">
            <summary>
            The gyroscope that was last added or had activity last.
            </summary>
            <value>Current gyroscope or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.Gyroscope.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Gyroscope.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.Gyroscope.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.GravitySensor">
            <summary>
            Input device representing a gravity sensor.
            </summary>
            <remarks>
            A gravity sensor let's you determine the direction of the gravity vector relative to a device, and can be useful to control content by device orientation.
            This is usually derived from a hardware <see cref="T:UnityEngine.InputSystem.Accelerometer"/>, by subtracting the effect of linear acceleration (see <see cref="T:UnityEngine.InputSystem.LinearAccelerationSensor"/>).
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.GravitySensor.current">
            <summary>
            The gravity sensor that was last added or had activity last.
            </summary>
            <value>Current gravity sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.GravitySensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.GravitySensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.GravitySensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.AttitudeSensor">
            <summary>
            Input device representing an attitude sensor.
            </summary>
            <remarks>
            An attitude sensor let's you determine the orientation of a device, and can be useful to control content by rotating a device.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.AttitudeSensor.current">
            <summary>
            The attitude sensor that was last added or had activity last.
            </summary>
            <value>Current attitude sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.AttitudeSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.AttitudeSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.AttitudeSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.LinearAccelerationSensor">
            <summary>
            Input device representing linear acceleration affecting the device playing the content.
            </summary>
            <remarks>
            An accelerometer let's you measure the acceleration of a device, and can be useful to control content by moving a device around.
            Linear acceleration is the acceleration of a device unaffected by gravity forces.
            This is usually derived from a hardware <see cref="T:UnityEngine.InputSystem.Accelerometer"/>, by subtracting the effect of gravity (see <see cref="T:UnityEngine.InputSystem.GravitySensor"/>).
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.LinearAccelerationSensor.current">
            <summary>
            The linear acceleration sensor that was last added or had activity last.
            </summary>
            <value>Current linear acceleration sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.LinearAccelerationSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.LinearAccelerationSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.LinearAccelerationSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.MagneticFieldSensor">
            <summary>
            Input device representing the magnetic field affecting the device playing the content.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.MagneticFieldSensor.magneticField">
            <summary>
            Strength of the magnetic field reported by the sensor.
            </summary>
            <value>Control representing the strength of the magnetic field.</value>
            <remarks>
            Values are in micro-Tesla (uT) and measure the ambient magnetic field in the X, Y and Z axis.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.MagneticFieldSensor.current">
            <summary>
            The linear acceleration sensor that was last added or had activity last.
            </summary>
            <value>Current linear acceleration sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.MagneticFieldSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.MagneticFieldSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.MagneticFieldSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.LightSensor">
            <summary>
            Input device representing the ambient light measured by the device playing the content.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LightSensor.lightLevel">
            <summary>
            Light level in SI lux units.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.LightSensor.current">
            <summary>
            The light sensor that was last added or had activity last.
            </summary>
            <value>Current light sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.LightSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.LightSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.LightSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.PressureSensor">
            <summary>
            Input device representing the atmospheric pressure measured by the device playing the content.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.PressureSensor.atmosphericPressure">
            <summary>
            Atmospheric pressure in hPa (millibar).
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.PressureSensor.current">
            <summary>
            The pressure sensor that was last added or had activity last.
            </summary>
            <value>Current pressure sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.PressureSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.PressureSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.PressureSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.ProximitySensor">
            <summary>
            Input device representing the proximity of the device playing the content to the user.
            </summary>
            <remarks>
            The proximity sensor is usually used by phones to determine if the user is holding the phone to their ear or not.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.ProximitySensor.distance">
            <summary>
            Proximity sensor distance measured in centimeters.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.ProximitySensor.current">
            <summary>
            The proximity sensor that was last added or had activity last.
            </summary>
            <value>Current proximity sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.ProximitySensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.ProximitySensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.ProximitySensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.HumiditySensor">
            <summary>
            Input device representing the ambient air humidity measured by the device playing the content.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.HumiditySensor.relativeHumidity">
            <summary>
            Relative ambient air humidity in percent.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.HumiditySensor.current">
            <summary>
            The humidity sensor that was last added or had activity last.
            </summary>
            <value>Current humidity sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.HumiditySensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.HumiditySensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.HumiditySensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.AmbientTemperatureSensor">
            <summary>
            Input device representing the ambient air temperature measured by the device playing the content.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.AmbientTemperatureSensor.ambientTemperature">
            <summary>
            Temperature in degree Celsius.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.AmbientTemperatureSensor.current">
            <summary>
            The ambient temperature sensor that was last added or had activity last.
            </summary>
            <value>Current ambient temperature sensor or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.AmbientTemperatureSensor.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.AmbientTemperatureSensor.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.AmbientTemperatureSensor.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.StepCounter">
            <summary>
            Input device representing the foot steps taken by the user as measured by the device playing the content.
            </summary>
            <remarks>
            On iOS, access to the step counter must be enabled via <see cref="P:UnityEngine.InputSystem.InputSettings.iOSSettings.motionUsage"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.StepCounter.stepCounter">
            <summary>
            The number of steps taken by the user since the last reboot while activated.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.StepCounter.current">
            <summary>
            The step counter that was last added or had activity last.
            </summary>
            <value>Current step counter or <c>null</c>.</value>
        </member>
        <member name="M:UnityEngine.InputSystem.StepCounter.MakeCurrent">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.StepCounter.OnRemoved">
            <inheritdoc />
        </member>
        <member name="M:UnityEngine.InputSystem.StepCounter.FinishSetup">
            <inheritdoc />
        </member>
        <member name="T:UnityEngine.InputSystem.UnityRemoteSupport">
            <summary>
            Adds support for processing input-related messages sent from the <c>Unite Remote</c> app.
            </summary>
            <remarks>
            A hook in the Unity runtime allows us to observe messages received from the remote (see Modules/GenericRemoteEditor).
            We get the binary blob of each message and a shot at processing the message instead of
            the native code doing it.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionRebindingExtensions">
             <summary>
             Extensions to help with dynamically rebinding <see cref="T:UnityEngine.InputSystem.InputAction"/>s in
             various ways.
             </summary>
             <remarks>
             Unlike <see cref="T:UnityEngine.InputSystem.InputActionSetupExtensions"/>, the extension methods in here are meant to be
             called during normal game operation, i.e. as part of screens whether the user can rebind
             controls.
            
             The two primary duties of these extensions are to apply binding overrides that non-destructively
             redirect existing bindings and to facilitate user-controlled rebinding by listening for controls
             actuated by the user.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputActionSetupExtensions"/>
             <seealso cref="T:UnityEngine.InputSystem.InputBinding"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndex(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Get the index of the first binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> on <paramref name="action"/>
            that matches the given binding mask.
            </summary>
            <param name="action">An input action.</param>
            <param name="bindingMask">Binding mask to match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>).</param>
            <returns>The first binding on the action matching <paramref name="bindingMask"/> or -1 if no binding
            on the action matches the mask.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndex(UnityEngine.InputSystem.InputActionMap,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Get the index of the first binding in <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> on <paramref name="actionMap"/>
            that matches the given binding mask.
            </summary>
            <param name="actionMap">An input action map.</param>
            <param name="bindingMask">Binding mask to match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>).</param>
            <returns>The first binding on the action matching <paramref name="bindingMask"/> or -1 if no binding
            on the action matches the mask.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndex(UnityEngine.InputSystem.InputAction,System.String,System.String)">
            <summary>
            Get the index of the first binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> on <paramref name="action"/>
            that matches the given binding group and/or path.
            </summary>
            <param name="action">An input action.</param>
            <param name="group">Binding group to match (see <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>).</param>
            <param name="path">Binding path to match (see <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>).</param>
            <returns>The first binding on the action matching the given group and/or path or -1 if no binding
            on the action matches.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingForControl(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)">
            <summary>
            Return the binding that the given control resolved from.
            </summary>
            <param name="action">An input action that may be using the given control.</param>
            <param name="control">Control to look for a binding for.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="control"/>
            is <c>null</c>.</exception>
            <returns>The binding from which <paramref name="control"/> has been resolved or <c>null</c> if no such binding
            could be found on <paramref name="action"/>.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndexForControl(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)">
             <summary>
             Return the index into <paramref name="action"/>'s <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> that corresponds
             to <paramref name="control"/> bound to the action.
             </summary>
             <param name="action">The input action whose bindings to use.</param>
             <param name="control">An input control for which to look for a binding.</param>
             <returns>The index into the action's binding array for the binding that <paramref name="control"/> was
             resolved from or -1 if the control is not currently bound to the action.</returns>
             <remarks>
             Note that this method will only take currently active bindings into consideration. This means that if
             the given control <em>could</em> come from one of the bindings on the action but does not currently
             do so, the method still returns -1.
            
             In case you want to manually find out which of the bindings on the action could match the given control,
             you can do so using <see cref="M:UnityEngine.InputSystem.InputControlPath.Matches(System.String,UnityEngine.InputSystem.InputControl)"/>:
            
             <example>
             <code>
             // Find the binding on 'action' that matches the given 'control'.
             foreach (var binding in action.bindings)
                 if (InputControlPath.Matches(binding.effectivePath, control))
                     Debug.Log($"Binding for {control}: {binding}");
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="control"/>
             is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding.DisplayStringOptions,System.String)">
             <summary>
             Return a string suitable for display in UIs that shows what the given action is currently bound to.
             </summary>
             <param name="action">Action to create a display string for.</param>
             <param name="options">Optional set of formatting flags.</param>
             <param name="group">Optional binding group to restrict the operation to. If this is supplied, it effectively
             becomes the binding mask (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) to supply to <see
             cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)"/>.</param>
             <returns>A string suitable for display in rebinding UIs.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             This method will take into account any binding masks (such as from control schemes) in effect on the action
             (such as <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/> on the action itself, the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
             on its action map, or the <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/> on its asset) as well as the actual controls
             that the action is currently bound to (see <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>).
            
             <example>
             <code>
             var action = new InputAction();
            
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth", groups: "Gamepad");
             action.AddBinding("&lt;Mouse&gt;/leftButton", groups: "KeyboardMouse");
            
             // Prints "A | LMB".
             Debug.Log(action.GetBindingDisplayString());
            
             // Prints "A".
             Debug.Log(action.GetBindingDisplayString(group: "Gamepad");
            
             // Prints "LMB".
             Debug.Log(action.GetBindingDisplayString(group: "KeyboardMouse");
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)">
             <summary>
             Return a string suitable for display in UIs that shows what the given action is currently bound to.
             </summary>
             <param name="action">Action to create a display string for.</param>
             <param name="bindingMask">Mask for bindings to take into account. Any binding on the action not
             matching (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the mask is ignored and not included
             in the resulting string.</param>
             <param name="options">Optional set of formatting flags.</param>
             <returns>A string suitable for display in rebinding UIs.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             This method will take into account any binding masks (such as from control schemes) in effect on the action
             (such as <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/> on the action itself, the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
             on its action map, or the <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/> on its asset) as well as the actual controls
             that the action is currently bound to (see <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>).
            
             <example>
             <code>
             var action = new InputAction();
            
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth", groups: "Gamepad");
             action.AddBinding("&lt;Mouse&gt;/leftButton", groups: "KeyboardMouse");
            
             // Prints "A".
             Debug.Log(action.GetBindingDisplayString(InputBinding.MaskByGroup("Gamepad"));
            
             // Prints "LMB".
             Debug.Log(action.GetBindingDisplayString(InputBinding.MaskByGroup("KeyboardMouse"));
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)">
             <summary>
             Return a string suitable for display in UIs that shows what the given action is currently bound to.
             </summary>
             <param name="action">Action to create a display string for.</param>
             <param name="bindingIndex">Index of the binding in the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> array of
             <paramref name="action"/> for which to get a display string.</param>
             <param name="options">Optional set of formatting flags.</param>
             <returns>A string suitable for display in rebinding UIs.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             This method will ignore active binding masks and return the display string for the given binding whether it
             is masked out (disabled) or not.
            
             <example>
             <code>
             var action = new InputAction();
            
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth", groups: "Gamepad");
             action.AddBinding("&lt;Mouse&gt;/leftButton", groups: "KeyboardMouse");
            
             // Prints "A".
             Debug.Log(action.GetBindingDisplayString(0));
            
             // Prints "LMB".
             Debug.Log(action.GetBindingDisplayString(1));
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,System.String@,System.String@,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)">
             <summary>
             Return a string suitable for display in UIs that shows what the given action is currently bound to.
             </summary>
             <param name="action">Action to create a display string for.</param>
             <param name="bindingIndex">Index of the binding in the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> array of
             <paramref name="action"/> for which to get a display string.</param>
             <param name="deviceLayoutName">Receives the name of the <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/> used for the
             device in the given binding, if applicable. Otherwise is set to <c>null</c>. If, for example, the binding
             is <c>"&lt;Gamepad&gt;/buttonSouth"</c>, the resulting value is <c>"Gamepad</c>.</param>
             <param name="controlPath">Receives the path to the control on the device referenced in the given binding,
             if applicable. Otherwise is set to <c>null</c>. If, for example, the binding is <c>"&lt;Gamepad&gt;/leftStick/x"</c>,
             the resulting value is <c>"leftStick/x"</c>.</param>
             <param name="options">Optional set of formatting flags.</param>
             <returns>A string suitable for display in rebinding UIs.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             The information returned by <paramref name="deviceLayoutName"/> and <paramref name="controlPath"/> can be used, for example,
             to associate images with controls. Based on knowing which layout is used and which control on the layout is referenced, you
             can look up an image dynamically. For example, if the layout is based on <see cref="T:UnityEngine.InputSystem.DualShock.DualShockGamepad"/> (use
             <see cref="M:UnityEngine.InputSystem.InputSystem.IsFirstLayoutBasedOnSecond(System.String,System.String)"/> to determine inheritance), you can pick a PlayStation-specific image
             for the control as named by <paramref name="controlPath"/>.
            
             <example>
             <code>
             var action = new InputAction();
            
             action.AddBinding("&lt;Gamepad&gt;/dpad/up", groups: "Gamepad");
             action.AddBinding("&lt;Mouse&gt;/leftButton", groups: "KeyboardMouse");
            
             // Prints "A", then "Gamepad", then "dpad/up".
             Debug.Log(action.GetBindingDisplayString(0, out var deviceLayoutNameA, out var controlPathA));
             Debug.Log(deviceLayoutNameA);
             Debug.Log(controlPathA);
            
             // Prints "LMB", then "Mouse", then "leftButton".
             Debug.Log(action.GetBindingDisplayString(1, out var deviceLayoutNameB, out var controlPathB));
             Debug.Log(deviceLayoutNameB);
             Debug.Log(controlPathB);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingIndex(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String)">
             <summary>
             Put an override on all matching bindings of <paramref name="action"/>.
             </summary>
             <param name="action">Action to apply the override to.</param>
             <param name="newPath">New binding path to take effect. Supply an empty string
             to disable the binding(s). See <see cref="T:UnityEngine.InputSystem.InputControlPath"/> for details on
             the path language.</param>
             <param name="group">Optional list of binding groups to target the override
             to. For example, <c>"Keyboard;Gamepad"</c> will only apply overrides to bindings
             that either have the <c>"Keyboard"</c> or the <c>"Gamepad"</c> binding group
             listed in <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>.</param>
             <param name="path">Only override bindings that have this exact path.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             Calling this method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
             with the properties of the given <see cref="T:UnityEngine.InputSystem.InputBinding"/> initialized accordingly.
            
             <example>
             <code>
             // Override the binding to the gamepad A button with a binding to
             // the Y button.
             fireAction.ApplyBindingOverride("&lt;Gamepad&gt;/buttonNorth",
                 path: "&lt;Gamepad&gt;/buttonSouth);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Apply overrides to all bindings on <paramref name="action"/> that match <paramref name="bindingOverride"/>.
             The override values are taken from <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>,
             and <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/> on <paramref name="bindingOverride"/>.
             </summary>
             <param name="action">Action to override bindings on.</param>
             <param name="bindingOverride">A binding that both acts as a mask (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>)
             on the bindings to <paramref name="action"/> and as a container for the override values.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <remarks>
             The method will go through all of the bindings for <paramref name="action"/> (i.e. its <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>)
             and call <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> on them with <paramref name="bindingOverride"/>.
             For every binding that returns <c>true</c> from <c>Matches</c>, the override values from the
             binding (i.e. <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>,
             and <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>) are copied into the binding.
            
             Binding overrides are non-destructive. They do not change the bindings set up for an action
             but rather apply non-destructive modifications that change the paths of existing bindings.
             However, this also means that for overrides to work, there have to be existing bindings that
             can be modified.
            
             This is achieved by setting <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/> which is a non-serialized
             property. When resolving bindings, the system will use <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/>
             which uses <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/> if set or <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             otherwise. The same applies to <see cref="P:UnityEngine.InputSystem.InputBinding.effectiveProcessors"/> and <see
             cref="P:UnityEngine.InputSystem.InputBinding.effectiveInteractions"/>.
            
             <example>
             <code>
             // Override the binding in the "KeyboardMouse" group on 'fireAction'
             // by setting its override binding path to the space bar on the keyboard.
             fireAction.ApplyBindingOverride(new InputBinding
             {
                 groups = "KeyboardMouse",
                 overridePath = "&lt;Keyboard&gt;/space"
             });
             </code>
             </example>
            
             If the given action is enabled when calling this method, the effect will be immediate,
             i.e. binding resolution takes place and <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> are updated.
             If the action is not enabled, binding resolution is deferred to when controls are needed
             next (usually when either <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> is queried or when the
             action is enabled).
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Apply a binding override to the Nth binding on the given action.
             </summary>
             <param name="action">Action to apply the binding override to.</param>
             <param name="bindingIndex">Index of the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> to
             which to apply the override to.</param>
             <param name="bindingOverride">A binding that specifies the overrides to apply. In particular,
             the <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>, and
             <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/> properties will be copied into the binding
             in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>. The remaining fields will be ignored by this method.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is null.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is out of range.</exception>
             <remarks>
             Unlike <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/> this method will
             not use <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> to determine which binding to apply the
             override to. Instead, it will apply the override to the binding at the given index
             and to that binding alone.
            
             The remaining details of applying overrides are identical to <see
             cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>.
            
             Note that calling this method with an empty (default-constructed) <paramref name="bindingOverride"/>
             is equivalent to resetting all overrides on the given binding.
            
             <example>
             <code>
             // Reset the overrides on the second binding on 'fireAction'.
             fireAction.ApplyBindingOverride(1, default);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,System.String)">
             <summary>
             Apply a binding override to the Nth binding on the given action.
             </summary>
             <param name="action">Action to apply the binding override to.</param>
             <param name="bindingIndex">Index of the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> to
             which to apply the override to.</param>
             <param name="path">Override path (<see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>) to set on
             the given binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is null.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is out of range.</exception>
             <remarks>
             Calling this method is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
             like so:
            
             <example>
             <code>
             action.ApplyBindingOverride(new InputBinding { overridePath = path });
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputActionMap,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Apply the given binding override to all bindings in the map that are matched by the override.
            </summary>
            <param name="actionMap">An action map. Overrides will be applied to its <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>.</param>
            <param name="bindingOverride">Binding that is matched (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) against
            the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>. The binding's
            <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>, and
            <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/> properties will be copied over to any matching binding.</param>
            <returns>The number of bindings overridden in the given map.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c>.</exception>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputActionMap,System.Int32,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Copy the override properties (<see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>, <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>,
            and <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>) from <paramref name="bindingOverride"/> over to the
            binding at index <paramref name="bindingIndex"/> in <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>.
            </summary>
            <param name="actionMap">Action map whose bindings to modify.</param>
            <param name="bindingIndex">Index of the binding to modify in <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of
            <paramref name="actionMap"/>.</param>
            <param name="bindingOverride">Binding whose override properties (<see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>,
            <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>) to copy.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is not a valid index for
            <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RemoveBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32)">
            <summary>
            Remove any overrides from the binding on <paramref name="action"/> with the given index.
            </summary>
            <param name="action">Action whose bindings to modify.</param>
            <param name="bindingIndex">Index of the binding within <paramref name="action"/>'s <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is invalid.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RemoveBindingOverride(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputBinding)">
            <summary>
            Remove any overrides from the binding on <paramref name="action"/> matching the given binding mask.
            </summary>
            <param name="action">Action whose bindings to modify.</param>
            <param name="bindingMask">Mask that will be matched against the bindings on <paramref name="action"/>. All bindings
            that match the mask (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) will have their overrides removed. If none of the
            bindings on the action match the mask, no bindings will be modified.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <remarks>
            <example>
            <code>
            // Remove all binding overrides from bindings associated with the "Gamepad" binding group.
            myAction.RemoveBindingOverride(InputBinding.MaskByGroup("Gamepad"));
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RemoveAllBindingOverrides(UnityEngine.InputSystem.IInputActionCollection2)">
            <summary>
            Restore all bindings in the map to their defaults.
            </summary>
            <param name="actions">Collection of actions to remove overrides from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="actions"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RemoveAllBindingOverrides(UnityEngine.InputSystem.InputAction)">
            <summary>
            Remove all binding overrides on <paramref name="action"/>, i.e. clear all <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>,
            <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/> set on bindings
            for the given action.
            </summary>
            <param name="action">Action to remove overrides from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverridesOnMatchingControls(UnityEngine.InputSystem.InputAction,UnityEngine.InputSystem.InputControl)">
             <summary>
             For all bindings in the <paramref name="action"/>, if a binding matches a control in the given control
             hierarchy, set an override on the binding to refer specifically to that control.
             </summary>
             <param name="action">An action whose bindings to modify.</param>
             <param name="control">A control hierarchy or an entire <see cref="T:UnityEngine.InputSystem.InputDevice"/>.</param>
             <returns>The number of binding overrides that have been applied to the given action.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="control"/>
             is <c>null</c>.</exception>
             <remarks>
             This method can be used to restrict bindings that otherwise apply to a wide set of possible
             controls.
            
             <example>
             <code>
             // Create two gamepads.
             var gamepad1 = InputSystem.AddDevice&lt;Gamepad&gt;();
             var gamepad2 = InputSystem.AddDevice&lt;Gamepad&gt;();
            
             // Create an action that binds to the A button on gamepads.
             var action = new InputAction();
             action.AddBinding("&lt;Gamepad&gt;/buttonSouth");
            
             // When we enable the action now, it will bind to both
             // gamepad1.buttonSouth and gamepad2.buttonSouth.
             action.Enable();
            
             // But let's say we want the action to specifically work
             // only with the first gamepad. One way to do it is like
             // this:
             action.ApplyBindingOverridesOnMatchingControls(gamepad1);
            
             // As "&lt;Gamepad&gt;/buttonSouth" matches the gamepad1.buttonSouth
             // control, an override will automatically be applied such that
             // the binding specifically refers to that button on that gamepad.
             </code>
             </example>
            
             Note that for actions that are part of <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s and/or
             <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>s, it is possible to restrict actions to
             specific device without having to set overrides. See <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
             and <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.devices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverridesOnMatchingControls(UnityEngine.InputSystem.InputActionMap,UnityEngine.InputSystem.InputControl)">
             <summary>
             For all bindings in the <paramref name="actionMap"/>, if a binding matches a control in the given control
             hierarchy, set an override on the binding to refer specifically to that control.
             </summary>
             <param name="actionMap">An action map whose bindings to modify.</param>
             <param name="control">A control hierarchy or an entire <see cref="T:UnityEngine.InputSystem.InputDevice"/>.</param>
             <returns>The number of binding overrides that have been applied to the given action.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c> -or- <paramref name="control"/>
             is <c>null</c>.</exception>
             <remarks>
             This method can be used to restrict bindings that otherwise apply to a wide set of possible
             controls. It will go through <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> and apply overrides to
             <example>
             <code>
             // Create two gamepads.
             var gamepad1 = InputSystem.AddDevice&lt;Gamepad&gt;();
             var gamepad2 = InputSystem.AddDevice&lt;Gamepad&gt;();
            
             // Create an action map with an action for the A and B buttons
             // on gamepads.
             var actionMap = new InputActionMap();
             var aButtonAction = actionMap.AddAction("a", binding: "&lt;Gamepad&gt;/buttonSouth");
             var bButtonAction = actionMap.AddAction("b", binding: "&lt;Gamepad&gt;/buttonEast");
            
             // When we enable the action map now, the actions will bind
             // to the buttons on both gamepads.
             actionMap.Enable();
            
             // But let's say we want the actions to specifically work
             // only with the first gamepad. One way to do it is like
             // this:
             actionMap.ApplyBindingOverridesOnMatchingControls(gamepad1);
            
             // Now binding overrides on the actions will be set to specifically refer
             // to the controls on the first gamepad.
             </code>
             </example>
            
             Note that for actions that are part of <see cref="T:UnityEngine.InputSystem.InputActionMap"/>s and/or
             <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>s, it is possible to restrict actions to
             specific device without having to set overrides. See <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>
             and <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>.
            
             <example>
             <code>
             // For an InputActionMap, we could alternatively just do:
             actionMap.devices = new InputDevice[] { gamepad1 };
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.devices"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)">
             <summary>
             Return a JSON string containing all overrides applied to bindings in the given set of <paramref name="actions"/>.
             </summary>
             <param name="actions">A collection of <see cref="T:UnityEngine.InputSystem.InputAction"/>s such as an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> or
             an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>.</param>
             <returns>A JSON string containing a serialized version of the overrides applied to bindings in the given set of actions.</returns>
             <remarks>
             This method can be used to serialize the overrides, i.e. <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>,
             <see cref="P:UnityEngine.InputSystem.InputBinding.overrideProcessors"/>, and <see cref="P:UnityEngine.InputSystem.InputBinding.overrideInteractions"/>, applied to
             bindings in the set of actions. Only overrides will be saved.
            
             <example>
             <code>
             void SaveUserRebinds(PlayerInput player)
             {
                 var rebinds = player.actions.SaveBindingOverridesAsJson();
                 PlayerPrefs.SetString("rebinds", rebinds);
             }
            
             void LoadUserRebinds(PlayerInput player)
             {
                 var rebinds = PlayerPrefs.GetString("rebinds");
                 player.actions.LoadBindingOverridesFromJson(rebinds);
             }
             </code>
             </example>
            
             Note that this method can also be used with C# wrapper classes generated from .inputactions assets.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actions"/> is <c>null</c>.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.IInputActionCollection2,System.String,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.InputAction)">
            <summary>
            Return a string in JSON format that contains all overrides applied <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
            of <paramref name="action"/>.
            </summary>
            <param name="action">An action for which to extract binding overrides.</param>
            <returns>A string in JSON format containing binding overrides for <paramref name="action"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
            <remarks>
            This overrides can be restored using <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.InputAction,System.String,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.IInputActionCollection2,System.String,System.Boolean)">
             <summary>
             Restore all binding overrides stored in the given JSON string to the bindings in <paramref name="actions"/>.
             </summary>
             <param name="actions">A set of actions and their bindings, such as an <see cref="T:UnityEngine.InputSystem.InputActionMap"/>, an
             <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>, or a C# wrapper class generated from an .inputactions asset.</param>
             <param name="json">A string persisting binding overrides in JSON format. See
             <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>.</param>
             <param name="removeExisting">If true (default), all existing overrides present on the bindings
             of <paramref name="actions"/> will be removed first. If false, existing binding overrides will be left
             in place but may be overwritten by overrides present in <paramref name="json"/>.</param>
             <remarks>
             <example>
             <code>
             void SaveUserRebinds(PlayerInput player)
             {
                 var rebinds = player.actions.SaveBindingOverridesAsJson();
                 PlayerPrefs.SetString("rebinds", rebinds);
             }
            
             void LoadUserRebinds(PlayerInput player)
             {
                 var rebinds = PlayerPrefs.GetString("rebinds");
                 player.actions.LoadBindingOverridesFromJson(rebinds);
             }
             </code>
             </example>
            
             Note that this method can also be used with C# wrapper classes generated from .inputactions assets.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actions"/> is <c>null</c>.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.LoadBindingOverridesFromJson(UnityEngine.InputSystem.InputAction,System.String,System.Boolean)">
             <summary>
             Restore all binding overrides stored in the given JSON string to the bindings of <paramref name="action"/>.
             </summary>
             <param name="action">Action to restore bindings on.</param>
             <param name="json">A string persisting binding overrides in JSON format. See
             <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.InputAction)"/>.</param>
             <param name="removeExisting">If true (default), all existing overrides present on the bindings
             of <paramref name="action"/> will be removed first. If false, existing binding overrides will be left
             in place but may be overwritten by overrides present in <paramref name="json"/>.</param>
             <remarks>
             <example>
             <code>
             void SaveUserRebinds(PlayerInput player)
             {
                 var rebinds = player.actions.SaveBindingOverridesAsJson();
                 PlayerPrefs.SetString("rebinds", rebinds);
             }
            
             void LoadUserRebinds(PlayerInput player)
             {
                 var rebinds = PlayerPrefs.GetString("rebinds");
                 player.actions.LoadBindingOverridesFromJson(rebinds);
             }
             </code>
             </example>
            
             Note that this method can also be used with C# wrapper classes generated from .inputactions assets.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actions"/> is <c>null</c>.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.SaveBindingOverridesAsJson(UnityEngine.InputSystem.IInputActionCollection2)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation">
             <summary>
             An ongoing rebinding operation.
             </summary>
             <remarks>
             <example>
             An example for how to use this class comes with the Input System package in the form of the "Rebinding UI" sample
             that can be installed from the Package Manager UI in the Unity editor. The sample comes with a reusable <c>RebindActionUI</c>
             component that also has a dedicated custom inspector.
             </example>
            
             The most convenient way to use this class is by using <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.PerformInteractiveRebinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>.
             This method sets up many default behaviors based on the information found in the given action.
            
             Note that instances of this class <em>must</em> be disposed of to not leak memory on the unmanaged heap.
            
             <example>
             <code>
             // A MonoBehaviour that can be hooked up to a UI.Button control.
             public class RebindButton : MonoBehaviour
             {
                 public InputActionReference m_Action; // Reference to an action to rebind.
                 public int m_BindingIndex; // Index into m_Action.bindings for binding to rebind.
                 public Text m_DisplayText; // Text in UI that receives the binding display string.
            
                 public void OnEnable()
                 {
                     UpdateDisplayText();
                 }
            
                 public void OnDisable()
                 {
                     m_Rebind?.Dispose();
                 }
            
                 public void OnClick()
                 {
                     var rebind = m_Action.PerformInteractiveRebinding()
                         .WithTargetBinding(m_BindingIndex)
                         .OnComplete(_ => UpdateDisplayText())
                         .Start();
                 }
            
                 private void UpdateDisplayText()
                 {
                     m_DisplayText.text = m_Action.GetBindingDisplayString(m_BindingIndex);
                 }
            
                 private void RebindingOperation m_Rebind;
             }
            
             rebind.Start();
             </code>
             </example>
            
             The goal of a rebind is always to generate a control path (see <see cref="T:UnityEngine.InputSystem.InputControlPath"/>) usable
             with a binding. By default, the generated path will be installed in <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>.
             This is non-destructive as the original path is left intact in the form of <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.
            
             This class acts as both a configuration interface for rebinds as well as a controller while
             the rebind is ongoing. An instance can be reused arbitrary many times. Doing so can avoid allocating
             additional GC memory (the class internally retains state that it can reuse for multiple rebinds).
            
             Note, however, that during rebinding it can be necessary to look at the <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
             information registered in the system which means that layouts may have to be loaded. These will be
             cached for as long as the rebind operation is not disposed of.
            
             To reset the configuration of a rebind operation without releasing its memory, call <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Reset"/>.
             Note that changing configuration while a rebind is in progress in not allowed and will throw
             <see cref="T:System.InvalidOperationException"/>.
            
             Note that it is also possible to use this class for selecting controls interactively without also
             having an <see cref="T:UnityEngine.InputSystem.InputAction"/> or even associated <see cref="T:UnityEngine.InputSystem.InputBinding"/>s. To set this up,
             configure the rebind accordingly with the respective methods (such as <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithExpectedControlType``1"/>)
             and use <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnApplyBinding(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation,System.String})"/> to intercept the binding override process and instead use custom
             logic to do something with the resulting path (or to even just use the control list found in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>).
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.PerformInteractiveRebinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.action">
            <summary>
            The action that rebinding is being performed on.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.bindingMask">
            <summary>
            Optional mask to determine which bindings to apply overrides to.
            </summary>
            <remarks>
            If this is not null, all bindings that match this mask will have overrides applied to them.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates">
            <summary>
            Controls that had input and were deemed potential matches to rebind to.
            </summary>
            <remarks>
            Controls in the list should be ordered by priority with the first element in the list being
            considered the best match.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.AddCandidate(UnityEngine.InputSystem.InputControl,System.Single,System.Single)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.RemoveCandidate(UnityEngine.InputSystem.InputControl)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores">
             <summary>
             The matching score for each control in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>.
             </summary>
             <value>A relative floating-point score for each control in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>.</value>
             <remarks>
             Candidates are ranked and sorted by their score. By default, a score is computed for each candidate
             control automatically. However, this can be overridden using <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComputeScore(System.Func{UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single})"/>.
            
             Default scores are directly based on magnitudes (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>).
             The greater the magnitude of actuation, the greater the score associated with the control. This means,
             for example, that if both X and Y are actuated on a gamepad stick, the axis with the greater amount
             of actuation will get scored higher and thus be more likely to get picked.
            
             In addition, 1 is added to each default score if the respective control is non-synthetic (see <see
             cref="P:UnityEngine.InputSystem.InputControl.synthetic"/>). This will give controls that correspond to actual controls present
             on the device precedence over those added internally. For example, if both are actuated, the synthetic
             <see cref="P:UnityEngine.InputSystem.Controls.StickControl.up"/> button on stick controls will be ranked lower than the <see
             cref="P:UnityEngine.InputSystem.Gamepad.buttonSouth"/> which is an actual button on the device.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComputeScore(System.Func{UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single})"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes">
            <summary>
            The matching control actuation level (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> for each control in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>.
            </summary>
            <value><see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> result for each <see cref="T:UnityEngine.InputSystem.InputControl"/> in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>.</value>
            <remarks>
            This array mirrors <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>, i.e. each entry corresponds to the entry in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/> at
            the same index.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.selectedControl">
            <summary>
            The control currently deemed the best candidate.
            </summary>
            <value>Primary candidate control at this point.</value>
            <remarks>
            If there are no candidates yet, this returns <c>null</c>. If there are candidates,
            it returns the first element of <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/> which is always the control
            with the highest matching score.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.started">
            <summary>
            Whether the rebind is currently in progress.
            </summary>
            <value>Whether rebind is in progress.</value>
            <remarks>
            This is true after calling <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Start"/> and set to false when
            <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComplete(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/> or <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnCancel(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/> is called.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Start"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.completed"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.canceled"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.completed">
            <summary>
            Whether the rebind has been completed.
            </summary>
            <value>True if the rebind has been completed.</value>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComplete(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComplete(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.canceled">
            <summary>
            Whether the rebind has been cancelled.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnCancel(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.expectedControlType">
             <summary>
             Name of the control layout that the rebind is looking for.
             </summary>
             <remarks>
             This is optional but in general, rebinds will be more successful when the operation knows
             what kind of input it is looking for.
            
             If an action is supplied with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/> (automatically done by <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.PerformInteractiveRebinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>),
             the expected control type is automatically set to <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> or, if that is
             not set, to <c>"Button"</c> in case the action has type <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/>.
            
             If a binding is supplied with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/> and the binding is a part binding (see <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>),
             the expected control type is automatically set to that expected by the respective part of the composite.
            
             If this is set, any input on controls that are not of the expected type is ignored. If this is not set,
             any control that matches all of the other criteria is considered for rebinding.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.layout"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)">
             <summary>
             Perform rebinding on the bindings of the given action.
             </summary>
             <param name="action">Action to perform rebinding on.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             Note that by default, a rebind does not have a binding mask or any other setting
             that constrains which binding the rebind is applied to. This means that if the action
             has multiple bindings, all of them will have overrides applied to them.
            
             To target specific bindings, either set a binding index with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/>,
             or set a binding mask with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingMask(System.Nullable{UnityEngine.InputSystem.InputBinding})"/> or <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)"/>.
            
             If the action has an associated <see cref="P:UnityEngine.InputSystem.InputAction.expectedControlType"/> set,
             it will automatically be passed to <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithExpectedControlType(System.String)"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.InvalidOperationException"><paramref name="action"/> is currently enabled.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.PerformInteractiveRebinding(UnityEngine.InputSystem.InputAction,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithMatchingEventsBeingSuppressed(System.Boolean)">
             <summary>
             Prevent all input events that have input matching the rebind operation's configuration from reaching
             its targeted <see cref="T:UnityEngine.InputSystem.InputDevice"/>s and thus taking effect.
             </summary>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             While rebinding interactively, it is usually for the most part undesirable for input to actually have an effect.
             For example, when rebind gamepad input, pressing the "A" button should not lead to a "submit" action in the UI.
             For this reason, a rebind can be configured to automatically swallow any input event except the ones having
             input on controls matching <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsExcluding(System.String)"/>.
            
             Not at all input necessarily should be suppressed. For example, it can be desirable to have UI that
             allows the user to cancel an ongoing rebind by clicking with the mouse. This means that mouse position and
             click input should come through. For this reason, input from controls matching <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsExcluding(System.String)"/>
             is still let through.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithCancelingThrough(System.String)">
             <summary>
             Set the control path that is matched against actuated controls.
             </summary>
             <param name="binding">A control path (see <see cref="T:UnityEngine.InputSystem.InputControlPath"/>) such as <c>"&lt;Keyboard&gt;/escape"</c>.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             Note that every rebind operation has only one such path. Calling this method repeatedly will overwrite
             the path set from prior calls.
            
             <code>
             var rebind = new RebindingOperation();
            
             // Cancel from keyboard escape key.
             rebind
                 .WithCancelingThrough("&lt;Keyboard&gt;/escape");
            
             // Cancel from any control with "Cancel" usage.
             // NOTE: This can be dangerous. The control that the wants to bind to may have the "Cancel"
             //       usage assigned to it, thus making it impossible for the user to bind to the control.
             rebind
                 .WithCancelingThrough("*/{Cancel}");
             </code>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)">
             <summary>
             Rebinding a specific <see cref="T:UnityEngine.InputSystem.InputBinding"/> on an <see cref="T:UnityEngine.InputSystem.InputAction"/> as identified
             by the given index into <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>.
             </summary>
             <param name="bindingIndex">Index into <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the action supplied
             by <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             Note that if the given binding is a part binding of a composite (see <see cref="P:UnityEngine.InputSystem.InputBinding.isPartOfComposite"/>),
             then the expected control type (see <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithExpectedControlType(System.String)"/>) is implicitly changed to
             match the type of control expected by the given part. If, for example, the composite the part belongs to
             is a <see cref="T:UnityEngine.InputSystem.Composites.Vector2Composite"/>, then the expected control type is implicitly changed to
             <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>.
            
             <example>
             <code>
             // Create an action with a WASD setup.
             var moveAction = new InputAction(expectedControlType: "Vector2");
             moveAction.AddCompositeBinding("2DVector")
                 .With("Up", "&lt;Keyboard&gt;/w")
                 .With("Down", "&lt;Keyboard&gt;/s")
                 .With("Left", "&lt;Keyboard&gt;/a")
                 .With("Right", "&lt;Keyboard&gt;/d");
            
             // Start a rebind of the "Up" binding.
             moveAction.PerformInteractiveRebinding()
                 .WithTargetBinding(1)
                 .Start();
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is negative.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingMask(System.Nullable{UnityEngine.InputSystem.InputBinding})"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingMask(System.Nullable{UnityEngine.InputSystem.InputBinding})">
            <summary>
            Apply the rebinding to all <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the action given by <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>
            which are match the given binding mask (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>).
            </summary>
            <param name="bindingMask">A binding mask. See <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.</param>
            <returns>The same RebindingOperation instance.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)">
            <summary>
            Apply the rebinding to all <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of the action given by <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>
            which are associated with the given binding group (see <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>).
            </summary>
            <param name="group">A binding group. See <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>. A binding matches if any of its
            group associates matches.</param>
            <returns>The same RebindingOperation instance.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingMask(System.Nullable{UnityEngine.InputSystem.InputBinding})"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithoutGeneralizingPathOfSelectedControl">
             <summary>
             Disable the default behavior of automatically generalizing the path of a selected control.
             </summary>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             At runtime, every <see cref="T:UnityEngine.InputSystem.InputControl"/> has a unique path in the system (<see cref="P:UnityEngine.InputSystem.InputControl.path"/>).
             However, when performing rebinds, we are not generally interested in the specific runtime path of the
             control -- which may depend on the number and types of devices present. In fact, most of the time we are not
             even interested in what particular brand of device the user is rebinding to but rather want to just bind based
             on the device's broad category.
            
             For example, if the user has a DualShock controller and performs an interactive rebind, we usually do not want
             to generate override paths that reflects that the input specifically came from a DualShock controller. Rather,
             we're usually interested in the fact that it came from a gamepad.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnGeneratePath(System.Func{UnityEngine.InputSystem.InputControl,System.String})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithRebindAddingNewBinding(System.String)">
            <summary>
            Instead of applying the generated path as an <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/>,
            create a new binding on the given action (see <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>).
            </summary>
            <param name="group">Binding group (see <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>) to apply to the new binding.
            This determines, for example, which control scheme (if any) the binding is associated with.</param>
            <returns></returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnApplyBinding(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation,System.String})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithMagnitudeHavingToBeGreaterThan(System.Single)">
             <summary>
             Require actuation of controls to exceed a certain level.
             </summary>
             <param name="magnitude">Minimum magnitude threshold that has to be reached on a control
             for it to be considered a candidate. See <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> for
             details about magnitude evaluations.</param>
             <returns>The same RebindingOperation instance.</returns>
             <exception cref="T:System.ArgumentException"><paramref name="magnitude"/> is negative.</exception>
             <remarks>
             Rebind operations use a default threshold of 0.2. This means that the actuation level
             of any control as returned by <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/> must be equal
             or greater than 0.2 for it to be considered a potential candidate. This helps filter out
             controls that are actuated incidentally as part of actuating other controls.
            
             For example, if the player wants to bind an action to the X axis of the gamepad's right
             stick, the player will almost unavoidably also actuate the Y axis to a certain degree.
             However, if actuation of the Y axis stays under 2.0, it will automatically get filtered out.
            
             Note that the magnitude threshold is not the only mechanism that helps trying to find
             the most actuated control. In fact, all controls will eventually be sorted by magnitude
             of actuation so even if both X and Y of a stick make it into the candidate list, if X
             is actuated more strongly than Y, it will be favored.
            
             Note that you can also use this method to <em>lower</em> the default threshold of 0.2
             in case you want more controls to make it through the matching process.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithoutIgnoringNoisyControls">
             <summary>
             Do not ignore input from noisy controls.
             </summary>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             By default, noisy controls are ignored for rebinds. This means that, for example, a gyro
             inside a gamepad will not be considered as a potential candidate control as it is hard
             to tell valid user interaction on the control apart from random jittering that occurs
             on noisy controls.
            
             By calling this method, this behavior can be disabled. This is usually only useful when
             implementing custom candidate selection through <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnPotentialMatch(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/>.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsHavingToMatchPath(System.String)">
             <summary>
             Restrict candidate controls using a control path (see <see cref="T:UnityEngine.InputSystem.InputControlPath"/>).
             </summary>
             <param name="path">A control path. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/>.</param>
             <returns>The same RebindingOperation instance.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c> or empty.</exception>
             <remarks>
             This method is most useful to, for example, restrict controls to specific types of devices.
             If, say, you want to let the player only bind to gamepads, you can do so using
            
             <example>
             <code>
             rebind.WithControlsHavingToMatchPath("&lt;Gamepad&gt;");
             </code>
             </example>
            
             This method can be called repeatedly to add multiple paths. The effect is that candidates
             are accepted if <em>any</em> of the given paths matches. To reset the list, call <see
             cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Reset"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.Matches(System.String,UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsExcluding(System.String)">
             <summary>
             Prevent specific controls from being considered as candidate controls.
             </summary>
             <param name="path">A control path. See <see cref="T:UnityEngine.InputSystem.InputControlPath"/>.</param>
             <returns>The same RebindingOperation instance.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c> or empty.</exception>
             <remarks>
             Some controls can be undesirable to include in the candidate selection process even
             though they constitute valid, non-noise user input. For example, in a desktop application,
             the mouse will usually be used to navigate the UI including a rebinding UI that makes
             use of RebindingOperation. It can thus be advisable to exclude specific pointer controls
             like so:
            
             <example>
             <code>
             rebind
                 .WithControlsExcluding("&lt;Pointer&gt;/position") // Don't bind to mouse position
                 .WithControlsExcluding("&lt;Pointer&gt;/delta") // Don't bind to mouse movement deltas
                 .WithControlsExcluding("&lt;Pointer&gt;/{PrimaryAction}") // don't bind to controls such as leftButton and taps.
             </code>
             </example>
            
             This method can be called repeatedly to add multiple exclusions. To reset the list,
             call <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Reset"/>.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlPath.Matches(System.String,UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTimeout(System.Single)">
             <summary>
             If no match materializes with <paramref name="timeInSeconds"/>, cancel the rebind automatically.
             </summary>
             <param name="timeInSeconds">Time in seconds to wait for a successful rebind. Disabled if timeout is less than or equal to 0.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             Limiting rebinds by time can be useful in situations where a rebind may potentially put the user in a situation where
             there is no other way to escape the rebind. For example, if <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithMatchingEventsBeingSuppressed(System.Boolean)"/> is engaged,
             input may be consumed by the rebind and thus not reach the UI if <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsExcluding(System.String)"/> has not also been
             configured accordingly.
            
             By default, no timeout is set.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.timeout"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComplete(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})">
            <summary>
            Delegate to invoke when the rebind completes successfully.
            </summary>
            <param name="callback">A delegate to invoke when the rebind is <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.completed"/>.</param>
            <returns>The same RebindingOperation instance.</returns>
            <remarks>
            Note that by the time this is invoked, the rebind has been fully applied, that is
            <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnApplyBinding(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation,System.String})"/> has been executed.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnCancel(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})">
            <summary>
            Delegate to invoke when the rebind is cancelled instead of completing. This happens when either an
            input is received from a control explicitly set up to trigger cancellation (see <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithCancelingThrough(System.String)"/>
            and <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithCancelingThrough(UnityEngine.InputSystem.InputControl)"/>) or when <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Cancel"/> is called
            explicitly.
            </summary>
            <param name="callback">Delegate to invoke when the rebind is cancelled.</param>
            <returns></returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithCancelingThrough(System.String)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Cancel"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.canceled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnPotentialMatch(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})">
            <summary>
            Delegate to invoke when the rebind has found one or more controls that it considers
            potential matches. This allows modifying priority of matches or adding or removing
            matches altogether.
            </summary>
            <param name="callback">Callback to invoke when one or more suitable controls have been found.</param>
            <returns>The same RebindingOperation instance.</returns>
            <remarks>
            The matches will be contained in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>. In the callback, you can,
            for example, alter the contents of the list in order to customize the selection process.
            You can remove candidates with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.AddCandidate(UnityEngine.InputSystem.InputControl,System.Single,System.Single)"/> and/or remove candidates
            with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.RemoveCandidate(UnityEngine.InputSystem.InputControl)"/>.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnGeneratePath(System.Func{UnityEngine.InputSystem.InputControl,System.String})">
             <summary>
             Set function to call when generating the final binding path (see <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>) for a control
             that has been selected.
             </summary>
             <param name="callback">Delegate to call for when to generate a binding path.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             A rebind will by default create a path that it deems most useful for the purpose of rebinding. However, this
             logic may be undesirable for your use case. By supplying a custom callback you can bypass this logic and thus replace it.
            
             When a matching control is singled out, the default logic will look for the device that introduces the given
             control. For example, if the A button is pressed on an Xbox gamepad, the resulting path will be <c>"&lt;Gamepad&gt;/buttonSouth"</c>
             as it is the <see cref="T:UnityEngine.InputSystem.Gamepad"/> device that introduces the south face button on gamepads. Thus, the binding will work
             with any other gamepad, not just the Xbox controller.
            
             If the delegate returns a null or empty string, the default logic will be re-engaged.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithoutGeneralizingPathOfSelectedControl"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnComputeScore(System.Func{UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single})">
             <summary>
             Delegate to invoke for compute the matching score for a candidate control.
             </summary>
             <param name="callback">A delegate that computes matching scores.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             By default, the actuation level of a control is used as its matching score. For a <see cref="T:UnityEngine.InputSystem.Controls.StickControl"/>,
             for example, the vector magnitude of the control will be its score. So, a stick that is actuated just a little
             will have a lower score than a stick that is actuated to maximum extent in one direction.
            
             The control with the highest score will be the one appearing at index 0 in <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/> and thus
             will be the control picked by the rebind as the top candidate.
            
             By installing a custom delegate, it is possible to customize the scoring and apply custom logic to boost
             or lower scores of controls.
            
             The first argument to the delegate is the control that is being added to <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/> and the
             second argument is a pointer to the input event that contains an input on the control.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnApplyBinding(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation,System.String})">
             <summary>
             Apply a generated binding <see cref="P:UnityEngine.InputSystem.InputBinding.path"/> as the final step to complete a rebind.
             </summary>
             <param name="callback">Delegate to invoke in order to the apply the generated binding path.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             Once a binding path has been generated (see <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnGeneratePath(System.Func{UnityEngine.InputSystem.InputControl,System.String})"/>) from a candidate control,
             the last step is to apply the path. The default logic will take the supplied action (see <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>)
             and apply the path as an <see cref="P:UnityEngine.InputSystem.InputBinding.overridePath"/> on all bindings that have been selected
             for rebinding with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/>, <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingMask(System.Nullable{UnityEngine.InputSystem.InputBinding})"/>, or <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)"/>.
            
             To customize this process, you can supply a custom delegate via this method. If you do so, the default
             logic is bypassed and the step left entirely to the delegate. This also makes it possible to use
             rebind operations without even having an action or even <see cref="T:UnityEngine.InputSystem.InputBinding"/>s.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnMatchWaitForAnother(System.Single)">
             <summary>
             If a successful match has been found, wait for the given time for a better match to appear before
             committing to the match.
             </summary>
             <param name="seconds">Time in seconds to wait until committing to a match.</param>
             <returns>The same RebindingOperation instance.</returns>
             <remarks>
             While this adds a certain amount of lag to the operation, the lag is not really perceptible if the timeout
             is kept short.
            
             What this helps with is controls such as sticks where, when moved out of the deadzone, the initial direction
             that the user presses may not be the one actually intended. For example, the user may be pressing slightly
             more in the X direction before finally very clearly going more strongly in the Y direction. If the rebind
             does not wait for a bit but instead takes the first actuation as is, the rebind may appear overly brittle.
            
             An alternative to timeouts is to set higher magnitude thresholds with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithMagnitudeHavingToBeGreaterThan(System.Single)"/>.
             The default threshold is 0.2f. By setting it to 0.6f or even higher, timeouts may be unnecessary.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Start">
            <summary>
            Start the rebinding. This should be invoked after the rebind operation has been fully configured.
            </summary>
            <returns>The same RebindingOperation instance.</returns>
            <exception cref="T:System.InvalidOperationException">The rebind has been configure incorrectly. For example, no action has
            been given but no <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnApplyBinding(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation,System.String})"/> callback has been installed either.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Cancel"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Dispose"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Cancel">
            <summary>
            Cancel an ongoing rebind. This will invoke the callback supplied by <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnCancel(System.Action{UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation})"/> (if any).
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Start"/>
            <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.started"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Complete">
            <summary>
            Manually complete the rebinding operation.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.AddCandidate(UnityEngine.InputSystem.InputControl,System.Single,System.Single)">
            <summary>
            Add a candidate to <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>. This will also add values to <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/> and
            <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>. If the control has already been added, it's values are simply updated based
            on the given arguments.
            </summary>
            <param name="control">A control that is meant to be considered as a candidate for the rebind.</param>
            <param name="score">The score to associate with the control (see <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/>). By default, the control with the highest
            score will be picked by the rebind.</param>
            <param name="magnitude">Actuation level of the control to enter into <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.RemoveCandidate(UnityEngine.InputSystem.InputControl)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.RemoveCandidate(UnityEngine.InputSystem.InputControl)">
            <summary>
            Remove a control from the list of <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>. This also removes its entries from
            <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.scores"/> and <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.magnitudes"/>.
            </summary>
            <param name="control">Control to remove from <see cref="P:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.candidates"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.AddCandidate(UnityEngine.InputSystem.InputControl,System.Single,System.Single)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Dispose">
            <summary>
            Release all memory held by the option, especially unmanaged memory which will not otherwise
            be freed.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.Reset">
            <summary>
            Reset the configuration on the rebind.
            </summary>
            <returns>The same RebindingOperation instance.</returns>
            <remarks>
            Call this method to reset the effects of calling methods such as <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/>,
            <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithBindingGroup(System.String)"/>, etc. but retain other data that the rebind operation
            may have allocated already. If you are reusing the same <c>RebindingOperation</c>
            multiple times, a good strategy is to reset and reconfigure the operation before starting
            it again.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.GeneratePathForControl(UnityEngine.InputSystem.InputControl)">
            <summary>
            Based on the chosen control, generate an override path to rebind to.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.PerformInteractiveRebinding(UnityEngine.InputSystem.InputAction,System.Int32)">
             <summary>
             Initiate an operation that interactively rebinds the given action based on received input.
             </summary>
             <param name="action">Action to perform rebinding on.</param>
             <param name="bindingIndex">Optional index (within the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> array of <paramref name="action"/>)
             of binding to perform rebinding on. Must not be a composite binding.</param>
             <returns>A rebind operation configured to perform the rebind.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is not a valid index.</exception>
             <exception cref="T:System.InvalidOperationException">The binding at <paramref name="bindingIndex"/> is a composite binding.</exception>
             <remarks>
             This method will automatically perform a set of configuration on the <see cref="T:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation"/>
             based on the action and, if specified, binding. In particular, it will apply the following default
             configuration:
            
             <ul>
             <li><see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithAction(UnityEngine.InputSystem.InputAction)"/> will be called with <paramref name="action"/></li>
             <li>The default timeout will be set to 0.05f seconds with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.OnMatchWaitForAnother(System.Single)"/>.</li>
             <li>Pointer <see cref="P:UnityEngine.InputSystem.Pointer.delta"/> and <see cref="P:UnityEngine.InputSystem.Pointer.position"/> as well as touch <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.position"/>
             and <see cref="P:UnityEngine.InputSystem.Controls.TouchControl.delta"/> controls will be excluded with <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithControlsExcluding(System.String)"/>.
             This prevents mouse movement or touch leading to rebinds as it will generally be used to operate the UI.</li>
             <li><see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithMatchingEventsBeingSuppressed(System.Boolean)"/> will be invoked to suppress input funneled into rebinds
             from being picked up elsewhere.</li>
             <li>Except if the rebind is looking for a button, <see cref="P:UnityEngine.InputSystem.Keyboard.escapeKey"/> will be set up to cancel the rebind
             using <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithCancelingThrough(System.String)"/>.</li>
             <li>If <paramref name="bindingIndex"/> is given, <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.RebindingOperation.WithTargetBinding(System.Int32)"/> is invoked to
             target the given binding with the rebind.</li>
             </ul>
            
             Note that rebind operations must be disposed of once finished in order to not leak memory.
            
             <example>
             <code>
             // Target the first binding in the gamepad scheme.
             var bindingIndex = myAction.GetBindingIndex(InputBinding.MaskByGroup("Gamepad"));
             var rebind = myAction.PerformInteractiveRebinding(bindingIndex);
            
             // Dispose the operation on completion.
             rebind.OnComplete(
                operation =>
                {
                    Debug.Log($"Rebound '{myAction}' to '{operation.selectedControl}'");
                    operation.Dispose();
                };
            
             // Start the rebind. This will cause the rebind operation to start running in the
             // background listening for input.
             rebind.Start();
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.DeferBindingResolution">
            <summary>
            Temporarily suspend immediate re-resolution of bindings.
            </summary>
            <remarks>
            When changing control setups, it may take multiple steps to get to the final setup but each individual
            step may trigger bindings to be resolved again in order to update controls on actions (see <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>).
            Using this struct, this can be avoided and binding resolution can be deferred to after the whole operation
            is complete and the final binding setup is in place.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Return the current value of the given parameter as found on the processors, interactions, or composites
             of the action's current bindings.
             </summary>
             <param name="action">Action on whose bindings to look for the value of the given parameter.</param>
             <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
             parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
             type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
             parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
             <param name="bindingMask">Optional mask that determines on which bindings to look for objects with parameters. If used, only
             bindings that match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the given mask will be taken into account.</param>
             <returns>The current value of the given parameter or <c>null</c> if the parameter could not be found.</returns>
             <remarks>
             Parameters are found on interactions (<see cref="T:UnityEngine.InputSystem.IInputInteraction"/>), processors (<see cref="T:UnityEngine.InputSystem.InputProcessor"/>), and
             composites (see <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>) that are applied to bindings. For example, the following binding
             adds a <c>Hold</c> interaction with a custom <c>duration</c> parameter on top of binding to the gamepad's A button:
            
             <example>
             <code>
             new InputBinding
             {
                 path = "&lt;Gamepad&gt;/buttonSouth",
                 interactions = "hold(duration=0.6)"
             };
             </code>
             </example>
            
             In the editor UI, parameters are set graphically from the properties sections in the right-most pane
             in the action editor when an action or a binding is selected.
            
             When the binding above is applied to an action, the <c>duration</c> parameter from the <c>Hold</c> interaction can be
             queried like so:
            
             <example>
             <code>
             action.GetParameterValue("duration") // Returns 0.6
             </code>
             </example>
            
             Note that if there are multiple objects on the action that use the same parameter name, the value of the <em>first</em> parameter
             that is encountered is returned. Also note that this method will create GC heap garbage.
            
             The type of object to query the parameter from can be include in the <paramref name="name"/> parameter. For example, if
             an action has both a <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/> and a <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> on it, the
             <c>duration</c> parameter can be queried independently like so:
            
             <example>
             <code>
             // Query "duration" from "hold":
             action.GetParameterValue("hold:duration");
            
             // Query "duration" from "tap":
             action.GetParameterValue("tap:duration");
             </code>
             </example>
            
             The names used here to identify the object holding the parameter are the same used by <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>,
             <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterBindingComposite(System.Type,System.String)"/>, and <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor(System.Type,System.String)"/>.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c></exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyBindingOverride(UnityEngine.InputSystem.InputAction,System.String,System.String,System.String)"/>
             <seealso cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,System.Int32)">
            <summary>
            Return the current value of the given parameter as found on the processors, interactions, or composites
            of the action's current bindings.
            </summary>
            <param name="action">Action on whose bindings to look for the value of the given parameter.</param>
            <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
            parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
            type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
            parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
            <param name="bindingIndex">Index of the binding in <paramref name="action"/>'s <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
            to look for processors, interactions, and composites on.</param>
            <returns>The current value of the given parameter or <c>null</c> if the parameter not could be found.</returns>
            <remarks>
            This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
            to specifically target a single binding by index. Otherwise, the method is identical in functionality.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c></exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},UnityEngine.InputSystem.InputBinding)">
             <summary>
             Return the current value of the given parameter as found on the processors, interactions, or composites
             of the action's current bindings.
             </summary>
             <param name="action">Action on whose bindings to look for the value of the given parameter.</param>
             <param name="expr">An expression such as <c>(TapInteraction x) => x.duration</c> that determines the
             name and type of the parameter being looked for.</param>
             <param name="bindingMask">Optional mask that determines on which bindings to look for objects with parameters. If used, only
             bindings that match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the given mask will be taken into account.</param>
             <returns>The current value of the given parameter or <c>null</c> if the parameter not could be found.</returns>
             <remarks>
             This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
             that encapsulates a reference to the name of the parameter and the type of object it is found on in a way that is
             type-safe and does not involve strings.
            
             <example>
             <code>
             // Get the "duration" parameter from a TapInteraction.
             // This is equivalent to calling GetParameterValue("tap:duration")
             // but will return a float? instead of a PrimitiveValue?.
             action.GetParameterValue((TapInteraction x) => x.duration)
             </code>
             </example>
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="expr"/> is <c>null</c></exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>.
             </summary>
             <param name="action">An action on whose <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="expr">An expression such as <c>(TapInteraction x) => x.duration</c> that determines the
             name and type of the parameter whose value to set.</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">Optional mask that determines on which bindings to look for objects with parameters. If used, only
             bindings that match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the given mask will have the override applied to them.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="expr"/> is <c>null</c>
             or empty.</exception>
             <remarks>
             This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
             that encapsulates a reference to the name of the parameter and the type of object it is found on in a way that is
             type-safe and does not involve strings.
            
             <example>
             <code>
             // Override the "duration" parameter from a TapInteraction.
             // This is equivalent to calling ApplyParameterOverride("tap:duration", 0.4f).
             action.ApplyParameterOverride((TapInteraction x) => x.duration, 0.4f);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride``2(UnityEngine.InputSystem.InputActionMap,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>.
             </summary>
             <param name="actionMap">An action on whose <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="expr">An expression such as <c>(TapInteraction x) => x.duration</c> that determines the
             name and type of the parameter whose value to set.</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">Optional mask that determines on which bindings to look for objects with parameters. If used, only
             bindings that match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the given mask will have the override applied to them.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c> -or- <paramref name="expr"/> is <c>null</c>
             or empty.</exception>
             <remarks>
             This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
             that encapsulates a reference to the name of the parameter and the type of object it is found on in a way that is
             type-safe and does not involve strings.
            
             <example>
             <code>
             // Override the "duration" parameter from a TapInteraction.
             // This is equivalent to calling mApplyParameterOverride("tap:duration", 0.4f).
             actionMap.ApplyParameterOverride((TapInteraction x) => x.duration, 0.4f);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride``2(UnityEngine.InputSystem.InputActionAsset,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of the <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
             in <paramref name="asset"/>.
             </summary>
             <param name="asset">An asset on whose <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="expr">An expression such as <c>(TapInteraction x) => x.duration</c> that determines the
             name and type of the parameter whose value to set.</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">Optional mask that determines on which bindings to look for objects with parameters. If used, only
             bindings that match (see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>) the given mask will have the override applied to them.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> -or- <paramref name="expr"/> is <c>null</c>
             or empty.</exception>
             <remarks>
             This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionAsset,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
             that encapsulates a reference to the name of the parameter and the type of object it is found on in a way that is
             type-safe and does not involve strings.
            
             <example>
             <code>
             // Override the "duration" parameter from a TapInteraction.
             // This is equivalent to calling mApplyParameterOverride("tap:duration", 0.4f).
             asset.ApplyParameterOverride((TapInteraction x) => x.duration, 0.4f);
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue``2(UnityEngine.InputSystem.InputAction,System.Linq.Expressions.Expression{System.Func{``0,``1}},UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of <paramref name="actionMap"/>.
             </summary>
             <param name="actionMap">An action map on whose <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
             parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
             type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
             parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">A binding mask that determines which of <paramref name="actionMap"/>'s <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
             to apply the override to. By default this is empty which leads to the override to be applied to all bindings in the map.</param>
             <remarks>
             This method both directly applies the new value and also stores the override internally.
            
             If an override for the same parameter <paramref name="name"/> and with the same <paramref name="bindingMask"/> already exists,
             its value is simply updated. No new override will be created.
            
             You can use this method to set parameters (public fields) on composites, interactions, and processors that are created
             from bindings.
            
             <example>
             <code>
             // Create an action map with two actions.
             var map = new InputActionMap();
             var action1 = map.AddAction("action1");
             var action2 = map.AddAction("action2");
            
             // Add a binding to each action to which  a "ClampProcessor" is applied.
             // This processor has two parameters:
             // - "min" (float)
             // - "max" (float)
             action1.AddBinding("&gt;Gamepad&gt;/rightTrigger", processors: "clamp(min=0.2,max=0.8)");
             action2.AddBinding("&gt;Gamepad&gt;/leftTrigger", processors: "clamp(min=0.2,max=0.8)");
            
             // Apply parameter overrides to set the values differently.
             // This will apply the setting to *both* the bindings on action1 *and* action2.
             map.ApplyParameterOverride("min", 0.3f);
             map.ApplyParameterOverride("max", 0.9f);
             </code>
             </example>
            
             An override can optionally be directed at a specific type of object.
            
             <example>
             <code>
             map.ApplyParameterOverride("clamp:min", 0.3f);
             map.ApplyParameterOverride("clamp:max", 0.9f);
             </code>
             </example>
            
             By default, the parameter override will apply to all bindings in the map. To limit the override
             to specific bindings, you can supply a <paramref name="bindingMask"/>.
            
             <example>
             <code>
             // Apply a parameter override only to action1.
             map.ApplyBindingOverride("clamp:min", 0.25f, new InputBinding { action = action1.name });
            
             // Apply a parameter override only to a specific binding path.
             map.ApplyBindingOverride("clamp:min", 0.4f, new InputBinding { path = "&lt;Gamepad&gt;/leftTrigger" });
             </code>
             </example>
            
             If multiple overrides exist for the same parameter, an attempt is made to choose the override that is most specific.
             Say, that you apply an override for <c>"duration"</c> on an entire <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> using
             <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionAsset,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>. But then you also apply
             an override to just an individual <see cref="T:UnityEngine.InputSystem.InputAction"/> inside the asset. In this case, the <c>"duration"</c>
             override for just that action will be applied to bindings of that action and the override inside the asset will
             be applied to bindings of all other actions. Note that if multiple overrides exist that could all be considered
             equally valid, the behavior is undecided.
            
             Note that parameter overrides stay in place on the map. Like binding overrides, however, they are not
             automatically persisted and thus need to be reapplied when actions are loaded from assets. This will, however, be applied
             automatically to bindings added to the action in the future as well as whenever bindings are resolved to controls.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="actionMap"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c>
             or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionAsset,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> of each of the <see cref="P:UnityEngine.InputSystem.InputActionAsset.actionMaps"/>
             in <paramref name="asset"/>.
             </summary>
             <param name="asset">An <c>.inputactions</c> asset on whose <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
             parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
             type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
             parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">A binding mask that determines which of the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
             to apply the override to. By default this is empty which leads to the override to be applied to all bindings in the asset.</param>
             <remarks>
             This method both directly applies the new value and also stores the override internally.
            
             If an override for the same parameter <paramref name="name"/> and with the same <paramref name="bindingMask"/> already exists,
             its value is simply updated. No new override will be created.
            
             You can use this method to set parameters (public fields) on composites, interactions, and processors that are created
             from bindings.
            
             <example>
             <code>
             // Create an asset with one action map and two actions.
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
             var map = asset.AddActionMap("map");
             var action1 = map.AddAction("action1");
             var action2 = map.AddAction("action2");
            
             // Add a binding to each action to which  a "ClampProcessor" is applied.
             // This processor has two parameters:
             // - "min" (float)
             // - "max" (float)
             action1.AddBinding("&gt;Gamepad&gt;/rightTrigger", processors: "clamp(min=0.2,max=0.8)");
             action2.AddBinding("&gt;Gamepad&gt;/leftTrigger", processors: "clamp(min=0.2,max=0.8)");
            
             // Apply parameter overrides to set the values differently.
             // This will apply the setting to *both* the bindings on action1 *and* action2.
             asset.ApplyParameterOverride("min", 0.3f);
             asset.ApplyParameterOverride("max", 0.9f);
             </code>
             </example>
            
             An override can optionally be directed at a specific type of object.
            
             <example>
             <code>
             asset.ApplyParameterOverride("clamp:min", 0.3f);
             asset.ApplyParameterOverride("clamp:max", 0.9f);
             </code>
             </example>
            
             By default, the parameter override will apply to all bindings in the asset. To limit the override
             to specific bindings, you can supply a <paramref name="bindingMask"/>.
            
             <example>
             <code>
             // Apply a parameter override only to action1.
             asset.ApplyBindingOverride("clamp:min", 0.25f, new InputBinding { action = action1.name });
            
             // Apply a parameter override only to a specific binding path.
             asset.ApplyBindingOverride("clamp:min", 0.4f, new InputBinding { path = "&lt;Gamepad&gt;/leftTrigger" });
             </code>
             </example>
            
             If multiple overrides exist for the same parameter, an attempt is made to choose the override that is most specific.
             Say, that you apply an override for <c>"duration"</c> on an entire <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> using
             <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionAsset,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>. But then you also apply
             an override to just an individual <see cref="T:UnityEngine.InputSystem.InputAction"/> inside the asset. In this case, the <c>"duration"</c>
             override for just that action will be applied to bindings of that action and the override inside the asset will
             be applied to bindings of all other actions. Note that if multiple overrides exist that could all be considered
             equally valid, the behavior is undecided.
            
             Note that parameter overrides stay in place on the map. Like binding overrides, however, they are not
             automatically persisted and thus need to be reapplied when actions are loaded from assets. This will, however, be applied
             automatically to bindings added to the action in the future as well as whenever bindings are resolved to controls.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="asset"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c>
             or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)">
             <summary>
             Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
             and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>.
             </summary>
             <param name="action">An action on whose <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> to look for objects to set
             the parameter value on.</param>
             <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
             parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
             type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
             parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
             <param name="value">New value to assign to the parameter.</param>
             <param name="bindingMask">A binding mask that determines which of <paramref name="action"/>'s <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             to apply the override to. By default this is empty which leads to the override to be applied to all bindings of the action.</param>
             <remarks>
             This method both directly applies the new value and also stores the override internally.
            
             If an override for the same parameter <paramref name="name"/> on the same <paramref name="action"/> and with the same
             <paramref name="bindingMask"/> already exists, its value is simply updated. No new override will be created.
            
             You can use this method to set parameters (public fields) on composites, interactions, and processors that are created
             from bindings.
            
             <example>
             <code>
             // Create an action with a binding that has a "ClampProcessor" applied to it.
             // This processor has two parameters:
             // - "min" (float)
             // - "max" (float)
             var action = new InputAction(binding: "&gt;Gamepad&gt;/rightTrigger", processors: "clamp(min=0.2,max=0.8)");
            
             // Apply parameter overrides to set the values differently.
             action.ApplyParameterOverride("min", 0.3f);
             action.ApplyParameterOverride("max", 0.9f);
             </code>
             </example>
            
             An override can optionally be directed at a specific type of object.
            
             <example>
             <code>
             // Create an action with both a "tap" and a "hold" interaction. Both have a
             // "duration" parameter.
             var action = new InputAction(binding: "&lt;Gamepad&gt;/buttonSouth", interactions: "tap;hold");
            
             // Apply parameter overrides individually to the two.
             action.ApplyParameterOverride("tap:duration", 0.6f);
             action.ApplyParameterOverride("hold:duration", 4f);
             </code>
             </example>
            
             By default, the parameter override will apply to all bindings on the action. To limit the override
             to specific bindings, you can supply a <paramref name="bindingMask"/>.
            
             <example>
             <code>
             // Create a "look" style action with a mouse and a gamepad binding.
             var lookAction = new InputAction();
             lookAction.AddBinding("&lt;Mouse&gt;/delta", processors: "scaleVector2", groups: "Mouse");
             lookAction.AddBinding("&lt;Gamepad&gt;/rightStick", processors: "scaleVector2", groups: "Gamepad");
            
             // Override scaling of the mouse delta individually.
             lookAction.ApplyBindingOverride("scaleVector2:x", 0.25f, InputBinding.MaskByGroup("Mouse"));
             lookAction.ApplyBindingOverride("scaleVector2:y", 0.25f, InputBinding.MaskByGroup("Mouse"));
            
             // Can also do that by path.
             lookAction.ApplyBindingOverride("scaleVector2:x", 0.25f, new InputBinding("&lt;Mouse&gt;/delta"));
             lookAction.ApplyBindingOverride("scaleVector2:y", 0.25f, new InputBinding("&lt;Mouse&gt;/delta"));
             </code>
             </example>
            
             Note that parameter overrides stay in place on the action. Like binding overrides, however, they are not
             automatically persisted and thus need to be reapplied when actions are loaded from assets. This will, however, be applied
             automatically to bindings added to the action in the future as well as whenever bindings for the action are resolved.
             </remarks>
             <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c>
             or empty.</exception>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,System.Int32)">
            <summary>
            Set the value of the given parameter on the <see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>, <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>,
            and <see cref="T:UnityEngine.InputSystem.InputProcessor"/> objects found on the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>.
            </summary>
            <param name="action">An action on whose <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> to look for objects to set
            the parameter value on.</param>
            <param name="name">Name of the parameter to get the value of. Case-insensitive. This can either be just the name of the
            parameter (like <c>"duration"</c> or expressed as <c>nameof(TapInteraction.duration)</c>) or can be prefixed with the
            type of object to get the parameter value from. For example, <c>"tap:duration"</c> will specifically get the <c>"duration"</c>
            parameter from the object registered as <c>"tap"</c> (which will usually be <see cref="T:UnityEngine.InputSystem.Interactions.TapInteraction"/>).</param>
            <param name="value">New value to assign to the parameter.</param>
            <param name="bindingIndex">Index of the binding in <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/> to which
            to restrict the parameter override to.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bindingIndex"/> is negative or equal or greater than the number of
            <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <c>null</c> -or- <paramref name="name"/> is <c>null</c>
            or empty.</exception>
            <remarks>
            This method is a variation of <see cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/> which
            allows specifying a binding by index. It otherwise behaves identically to that method.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.IInputInteraction">
             <summary>
             Interface for interaction patterns that drive actions.
             </summary>
             <remarks>
             Actions have a built-in interaction pattern that to some extent depends on their type (<see
             cref="T:UnityEngine.InputSystem.InputActionType"/>, <see cref="P:UnityEngine.InputSystem.InputAction.type"/>). What this means is that when controls
             bound to an action are actuated, the action will initiate an interaction that in turn determines
             when <see cref="E:UnityEngine.InputSystem.InputAction.started"/>, <see cref="E:UnityEngine.InputSystem.InputAction.performed"/>, and <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
             are called.
            
             The default interaction (that is, when no interaction has been added to a binding or the
             action that the binding targets) will generally start and perform an action as soon as a control
             is actuated, then perform the action whenever the value of the control changes except if the value
             changes back to the default in which case the action is cancelled.
            
             By writing custom interactions, it is possible to implement different interactions. For example,
             <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> will only start when a control is being actuated but
             will only perform the action if the control is held for a minimum amount of time.
            
             Interactions can be stateful and mutate state over time. In fact, interactions will usually
             represent miniature state machines driven directly by input.
            
             Multiple interactions can be applied to the same binding. The interactions will be processed in
             sequence. However, the first interaction that starts the action will get to drive the state of
             the action. If it performs the action, all interactions are reset. If it cancels, the first
             interaction in the list that is in started state will get to take over and drive the action.
            
             This makes it possible to have several interaction patterns on the same action. For example,
             to have a "fire" action that allows for charging, one can have a "Hold" and a "Press" interaction
             in sequence on the action.
            
             <example>
             <code>
             // Create a fire action with two interactions:
             // 1. Hold. Triggers charged firing. Has to come first as otherwise "Press" will immediately perform the action.
             // 2. Press. Triggers instant firing.
             // NOTE: An alternative is to use "Tap;Hold", that is, a "Tap" first and then a "Hold". The difference
             //       is relatively minor. In this setup, the "Tap" turns into a "Hold" if the button is held for
             //       longer than the tap time whereas in the setup below, the "Hold" turns into a "Press" if the
             //       button is released before the hold time has been reached.
             var fireAction = new InputAction(type: InputActionType.Button, interactions: "Hold;Press");
             fireAction.AddBinding("&lt;Gamepad&gt;/buttonSouth");
             </code>
             </example>
            
             Custom interactions can be registered using <see cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>. This can be
             done at any point during or after startup but has to be done before actions that reference the interaction
             are enabled or have their controls queried. A good point is usually to do it during loading like so:
            
             <example>
             <code>
             #if UNITY_EDITOR
             [InitializeOnLoad]
             #endif
             public class MyInteraction : IInputInteraction
             {
                 public void Process(ref InputInteractionContext context)
                 {
                     // ...
                 }
            
                 public void Reset()
                 {
                 }
            
                 static MyInteraction()
                 {
                     InputSystem.RegisterInteraction&lt;MyInteraction&gt;();
                 }
            
                 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
                 private static void Initialize()
                 {
                     // Will execute the static constructor as a side effect.
                 }
             }
             </code>
             </example>
            
             If your interaction will only work with a specific type of value (e.g. <c>float</c>), it is better
             to base the implementation on <see cref="T:UnityEngine.InputSystem.IInputInteraction`1"/> instead. While the interface is the
             same, the type parameter communicates to the input system that only controls that have compatible value
             types should be used with your interaction.
            
             Interactions, like processors (<see cref="T:UnityEngine.InputSystem.InputProcessor"/>) and binding composites (<see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>)
             may define their own parameters which can then be configured through the editor UI or set programmatically in
             code. To define a parameter, add a public field to your class that has either a <c>bool</c>, an <c>int</c>,
             a <c>float</c>, or an <c>enum</c> type. To set defaults for the parameters, assign default values
             to the fields.
            
             <example>
             <code>
             public class MyInteraction : IInputInteraction
             {
                 public bool boolParameter;
                 public int intParameter;
                 public float floatParameter;
                 public MyEnum enumParameter = MyEnum.C; // Custom default.
            
                 public enum MyEnum
                 {
                     A,
                     B,
                     C
                 }
            
                 public void Process(ref InputInteractionContext context)
                 {
                     // ...
                 }
            
                 public void Reset()
                 {
                 }
             }
            
             // The parameters can be configured graphically in the editor or set programmatically in code.
             // NOTE: Enum parameters are represented by their integer values. However, when setting enum parameters
             //       graphically in the UI, they will be presented as a dropdown using the available enum values.
             var action = new InputAction(interactions: "MyInteraction(boolParameter=true,intParameter=1,floatParameter=1.2,enumParameter=1);
             </code>
             </example>
            
             A default UI will be presented in the editor UI to configure the parameters of your interaction.
             You can customize this by replacing the default UI with a custom implementation using <see cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor"/>.
             This mechanism is the same as for processors and binding composites.
            
             <example>
             <code>
             #if UNITY_EDITOR
             public class MyCustomInteractionEditor : InputParameterEditor&lt;MyCustomInteraction&gt;
             {
                 protected override void OnEnable()
                 {
                     // Do any setup work you need.
                 }
            
                 protected override void OnGUI()
                 {
                     // Use standard Unity UI calls do create your own parameter editor UI.
                 }
             }
             #endif
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterInteraction(System.Type,System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.interactions"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.interactions"/>
             <seealso cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputInteraction.Process(UnityEngine.InputSystem.InputInteractionContext@)">
             <summary>
             Perform processing of the interaction in response to input.
             </summary>
             <param name="context"></param>
             <remarks>
             This method is called whenever a control referenced in the binding that the interaction sits on
             changes value. The interaction is expected to process the value change and, if applicable, call
             <see cref="M:UnityEngine.InputSystem.InputInteractionContext.Started"/> and/or its related methods to initiate a state change.
            
             Note that if "control disambiguation" (i.e. the process where if multiple controls are bound to
             the same action, the system decides which control gets to drive the action at any one point) is
             in effect -- i.e. when either <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> or <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
             are used but not if <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> is used -- inputs that the disambiguation
             chooses to ignore will cause this method to not be called.
            
             Note that this method is called on the interaction even when there are multiple interactions
             and the interaction is not the one currently in control of the action (because another interaction
             that comes before it in the list had already started the action). Each interaction will get
             processed independently and the action will decide when to use which interaction to drive the
             action as a whole.
            
             <example>
             <code>
                 // Processing for an interaction that will perform the action only if a control
                 // is held at least at 3/4 actuation for at least 1 second.
                 public void Process(ref InputInteractionContext context)
                 {
                     var control = context.control;
            
                     // See if we're currently tracking a control.
                     if (m_Control != null)
                     {
                         // Ignore any input on a control we're not currently tracking.
                         if (m_Control != control)
                             return;
            
                         // Check if the control is currently actuated past our 3/4 threshold.
                         var isStillActuated = context.ControlIsActuated(0.75f);
            
                         // See for how long the control has been held.
                         var actuationTime = context.time - context.startTime;
            
                         if (!isStillActuated)
                         {
                             // Control is no longer actuated above 3/4 threshold. If it was held
                             // for at least a second, perform the action. Otherwise cancel it.
            
                             if (actuationTime >= 1)
                                 context.Performed();
                             else
                                 context.Cancelled();
                         }
            
                         // Control changed value somewhere above 3/4 of its actuation. Doesn't
                         // matter to us so no change.
                     }
                     else
                     {
                         // We're not already tracking a control. See if the control that just triggered
                         // is actuated at least 3/4th of its way. If so, start tracking it.
            
                         var isActuated = context.ControlIsActuated(0.75f);
                         if (isActuated)
                         {
                             m_Control = context.control;
                             context.Started();
                         }
                     }
                 }
            
                 InputControl m_Control;
            
                 public void Reset()
                 {
                     m_Control = null;
                 }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.IInputInteraction.Reset">
            <summary>
            Reset state that the interaction may hold. This should put the interaction back in its original
            state equivalent to no input yet having been received.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.IInputInteraction`1">
             <summary>
             Identical to <see cref="T:UnityEngine.InputSystem.IInputInteraction"/> except that it allows an interaction to explicitly
             advertise the value it expects.
             </summary>
             <typeparam name="TValue">Type of values expected by the interaction</typeparam>
             <remarks>
             Advertising the value type will an interaction type to be filtered out in the UI if the value type
             it has is not compatible with the value type expected by the action.
            
             In all other ways, this interface is identical to <see cref="T:UnityEngine.InputSystem.IInputInteraction"/>.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Haptics.DualMotorRumble">
            <summary>
            Common implementation of dual motor rumbling.
            </summary>
            <remarks>
            This struct is meant for use in devices that implement <see cref="T:UnityEngine.InputSystem.Haptics.IDualMotorRumble"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed">
            <summary>
            Normalized [0..1] speed of the low-frequency (usually left) motor.
            </summary>
            <value>Speed of left motor.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed">
            <summary>
            Normalized [0..1] speed of the high-frequency (usually right) motor.
            </summary>
            <value>Speed of right motor.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.isRumbling">
            <summary>
            Whether either of the motors is currently set to non-zero speeds.
            </summary>
            <value>True if the motors are currently turned on.</value>
            <remarks>
            Does not take pausing into account, i.e. <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed"/> and/or
            <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed"/> may be non-zero but haptics on the device
            may actually be paused with <see cref="M:UnityEngine.InputSystem.Haptics.DualMotorRumble.PauseHaptics(UnityEngine.InputSystem.InputDevice)"/>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.DualMotorRumble.PauseHaptics(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Reset motor speeds to zero but retain current values for <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed"/>
            and <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed"/>.
            </summary>
            <param name="device">Device to send command to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.DualMotorRumble.ResumeHaptics(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Resume haptics by setting motor speeds to the current values of <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed"/>
            and <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed"/>.
            </summary>
            <param name="device">Device to send command to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.DualMotorRumble.ResetHaptics(UnityEngine.InputSystem.InputDevice)">
            <summary>
            Reset haptics by setting both <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed"/> and <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed"/>
            to zero.
            </summary>
            <param name="device">Device to send command to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.DualMotorRumble.SetMotorSpeeds(UnityEngine.InputSystem.InputDevice,System.Single,System.Single)">
            <summary>
            Set the speed of the low-frequency (usually left) and high-frequency (usually right) motor
            on <paramref name="device"/>. Updates <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.lowFrequencyMotorSpeed"/> and
            <see cref="P:UnityEngine.InputSystem.Haptics.DualMotorRumble.highFrequencyMotorSpeed"/>.
            </summary>
            <param name="device">Device to send command to.</param>
            <param name="lowFrequency">Speed of the low-frequency (left) motor. Normalized [0..1] value
            with 1 indicating maximum speed and 0 indicating the motor is turned off. Will automatically
            be clamped into range.</param>
            <param name="highFrequency">Speed of the high-frequency (right) motor. Normalized [0..1] value
            with 1 indicating maximum speed and 0 indicating the motor is turned off. Will automatically
            be clamped into range.</param>
            <remarks>
            Sends <see cref="T:UnityEngine.InputSystem.LowLevel.DualMotorRumbleCommand"/> to <paramref name="device"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is null.</exception>
        </member>
        <member name="T:UnityEngine.InputSystem.Haptics.IDualMotorRumble">
            <summary>
            A simple haptics interface that allows to control two motors individually.
            </summary>
            <remarks>
            Dual-motor control is most common on gamepads (see <see cref="T:UnityEngine.InputSystem.Gamepad"/>) such as
            Xbox and PlayStation controllers.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.IDualMotorRumble.SetMotorSpeeds(System.Single,System.Single)">
            <summary>
            Set the motor speeds of the low-frequency (usually on the left) and high-frequency
            (usually on the right) motors.
            </summary>
            <param name="lowFrequency">Speed of the low-frequency (left) motor. Normalized [0..1] value
            with 1 indicating maximum speed and 0 indicating the motor is turned off. Will automatically
            be clamped into range.</param>
            <param name="highFrequency">Speed of the high-frequency (right) motor. Normalized [0..1] value
            with 1 indicating maximum speed and 0 indicating the motor is turned off. Will automatically
            be clamped into range.</param>
            <remarks>
            Note that hardware will put limits on the level of control you have over the motors.
            Rumbling the motors at maximum speed for an extended period of time may cause them to turn
            off for some time to prevent overheating. Also, how quickly the motors react and how often
            the speed can be updated will depend on the hardware and drivers.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.Haptics.IHaptics">
             <summary>
             Base interface for haptics on input devices.
             </summary>
             <remarks>
             To support haptics, an <see cref="T:UnityEngine.InputSystem.InputDevice"/> has to implement one or more
             haptics interfaces.
             </remarks>
             <example>
             <code>
             class MyDevice : InputDevice, IDualMotorRumble
             {
                 private DualMotorRumble m_Rumble;
            
                 public void SetMotorSpeeds(float lowFrequency, float highFrequency)
                 {
                     m_Rumble.SetMotorSpeeds(lowFrequency, highFrequency);
                 }
            
                 public void PauseHaptics()
                 {
                     m_Rumble.PauseHaptics();
                 }
            
                 public void ResumeHaptics()
                 {
                     m_Rumble.ResumeHaptics();
                 }
            
                 public void ResetHaptics()
                 {
                     m_Rumble.ResetHaptics();
                 }
             }
             </code>
             </example>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.PauseHaptics"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResumeHaptics"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.ResetHaptics"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.IHaptics.PauseHaptics">
             <summary>
             Pause haptics playback on the device.
             </summary>
             <remarks>
             This should preserve current playback settings (such as motor speed levels
             or effect playback positions) but shut down feedback effects on the device.
            
             If proper resumption of effects is not possible, playback should be stopped
             and <see cref="M:UnityEngine.InputSystem.Haptics.IHaptics.ResumeHaptics"/> is allowed to be a no-operation.
            
             Note that haptics playback states are not required to survive domain reloads
             in the editor.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.Haptics.IHaptics.ResumeHaptics"/>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.IHaptics.ResumeHaptics">
            <summary>
            Resume haptics playback on the device.
            </summary>
            <remarks>
            Should be called after calling <see cref="M:UnityEngine.InputSystem.Haptics.IHaptics.PauseHaptics"/>. Otherwise does
            nothing.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.Haptics.IHaptics.ResetHaptics">
            <summary>
            Reset haptics playback on the device to its default state.
            </summary>
            <remarks>
            This will turn off all haptics effects that may be playing on the device.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionMap">
             <summary>
             A mechanism for collecting a series of input actions (see <see cref="T:UnityEngine.InputSystem.InputAction"/>)
             and treating them as a group.
             </summary>
             <remarks>
             Each action map is a named collection of bindings and actions. Both are stored
             as a flat list. The bindings are available through the <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
             property and the actions are available through the <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> property.
            
             The actions in a map are owned by the map. No action can appear in two maps
             at the same time. To find the action map an action belongs to, use the
             <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/> property. Note that actions can also stand
             on their own and thus do not necessarily need to belong to a map (in which case
             the <see cref="P:UnityEngine.InputSystem.InputAction.actionMap"/> property is <c>null</c>).
            
             Within a map, all actions have to have names and each action name must
             be unique. The <see cref="P:UnityEngine.InputSystem.InputBinding.action"/> property of bindings in a map
             are resolved within the <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> in the map. Looking up actions
             by name can be done through <see cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)"/>.
            
             The <see cref="P:UnityEngine.InputSystem.InputActionMap.name"/> of the map itself can be empty, except if the map is part of
             an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> in which case it is required to have a name
             which also must be unique within the asset.
            
             Action maps are most useful for grouping actions that contextually
             belong together. For example, one common usage is to separate the actions
             that can be performed in the UI or in the main menu from those that can
             be performed during gameplay. However, even within gameplay, multiple action
             maps can be employed. For example, one could have different action maps for
             driving and for walking plus one more map for the actions shared between
             the two modes.
            
             Action maps are usually created in the <a href="../manual/ActionAssets.html">action
             editor</a> as part of <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>s. However, they can also be
             created standing on their own directly in code or from JSON (see <see cref="M:UnityEngine.InputSystem.InputActionMap.FromJson(System.String)"/>).
            
             <example>
             <code>
             // Create a free-standing action map.
             var map = new InputActionMap();
            
             // Add some actions and bindings to it.
             map.AddAction("action1", binding: "&lt;Keyboard&gt;/space");
             map.AddAction("action2", binding: "&lt;Gamepad&gt;/buttonSouth");
             </code>
             </example>
            
             Actions in action maps, like actions existing by themselves outside of action
             maps, do not actively process input except if enabled. Actions can either
             be enabled individually (see <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/> and <see
             cref="M:UnityEngine.InputSystem.InputAction.Disable"/>) or in bulk by enabling and disabling the
             entire map (see <see cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/> and <see cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/>).
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputActionAsset"/>
             <seealso cref="T:UnityEngine.InputSystem.InputAction"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.name">
            <summary>
            Name of the action map.
            </summary>
            <value>Name of the action map.</value>
            <remarks>
            For action maps that are part of <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>s, this will always be
            a non-null, non-empty string that is unique within the maps in the asset. For action maps
            that are standing on their own, this can be null or empty.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.asset">
            <summary>
            If the action map is part of an asset, this refers to the asset. Otherwise it is <c>null</c>.
            </summary>
            <value>Asset to which the action map belongs.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.id">
            <summary>
            A stable, unique identifier for the map.
            </summary>
            <value>Unique ID for the action map.</value>
            <remarks>
            This can be used instead of the name to refer to the action map. Doing so allows referring to the
            map such that renaming it does not break references.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.id"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.enabled">
            <summary>
            Whether any action in the map is currently enabled.
            </summary>
            <value>True if any action in <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> is currently enabled.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputAction.enabled"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>
            <seealso cref="M:UnityEngine.InputSystem.InputAction.Enable"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.actions">
             <summary>
             List of actions contained in the map.
             </summary>
             <value>Collection of actions belonging to the map.</value>
             <remarks>
             Actions are owned by their map. The same action cannot appear in multiple maps.
            
             Accessing this property. Note that values returned by the property become invalid if
             the setup of actions in a map is changed.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.actionMap"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.bindings">
             <summary>
             List of bindings contained in the map.
             </summary>
             <value>Collection of bindings in the map.</value>
             <remarks>
             <see cref="T:UnityEngine.InputSystem.InputBinding"/>s are owned by action maps and not by individual actions.
            
             Bindings that trigger actions refer to the action by <see cref="P:UnityEngine.InputSystem.InputAction.name"/>
             or <see cref="P:UnityEngine.InputSystem.InputAction.id"/>.
            
             Accessing this property does not allocate. Note that values returned by the property
             become invalid if the setup of bindings in a map is changed.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.controlSchemes">
            <summary>
            Control schemes defined for the action map.
            </summary>
            <value>List of available control schemes.</value>
            <remarks>
            Control schemes can only be defined at the level of <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>s.
            For action maps that are part of assets, this property will return the control schemes
            from the asset. For free-standing action maps, this will return an empty list.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.bindingMask">
             <summary>
             Binding mask to apply to all actions in the asset.
             </summary>
             <value>Optional mask that determines which bindings in the action map to enable.</value>
             <remarks>
             Binding masks can be applied at three different levels: for an entire asset through
             <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>, for a specific map through this property,
             and for single actions through <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>. By default,
             none of the masks will be set (that is, they will be <c>null</c>).
            
             When an action is enabled, all the binding masks that apply to it are taken into
             account. Specifically, this means that any given binding on the action will be
             enabled only if it matches the mask applied to the asset, the mask applied
             to the map that contains the action, and the mask applied to the action itself.
             All the masks are individually optional.
            
             Masks are matched against bindings using <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.
            
             Note that if you modify the masks applicable to an action while it is
             enabled, the action's <see cref="P:UnityEngine.InputSystem.InputAction.controls"/> will get updated immediately to
             respect the mask. To avoid repeated binding resolution, it is most efficient
             to apply binding masks before enabling actions.
            
             Binding masks are non-destructive. All the bindings on the action are left
             in place. Setting a mask will not affect the value of the <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             and <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> properties.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.MaskByGroup(System.String)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.devices">
             <summary>
             Set of devices that bindings in the action map can bind to.
             </summary>
             <value>Optional set of devices to use by bindings in the map.</value>
             <remarks>
             By default (with this property being <c>null</c>), bindings will bind to any of the
             controls available through <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>, that is, controls from all
             devices in the system will be used.
            
             By setting this property, binding resolution can instead be restricted to just specific
             devices. This restriction can either be applied to an entire asset using <see
             cref="P:UnityEngine.InputSystem.InputActionMap.devices"/> or to specific action maps by using this property. Note that
             if both this property and <see cref="P:UnityEngine.InputSystem.InputActionAsset.devices"/> is set for a specific action
             map, the list of devices on the action map will take precedence and the list on the
             asset will be ignored for bindings in that action map.
            
             <example>
             <code>
             // Create an action map containing a single action with a gamepad binding.
             var actionMap = new InputActionMap();
             var fireAction = actionMap.AddAction("Fire", binding: "&lt;Gamepad&gt;/buttonSouth");
             asset.AddActionMap(actionMap);
            
             // Let's assume we have two gamepads connected. If we enable the
             // action map now, the 'Fire' action will bind to both.
             actionMap.Enable();
            
             // This will print two controls.
             Debug.Log(string.Join("\n", fireAction.controls));
            
             // To restrict the setup to just the first gamepad, we can assign
             // to the 'devices' property.
             actionMap.devices = new InputDevice[] { Gamepad.all[0] };
            
             // Now this will print only one control.
             Debug.Log(string.Join("\n", fireAction.controls));
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.devices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputActionMap.Item(System.String)">
            <summary>
            Look up an action by name or ID.
            </summary>
            <param name="actionNameOrId">Name (as in <see cref="P:UnityEngine.InputSystem.InputAction.name"/>) or ID (as in <see cref="P:UnityEngine.InputSystem.InputAction.id"/>)
            of the action. Note that matching of names is case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionNameOrId"/> is <c>null</c>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No action with the name or ID of <paramref name="actionNameOrId"/>
            was found in the action map.</exception>
            <remarks>
            This method is equivalent to <see cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)"/> except it throws <c>KeyNotFoundException</c>
            if no action with the given name or ID can be found.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.Guid)"/>
            <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/>
        </member>
        <member name="E:UnityEngine.InputSystem.InputActionMap.actionTriggered">
            <summary>
            Add or remove a callback that is triggered when an action in the map changes its <see cref="T:UnityEngine.InputSystem.InputActionPhase">
            phase</see>.
            </summary>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.started"/>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.performed"/>
            <seealso cref="E:UnityEngine.InputSystem.InputAction.canceled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.#ctor">
            <summary>
            Construct an action map with default values.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.#ctor(System.String)">
            <summary>
            Construct an action map with the given name.
            </summary>
            <param name="name">Name to give to the action map. By default <c>null</c>, i.e. does
            not assign a name to the map.</param>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.Dispose">
             <summary>
             Release internal state held on to by the action map.
             </summary>
             <remarks>
             Once actions in a map are enabled, the map will allocate a block of state internally that
             it will hold on to until disposed of. All actions in the map will share the same internal
             state. Also, if the map is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> all maps and actions
             in the same asset will share the same internal state.
            
             Note that the internal state holds on to GC heap memory as well as memory from the
             unmanaged, C++ heap.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)">
            <summary>
            Find an action in the map by name or ID.
            </summary>
            <param name="actionNameOrId">Name (as in <see cref="P:UnityEngine.InputSystem.InputAction.name"/>) or ID (as in <see cref="P:UnityEngine.InputSystem.InputAction.id"/>)
            of the action. Note that matching of names is case-insensitive.</param>
            <param name="throwIfNotFound">If set to <see langword="true"/> will cause an exception to be thrown when the action was not found.</param>
            <returns>The action with the given name or ID or <c>null</c> if no matching action
            was found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionNameOrId"/> is <c>null</c>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.Guid)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.Guid)">
            <summary>
            Find an action by ID.
            </summary>
            <param name="id">ID (as in <see cref="P:UnityEngine.InputSystem.InputAction.id"/>) of the action.</param>
            <returns>The action with the given ID or null if no action in the map has
            the given ID.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FindAction(System.String,System.Boolean)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.IsUsableWithDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Check whether there are any bindings in the action map that can bind to
             controls on the given device.
             </summary>
             <param name="device">An input device.</param>
             <returns>True if any of the bindings in the map can resolve to controls on the device, false otherwise.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <remarks>
             The logic is entirely based on the contents of <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> and, more specifically,
             <see cref="P:UnityEngine.InputSystem.InputBinding.effectivePath"/> of each binding. Each path is checked using <see
             cref="M:UnityEngine.InputSystem.InputControlPath.Matches(System.String,UnityEngine.InputSystem.InputControl)"/>. If any path matches, the method returns <c>true</c>.
            
             Properties such as <see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/> and <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/> are ignored.
            
             <example>
             <code>
             // Create action map with two actions and bindings.
             var actionMap = new InputActionMap();
             actionMap.AddAction("action1", binding: "&lt;Gamepad&gt;/buttonSouth");
             actionMap.AddAction("action2", binding: "&lt;XRController{LeftHand}&gt;/{PrimaryAction}");
            
             //
             var gamepad = InputSystem.AddDevice&lt;Gamepad&gt;();
             var xrController = InputSystem.AddDevice&lt;XRController&gt;();
            
             // Returns true:
             actionMap.IsUsableWith(gamepad);
            
             // Returns false: (the XRController does not have the LeftHand usage assigned to it)
             actionMap.IsUsableWith(xrController);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.Enable">
            <summary>
            Enable all the actions in the map.
            </summary>
            <remarks>
            This is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputAction.Enable"/> on each
            action in <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/>, but is more efficient as the actions
            will get enabled in bulk.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Disable"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.Disable">
            <summary>
            Disable all the actions in the map.
            </summary>
            <remarks>
            This is equivalent to calling <see cref="M:UnityEngine.InputSystem.InputAction.Disable"/> on each
            action in <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/>, but is more efficient as the actions
            will get disabled in bulk.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Enable"/>
            <seealso cref="P:UnityEngine.InputSystem.InputActionMap.enabled"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.Clone">
             <summary>
             Produce an identical copy of the action map with its actions and bindings.
             </summary>
             <returns>A copy of the action map.</returns>
             <remarks>
             If the action map is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>, the clone will <em>not</em>
             be. It will be a free-standing action map and <see cref="P:UnityEngine.InputSystem.InputActionMap.asset"/> will be <c>null</c>.
            
             Note that the IDs for the map itself as well as for its <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> and
             <see cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/> are not copied. Instead, new IDs will be assigned. Also, callbacks
             installed on actions or on the map itself will not be copied over.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.System#ICloneable#Clone">
            <summary>
            Return an boxed instance of the action map.
            </summary>
            <returns>An boxed clone of the action map</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.Clone"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.Contains(UnityEngine.InputSystem.InputAction)">
            <summary>
            Return <c>true</c> if the action map contains the given action.
            </summary>
            <param name="action">An input action. Can be <c>null</c>.</param>
            <returns>True if the action map contains <paramref name="action"/>, false otherwise.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.ToString">
            <summary>
            Return a string representation of the action map useful for debugging.
            </summary>
            <returns>A string representation of the action map.</returns>
            <remarks>
            For unnamed action maps, this will always be <c>"&lt;Unnamed Action Map&gt;"</c>.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.GetEnumerator">
            <summary>
            Enumerate the actions in the map.
            </summary>
            <returns>An enumerator going over the actions in the map.</returns>
            <remarks>
            This method supports to generically iterate over the actions in a map. However, it will usually
            lead to GC allocation. Iterating directly over <see cref="P:UnityEngine.InputSystem.InputActionMap.actions"/> avoids allocating GC memory.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate the actions in the map.
            </summary>
            <returns>An enumerator going over the actions in the map.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.GetEnumerator"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionMap.m_Actions">
            <summary>
            List of actions in this map.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionMap.m_Bindings">
            <summary>
            List of bindings in this map.
            </summary>
            <remarks>
            For singleton actions, we ensure this is always the same as <see cref="F:UnityEngine.InputSystem.InputAction.m_SingletonActionBindings"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionMap.m_BindingsForEachAction">
            <summary>
            For each entry in <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Actions"/>, a slice of this array corresponds to the
            action's bindings.
            </summary>
            <remarks>
            Ideally, this array is the same as <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Bindings"/> (the same as in literally reusing the
            same array). However, we have no guarantee that <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Bindings"/> is sorted by actions. In case it
            isn't, we create a separate array with the bindings sorted by action and have each action reference
            a slice through <see cref="F:UnityEngine.InputSystem.InputAction.m_BindingsStartIndex"/> and <see cref="F:UnityEngine.InputSystem.InputAction.m_BindingsCount"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionMap.SetUpPerActionControlAndBindingArrays"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionMap.m_EnabledActionsCount">
            <summary>
            Number of actions currently enabled in the map.
            </summary>
            <remarks>
            This should only be written to by <see cref="T:UnityEngine.InputSystem.InputActionState"/>.
            </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionMap.m_State">
            <summary>
            Current execution state.
            </summary>
            <remarks>
            Initialized when map (or any action in it) is first enabled.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.GetBindingsForSingleAction(UnityEngine.InputSystem.InputAction)">
             <summary>
             Return the list of bindings for just the given actions.
             </summary>
             <param name="action"></param>
             <returns></returns>
             <remarks>
             The bindings for a single action may be contiguous in <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Bindings"/> or may be scattered
             around. We don't keep persistent storage for these and instead set up a transient
             array if and when bindings are queried directly from an action. In the simple case,
             we don't even need a separate array but rather just need to find out which slice in the
             bindings array corresponds to which action.
            
             NOTE: Bindings for individual actions aren't queried by the system itself during normal
                   runtime operation so we only do this for cases where the user asks for the
                   information. If the user never asks for bindings or controls on a per-action basis,
                   none of this data gets initialized.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.SetUpPerActionControlAndBindingArrays">
             <summary>
             Collect data from <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Bindings"/> and <see cref="F:UnityEngine.InputSystem.InputActionMap.m_Actions"/> such that we can
             we can cleanly expose it from <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> and <see cref="P:UnityEngine.InputSystem.InputAction.controls"/>.
             </summary>
             <remarks>
             We set up per-action caches the first time their information is requested. Internally, we do not
             use those arrays and thus they will not get set up by default.
            
             Note that it is important to allow to call this method at a point where we have not resolved
             controls yet (i.e. <see cref="F:UnityEngine.InputSystem.InputActionMap.m_State"/> is <c>null</c>). Otherwise, using <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/>
             may trigger a control resolution which would be surprising.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.LazyResolveBindings(System.Boolean)">
            <summary>
            Resolve bindings right away if we have to. Otherwise defer it to when we next need
            the bindings.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.ResolveBindings">
             <summary>
             Resolve all bindings to their controls and also add any action interactions
             from the bindings.
             </summary>
             <remarks>
             This is the core method of action binding resolution. All binding resolution goes through here.
            
             The best way is for binding resolution to happen once for each action map at the beginning of the game
             and to then enable and disable the maps as needed. However, the system will also re-resolve
             bindings if the control setup in the system changes (i.e. if devices are added or removed
             or if layouts in the system are changed).
            
             Bindings can be re-resolved while actions are enabled. This happens changing device or binding
             masks on action maps or assets (<see cref="P:UnityEngine.InputSystem.InputActionMap.devices"/>, <see cref="P:UnityEngine.InputSystem.InputActionMap.bindingMask"/>, <see cref="P:UnityEngine.InputSystem.InputAction.bindingMask"/>,
             <see cref="P:UnityEngine.InputSystem.InputActionAsset.devices"/>, <see cref="P:UnityEngine.InputSystem.InputActionAsset.bindingMask"/>). Doing so will
             not affect the enable state of actions and, as much as possible, will try to take current
             action states across.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.FindBinding(UnityEngine.InputSystem.InputBinding,UnityEngine.InputSystem.InputAction@)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.FindBindingRelativeToMap(UnityEngine.InputSystem.InputBinding)">
             <summary>
             Find the index of the first binding that matches the given mask.
             </summary>
             <param name="mask">A binding. See <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/> for details.</param>
             <returns>Index into <see cref="P:UnityEngine.InputSystem.InputAction.bindings"/> of <paramref name="action"/> of the binding
             that matches <paramref name="mask"/>. If no binding matches, will return -1.</returns>
             <remarks>
             For details about matching bindings by a mask, see <see cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>.
            
             <example>
             <code>
             var index = playerInput.actions.FindBindingRelativeToMap(
                 new InputBinding { path = "&lt;Gamepad&gt;/buttonSouth" });
            
             if (index != -1)
                 Debug.Log($"Found binding with index {index}");
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.Matches(UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="P:UnityEngine.InputSystem.InputActionMap.bindings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.FromJson(System.String)">
             <summary>
             Load one or more action maps from JSON.
             </summary>
             <param name="json">JSON representation of the action maps. Can be empty.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is <c>null</c>.</exception>
             <returns>The array of action maps (may be empty) read from the given JSON string. Will not be
             <c>null</c>.</returns>
             <remarks>
             Note that the format used by this method is different than what you
             get if you call <c>JsonUtility.ToJson</c> on an InputActionMap instance. In other
             words, the JSON format is not identical to the Unity serialized object representation
             of the asset.
            
             <example>
             <code>
             var maps = InputActionMap.FromJson(@"
                 {
                     ""maps"" : [
                         {
                             ""name"" : ""Gameplay"",
                             ""actions"" : [
                                 { ""name"" : ""fire"", ""type"" : ""button"" }
                             ],
                             ""bindings"" : [
                                 { ""path"" : ""&lt;Gamepad&gt;/leftTrigger"", ""action"" : ""fire"" }
                             ],
                         }
                     ]
                 }
             ");
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionAsset.FromJson(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionMap.ToJson(System.Collections.Generic.IEnumerable{UnityEngine.InputSystem.InputActionMap})"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.ToJson(System.Collections.Generic.IEnumerable{UnityEngine.InputSystem.InputActionMap})">
             <summary>
             Convert a set of action maps to JSON format.
             </summary>
             <param name="maps">List of action maps to serialize.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="maps"/> is <c>null</c>.</exception>
             <returns>JSON representation of the given action maps.</returns>
             <remarks>
             The result of this method can be loaded with <see cref="M:UnityEngine.InputSystem.InputActionMap.FromJson(System.String)"/>.
            
             Note that the format used by this method is different than what you
             get if you call <c>JsonUtility.ToJson</c> on an InputActionMap instance. In other
             words, the JSON format is not identical to the Unity serialized object representation
             of the asset.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputActionMap.FromJson(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.ToJson">
             <summary>
             Convert the action map to JSON format.
             </summary>
             <returns>A JSON representation of the action map.</returns>
             <remarks>
             The result of this method can be loaded with <see cref="M:UnityEngine.InputSystem.InputActionMap.FromJson(System.String)"/>.
            
             Note that the format used by this method is different than what you
             get if you call <c>JsonUtility.ToJson</c> on an InputActionMap instance. In other
             words, the JSON format is not identical to the Unity serialized object representation
             of the asset.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.OnBeforeSerialize">
            <summary>
            Called by Unity before the action map is serialized using Unity's
            serialization system.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputActionMap.OnAfterDeserialize">
            <summary>
            Called by Unity after the action map has been deserialized using Unity's
            serialization system.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBindingCompositeContext">
             <summary>
             Contextual data made available when processing values of composite bindings.
             </summary>
             <remarks>
             An instance of this struct is passed to <see
             cref="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)"/>.
             Use it to access contextual data such as the value for individual part bindings.
            
             Note that an instance of this struct should never be held on to past the duration
             of the call to <c>ReadValue</c>. The data it retrieves is only valid during
             the callback.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite"/>
             <seealso cref="T:UnityEngine.InputSystem.InputBindingComposite`1"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBindingComposite`1.ReadValue(UnityEngine.InputSystem.InputBindingCompositeContext@)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputBindingCompositeContext.PartBinding">
            <summary>
            Information about a control bound to a part of a composite.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingCompositeContext.PartBinding.part">
            <summary>
            Identifier of the part. This is the numeric identifier stored in the public
            fields of the composite by the input system.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingCompositeContext.PartBinding.control">
            <summary>
            The control bound to the part.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputBindingCompositeContext.controls">
            <summary>
            Enumerate all the controls that are part of the composite.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputBindingComposite.FinishSetup(UnityEngine.InputSystem.InputBindingCompositeContext@)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)">
             <summary>
             Read the value of the giving part binding.
             </summary>
             <param name="partNumber">Number of the part to read. This is assigned
             automatically by the input system and should be treated as an opaque
             identifier. See the example below.</param>
             <typeparam name="TValue">Type of value to read. This must match the
             value type expected from controls bound to the part.</typeparam>
             <returns>The value read from the part bindings.</returns>
             <exception cref="T:System.InvalidOperationException">The given <typeparamref name="TValue"/>
             value type does not match the actual value type of the control(s) bound
             to the part.</exception>
             <remarks>
             If no control is bound to the given part, the return value will always
             be <c>default(TValue)</c>. If a single control is bound to the part, the
             value will be that of the control. If multiple controls are bound to a
             part, the return value will be that greatest one according to <c>IComparable</c>
             implemented by <typeparamref name="TValue"/>.
            
             Note that this method only works with values that are <c>IComparable</c>.
             To read a value type that is not <c>IComparable</c> or to supply a custom
             comparer, use <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``2(System.Int32,``1)"/>.
            
             If an invalid <paramref name="partNumber"/> is supplied, the return value
             will simply be <c>default(TValue)</c>. No exception is thrown.
            
             <example>
             <code>
             public class MyComposite : InputBindingComposite&lt;float&gt;
             {
                 // Defines a "part" binding for the composite. Each part can be
                 // bound to arbitrary many times (including not at all). The "layout"
                 // property of the attribute we supply determines what kind of
                 // control is expected to be bound to the part.
                 //
                 // When initializing a composite instance, the input system will
                 // automatically assign part numbers and store them in the fields
                 // we define here.
                 [InputControl(layout = "Button")]
                 public int firstPart;
            
                 // Defines a second part.
                 [InputControl(layout = "Vector2")]
                 public int secondPart;
            
                 public override float ReadValue(ref InputBindingCompositeContext context)
                 {
                     // Read the button.
                     var firstValue = context.ReadValue&lt;float&gt;();
            
                     // Read the vector.
                     var secondValue = context.ReadValue&lt;Vector2&gt;();
            
                     // Perform some computation based on the inputs. Here, we just
                     // scale the vector by the value we got from the button.
                     return secondValue * firstValue;
                 }
             }
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``2(System.Int32,``1)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32,UnityEngine.InputSystem.InputControl@)">
            <summary>
            Same as <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/> but also return the control
            from which the value was read.
            </summary>
            <param name="partNumber">Number of the part to read. This is assigned
            automatically by the input system and should be treated as an opaque
            identifier.</param>
            <param name="sourceControl">Receives the <see cref="T:UnityEngine.InputSystem.InputControl"/> from
            which the value was read. If multiple controls are bound to the given part,
            this is the control whose value was ultimately selected. Will be set to
            <c>null</c> if <paramref name="partNumber"/> is not a valid part or if no
            controls are bound to the part.</param>
            <typeparam name="TValue">Type of value to read. This must match the
            value type expected from controls bound to the part.</typeparam>
            <returns>The value read from the part bindings.</returns>
            <remarks>
            Like <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>, this method relies on using <c>IComparable</c>
            implemented by <typeparamref name="TValue"/> to determine the greatest value
            if multiple controls are bound to the specified part.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``2(System.Int32,``1)">
             <summary>
             Read the value of the given part bindings and use the given <paramref name="comparer"/>
             to determine which value to return if multiple controls are bound to the part.
             </summary>
             <param name="partNumber">Number of the part to read. This is assigned
             automatically by the input system and should be treated as an opaque
             identifier.</param>
             <param name="comparer">Instance of <typeparamref name="TComparer"/> for comparing
             multiple values.</param>
             <typeparam name="TValue">Type of value to read. This must match the
             value type expected from controls bound to the part.</typeparam>
             <returns>The value read from the part bindings.</returns>
             <typeparam name="TComparer">Comparer to use if multiple controls are bound to
             the given part. All values will be compared using <c>TComparer.Compare</c> and
             the greatest value will be returned.</typeparam>
             <returns>The value read from the part bindings.</returns>
             <remarks>
             This method is a useful alternative to <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/> for
             value types that do not implement <c>IComparable</c> or when the default comparison
             behavior is undesirable.
            
             <example>
             <code>
             public class CompositeWithVector2Part : InputBindingComposite&lt;Vector2&gt;
             {
                 [InputControl(layout = "Vector2")]
                 public int part;
            
                 public override Vector2 ReadValue(ref InputBindingCompositeContext context)
                 {
                     // Return the Vector3 with the greatest magnitude.
                     return context.ReadValue&lt;Vector2, Vector2MagnitudeComparer&gt;(part);
                 }
             }
             </code>
             </example>
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Utilities.Vector2MagnitudeComparer"/>
             <seealso cref="T:UnityEngine.InputSystem.Utilities.Vector3MagnitudeComparer"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``2(System.Int32,UnityEngine.InputSystem.InputControl@,``1)">
            <summary>
            Like <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``2(System.Int32,``1)"/> but also return
            the control from which the value has ultimately been read.
            </summary>
            <param name="partNumber">Number of the part to read. This is assigned
            automatically by the input system and should be treated as an opaque
            identifier.</param>
            <param name="sourceControl">Receives the <see cref="T:UnityEngine.InputSystem.InputControl"/> from
            which the value was read. If multiple controls are bound to the given part,
            this is the control whose value was ultimately selected. Will be set to
            <c>null</c> if <paramref name="partNumber"/> is not a valid part or if no
            controls are bound to the part.</param>
            <param name="comparer">Instance of <typeparamref name="TComparer"/> for comparing
            multiple values.</param>
            <typeparam name="TValue">Type of value to read. This must match the
            value type expected from controls bound to the part.</typeparam>
            <returns>The value read from the part bindings.</returns>
            <typeparam name="TComparer">Comparer to use if multiple controls are bound to
            the given part. All values will be compared using <c>TComparer.Compare</c> and
            the greatest value will be returned.</typeparam>
            <returns>The value read from the part bindings.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValueAsButton(System.Int32)">
             <summary>
             Like <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/> but treat bound controls as buttons. This means
             that custom <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/> are respected and that floating-point
             values from non-ButtonControls will be compared to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.
             </summary>
             <param name="partNumber">Number of the part to read. This is assigned
             automatically by the input system and should be treated as an opaque
             identifier.</param>
             <returns>True if any button bound to the part is pressed.</returns>
             <remarks>
             This method expects all controls bound to the part to be of type <c>InputControl&lt;float&gt;</c>.
            
             This method is different from just calling <see cref="M:UnityEngine.InputSystem.InputBindingCompositeContext.ReadValue``1(System.Int32)"/> with a <c>float</c>
             parameter and comparing the result to <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/> in that
             custom press points set on individual ButtonControls will be respected.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputBindingCompositeContext.GetPressTime(System.Int32)">
            <summary>
            Return the timestamp (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>) for when the given
            binding part crossed the button press threshold (see <see cref="F:UnityEngine.InputSystem.Controls.ButtonControl.pressPoint"/>).
            </summary>
            <param name="partNumber">Number of the part to read. This is assigned
            automatically by the input system and should be treated as an opaque
            identifier.</param>
            <returns>Returns the time at which the given part binding moved into "press" state or 0 if there's
            current no press.</returns>
            <remarks>
            If the given part has more than a single binding and/or more than a single bound control, the <em>earliest</em>
            press time is returned.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputDevice">
             <summary>
             Represents an input device which is always the root of a hierarchy of <see cref="T:UnityEngine.InputSystem.InputControl"/> instances.
             </summary>
             <remarks>
             Input devices act as the container for control hierarchies. Every hierarchy has to have
             a device at the root. Devices cannot occur as children of other controls.
            
             Devices are usually created automatically in response to hardware being discovered by the Unity
             runtime. However, it is possible to manually add devices using methods such as <see
             cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>.
            
             <example>
             <code>
             // Add a "synthetic" gamepad that isn't actually backed by hardware.
             var gamepad = InputSystem.AddDevice&lt;Gamepad&gt;();
             </code>
             </example>
            
             There are subclasses representing the most common types of devices, like <see cref="T:UnityEngine.InputSystem.Mouse"/>,
             <see cref="T:UnityEngine.InputSystem.Keyboard"/>, <see cref="T:UnityEngine.InputSystem.Gamepad"/>, and <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
            
             To create your own types of devices, you can derive from InputDevice and register your device
             as a new "layout".
            
             <example>
             <code>
             // InputControlLayoutAttribute attribute is only necessary if you want
             // to override default behavior that occurs when registering your device
             // as a layout.
             // The most common use of InputControlLayoutAttribute is to direct the system
             // to a custom "state struct" through the `stateType` property. See below for details.
             [InputControlLayout(displayName = "My Device", stateType = typeof(MyDeviceState))]
             #if UNITY_EDITOR
             [InitializeOnLoad]
             #endif
             public class MyDevice : InputDevice
             {
                 public ButtonControl button { get; private set; }
                 public AxisControl axis { get; private set; }
            
                 // Register the device.
                 static MyDevice()
                 {
                     // In case you want instance of your device to automatically be created
                     // when specific hardware is detected by the Unity runtime, you have to
                     // add one or more "device matchers" (InputDeviceMatcher) for the layout.
                     // These matchers are compared to an InputDeviceDescription received from
                     // the Unity runtime when a device is connected. You can add them either
                     // using InputSystem.RegisterLayoutMatcher() or by directly specifying a
                     // matcher when registering the layout.
                     InputSystem.RegisterLayout&lt;MyDevice&gt;(
                         // For the sake of demonstration, let's assume your device is a HID
                         // and you want to match by PID and VID.
                         matches: new InputDeviceMatcher()
                             .WithInterface("HID")
                             .WithCapability("PID", 1234)
                             .WithCapability("VID", 5678));
                 }
            
                 // This is only to trigger the static class constructor to automatically run
                 // in the player.
                 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
                 private static void InitializeInPlayer() {}
            
                 protected override void FinishSetup()
                 {
                     base.FinishSetup();
                     button = GetChildControl&lt;ButtonControl&gt;("button");
                     axis = GetChildControl&lt;AxisControl&gt;("axis");
                 }
             }
            
             // A "state struct" describes the memory format used by a device. Each device can
             // receive and store memory in its custom format. InputControls are then connected
             // the individual pieces of memory and read out values from them.
             [StructLayout(LayoutKind.Explicit, Size = 32)]
             public struct MyDeviceState : IInputStateTypeInfo
             {
                 // In the case of a HID (which we assume for the sake of this demonstration),
                 // the format will be "HID". In practice, the format will depend on how your
                 // particular device is connected and fed into the input system.
                 // The format is a simple FourCC code that "tags" state memory blocks for the
                 // device to give a base level of safety checks on memory operations.
                 public FourCC format => return new FourCC('H', 'I', 'D');
            
                 // InputControlAttributes on fields tell the input system to create controls
                 // for the public fields found in the struct.
            
                 // Assume a 16bit field of buttons. Create one button that is tied to
                 // bit #3 (zero-based). Note that buttons do not need to be stored as bits.
                 // They can also be stored as floats or shorts, for example.
                 [InputControl(name = "button", layout = "Button", bit = 3)]
                 public ushort buttons;
            
                 // Create a floating-point axis. The name, if not supplied, is taken from
                 // the field.
                 [InputControl(layout = "Axis")]
                 public short axis;
             }
             </code>
             </example>
            
             Devices can have usages like any other control (<see cref="P:UnityEngine.InputSystem.InputControl.usages"/>). Unlike other controls,
             however, usages of InputDevices are allowed to be changed on the fly without requiring a change to the
             device layout (see <see cref="M:UnityEngine.InputSystem.InputSystem.SetDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>).
            
             For a more complete example of how to implement custom input devices, check out the "Custom Device"
             sample which you can install from the Unity package manager.
            
             And, as always, you can also find more information in the <a href="../manual/Devices.html">manual</a>.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputControl"/>
             <seealso cref="T:UnityEngine.InputSystem.Mouse"/>
             <seealso cref="T:UnityEngine.InputSystem.Keyboard"/>
             <seealso cref="T:UnityEngine.InputSystem.Gamepad"/>
             <seealso cref="T:UnityEngine.InputSystem.Touchscreen"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDevice.InvalidDeviceId">
            <summary>
            Value of an invalid <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/>.
            </summary>
            <remarks>
            The input system will not assigned this ID to any device.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.description">
             <summary>
             Metadata describing the device (product name etc.).
             </summary>
             <remarks>
             The description of a device is unchanging over its lifetime and does not
             comprise data about a device's configuration (which is considered mutable).
            
             In most cases, the description for a device is supplied by the Unity runtime.
             This it the case for all <see cref="P:UnityEngine.InputSystem.InputDevice.native"/> input devices. However, it is
             also possible to inject new devices in the form of device descriptions into
             the system using <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.Layouts.InputDeviceDescription)"/>.
            
             The description of a device is what is matched by an <see cref="T:UnityEngine.InputSystem.Layouts.InputDeviceMatcher"/>
             to find the <see cref="P:UnityEngine.InputSystem.InputControl.layout"/> to use for a device.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.enabled">
             <summary>
             Whether the device is currently enabled (that is, sends and receives events).
             </summary>
             <remarks>
             A device that is disabled will not receive events. I.e. events that are being sent to the device
             will be ignored.
            
             When disabling a <see cref="P:UnityEngine.InputSystem.InputDevice.native"/> device, a <see cref="T:UnityEngine.InputSystem.LowLevel.DisableDeviceCommand">disable command</see> will
             also be sent to the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">runtime</see>. It depends on the specific runtime whether the
             device command is supported but if it is, the device will be disabled in the runtime and no longer send
             events. This is especially important for devices such as <see cref="T:UnityEngine.InputSystem.Sensor">sensors</see> that incur both
             computation and battery consumption overhead while enabled.
            
             Specific types of devices can choose to start out in disabled state by default. This is generally the
             case for <see cref="T:UnityEngine.InputSystem.Sensor">sensors</see> to ensure that their overhead is only incurred when actually
             being used by the application.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.EnableDevice(UnityEngine.InputSystem.InputDevice)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.DisableDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.canRunInBackground">
             <summary>
             If true, the device is capable of delivering input while the application is running in the background, i.e.
             while <c>Application.isFocused</c> is false.
             </summary>
             <value>Whether the device can generate input while in the background.</value>
             <remarks>
             The value of this property is determined by three separator factors.
            
             For one, <see cref="P:UnityEngine.InputSystem.InputDevice.native"/> devices have an inherent value for this property that can be retrieved through
             <see cref="T:UnityEngine.InputSystem.LowLevel.QueryCanRunInBackground"/>. This determines whether at the input collection level, the device is
             capable of producing input independent of application. This is rare and only a select set of hardware, platform,
             and SDK/API combinations support this. The prominent class of input devices that in general do support this
             behavior are VR devices.
            
             Furthermore, the property may be force-set through a device's <see cref="P:UnityEngine.InputSystem.InputControl.layout"/> by
             means of <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.canRunInBackground"/>.
            
             Lastly, in the editor, the value of the property may be overridden depending on <see cref="P:UnityEngine.InputSystem.InputSettings.editorInputBehaviorInPlayMode"/>
             in case certain devices are automatically kept running in play mode even when no Game View has focus.
            
             Be aware that as far as players are concerned, only certain platforms support running Unity while not having focus.
             On mobile platforms, for example, this is generally not supported. In this case, the value of this property
             has no impact on input while the application does not have focus. See <see cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
             for more details.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.canRunInBackground"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.added">
            <summary>
            Whether the device has been added to the system.
            </summary>
            <value>If true, the device is currently among the devices in <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.</value>
            <remarks>
            Devices may be removed at any time. Either when their hardware is unplugged or when they
            are manually removed through <see cref="M:UnityEngine.InputSystem.InputSystem.RemoveDevice(UnityEngine.InputSystem.InputDevice)"/> or by being excluded
            through <see cref="P:UnityEngine.InputSystem.InputSettings.supportedDevices"/>. When a device is removed, its instance,
            however, will not disappear. This property can be used to check whether the device is part
            of the current set of active devices.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.remote">
            <summary>
            Whether the device is mirrored from a remote input system and not actually present
            as a "real" device in the local system.
            </summary>
            <value>Whether the device mirrors a device from a remotely connected input system.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.remoting"/>
            <seealso cref="T:UnityEngine.InputSystem.InputRemoting"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.native">
             <summary>
             Whether the device comes from the <see cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime">runtime</see>
             </summary>
             <value>Whether the device has been discovered by the Unity runtime.</value>
             <remarks>
             Devices can be discovered when <see cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onDeviceDiscovered">reported</see>
             by the runtime or they can be added manually through the various <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice(UnityEngine.InputSystem.InputDevice)">
             AddDevice</see> APIs. Devices reported by the runtime will return true for this
             property whereas devices added manually will return false.
            
             Devices reported by the runtime will usually come from the Unity engine itself.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.IInputRuntime"/>
             <seealso cref="P:UnityEngine.InputSystem.LowLevel.IInputRuntime.onDeviceDiscovered"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.updateBeforeRender">
             <summary>
             Whether the device requires an extra update before rendering.
             </summary>
             <remarks>
             The value of this property is determined by <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.updateBeforeRender"/> in
             the device's <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout">control layout</see>.
            
             The extra update is necessary for tracking devices that are used in rendering code. For example,
             the eye transforms of an HMD should be refreshed right before rendering as refreshing only in the
             beginning of the frame will lead to a noticeable lag.
             </remarks>
             <seealso cref="F:UnityEngine.InputSystem.LowLevel.InputUpdateType.BeforeRender"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.deviceId">
             <summary>
             Unique numeric ID for the device.
             </summary>
             <remarks>
             This is only assigned once a device has been added to the system. No two devices will receive the same
             ID and no device will receive an ID that another device used before even if the device was removed. The
             only exception to this is if a device gets re-created as part of a layout change. For example, if a new
             layout is registered that replaces the <see cref="T:UnityEngine.InputSystem.Mouse"/> layout, all <see cref="T:UnityEngine.InputSystem.Mouse"/> devices will
             get recreated but will keep their existing device IDs.
            
             IDs are assigned by the input runtime.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.LowLevel.IInputRuntime.AllocateDeviceId"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.lastUpdateTime">
            <summary>
            Timestamp of last state event used to update the device.
            </summary>
            <remarks>
            Events other than <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> and <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> will
            not cause lastUpdateTime to be changed.
            The "timeline" is reset to 0 when entering play mode. If there are any events incoming or device
            updates which occur prior to entering play mode, these will appear negative.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.allControls">
            <summary>
            A flattened list of controls that make up the device.
            </summary>
            <remarks>
            Does not allocate.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.valueType">
            <inheritdoc/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.valueSizeInBytes">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.#ctor">
            <summary>
            This constructor is public for the sake of <c>Activator.CreateInstance</c> only. To construct
            devices, use methods such as <see cref="M:UnityEngine.InputSystem.InputSystem.AddDevice``1(System.String)"/>. Manually
            using <c>new</c> on InputDevice will not result in a usable device.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.ReadValueFromBufferAsObject(System.Void*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.ReadValueFromStateAsObject(System.Void*)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.CompareValue(System.Void*,System.Void*)">
            <inheritdoc/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.NotifyConfigurationChanged">
            <summary>
            Called by the system when the configuration of the device has changed.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.MakeCurrent">
             <summary>
             Make this the current device of its type.
             </summary>
             <remarks>
             This method is called automatically by the input system when a device is
             added or when input is received on it. Many types of devices have <c>.current</c>
             getters that allow querying the last used device of a specific type directly (for
             example, see <see cref="P:UnityEngine.InputSystem.Gamepad.current"/>).
            
             There is one special case, however, related to noise. A device that has noisy controls
             (i.e. controls for which <see cref="P:UnityEngine.InputSystem.InputControl.noisy"/> is true) may receive input events
             that contain no meaningful user interaction but are simply just noise from the device. A
             good example of this is the PS4 gamepad which has a built-in gyro and may thus constantly
             feed events into the input system even if not being actually in use. If, for example, an
             Xbox gamepad and PS4 gamepad are both connected to a PC and the user is playing with the
             Xbox gamepad, the PS4 gamepad would still constantly make itself <see cref="P:UnityEngine.InputSystem.Gamepad.current"/>
             by simply flooding the system with events. Hence why by default,  noise on <c>.current</c> getters
             will be filtered out and a device will only see <c>MakeCurrent</c> getting called if there input
             was detected on non-noisy controls.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Pointer.current"/>
             <seealso cref="P:UnityEngine.InputSystem.Gamepad.current"/>
             <seealso cref="P:UnityEngine.InputSystem.Mouse.current"/>
             <seealso cref="P:UnityEngine.InputSystem.Pen.current"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.OnAdded">
            <summary>
            Called by the system when the device is added to <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.
            </summary>
            <remarks>
            This is called <em>after</em> the device has already been added.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
            <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.Added"/>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.OnRemoved"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.OnRemoved">
            <summary>
            Called by the system when the device is removed from <see cref="P:UnityEngine.InputSystem.InputSystem.devices"/>.
            </summary>
            <remarks>
            This is called <em>after</em> the device has already been removed.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.devices"/>
            <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.Removed"/>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.OnRemoved"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.OnConfigurationChanged">
            <summary>
            Called by the system when the device configuration is changed. This happens when the backend sends
            a <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/> for the device.
            </summary>
            <remarks>
            This method can be used to flush out cached information. An example of where this happens is <see cref="T:UnityEngine.InputSystem.Controls.KeyControl"/>
            caching information about the display name of a control. As this depends on the current keyboard layout, the information
            has to be fetched dynamically (this happens using <see cref="T:UnityEngine.InputSystem.LowLevel.QueryKeyNameCommand"/>). Whenever the keyboard layout changes,
            the system sends a <see cref="T:UnityEngine.InputSystem.LowLevel.DeviceConfigurationEvent"/> for the <see cref="T:UnityEngine.InputSystem.Keyboard"/> at which point the device flushes
            all cached key names.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputManager.OnUpdate(UnityEngine.InputSystem.LowLevel.InputUpdateType,UnityEngine.InputSystem.LowLevel.InputEventBuffer@)"/>
            <seealso cref="F:UnityEngine.InputSystem.InputDeviceChange.ConfigurationChanged"/>
            <seealso cref="M:UnityEngine.InputSystem.InputDevice.OnConfigurationChanged"/>///
        </member>
        <member name="M:UnityEngine.InputSystem.InputDevice.ExecuteCommand``1(``0@)">
             <summary>
             Perform a device-specific command.
             </summary>
             <param name="command">Data for the command to be performed.</param>
             <returns>A transfer-specific return code. Negative values are considered failure codes.</returns>
             <remarks>
             Commands allow devices to set up custom protocols without having to extend
             the device API. This is most useful for devices implemented in the native Unity runtime
             which, through the command interface, may provide custom, device-specific functions.
            
             This is a low-level API. It works in a similar way to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank">
             DeviceIoControl</a> on Windows and <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_blank">ioctl</a>
             on UNIX-like systems.
             </remarks>
        </member>
        <member name="F:UnityEngine.InputSystem.InputDevice.m_LastUpdateTimeInternal">
            <summary>
            Timestamp of last event we received.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputDevice.hasControlsWithDefaultState">
            <summary>
            If true, the device has at least one control that has an explicit default state.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlScheme">
             <summary>
             A named set of zero or more device requirements along with an associated binding group.
             </summary>
             <remarks>
             Control schemes provide an additional layer on top of binding groups. While binding
             groups allow differentiating sets of bindings (e.g. a "Keyboard&amp;Mouse" group versus
             a "Gamepad" group), control schemes impose a set of devices requirements that must be
             met in order for a specific set of bindings to be usable.
            
             Note that control schemes can only be defined at the <see cref="T:UnityEngine.InputSystem.InputActionAsset"/> level.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputActionAsset.controlSchemes"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.name">
            <summary>
            Name of the control scheme. Not <c>null</c> or empty except if InputControlScheme
            instance is invalid (i.e. default-initialized).
            </summary>
            <value>Name of the scheme.</value>
            <remarks>
            May be empty or null except if the control scheme is part of an <see cref="T:UnityEngine.InputSystem.InputActionAsset"/>.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputActionSetupExtensions.AddControlScheme(UnityEngine.InputSystem.InputActionAsset,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.bindingGroup">
            <summary>
            Binding group that is associated with the control scheme. Not <c>null</c> or empty
            except if InputControlScheme is invalid (i.e. default-initialized).
            </summary>
            <value>Binding group for the scheme.</value>
            <remarks>
            All bindings in this group are considered to be part of the control scheme.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputBinding.groups"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements">
             <summary>
             Devices used by the control scheme.
             </summary>
             <value>Device requirements of the scheme.</value>
             <remarks>
             No two entries will be allowed to match the same control or device at runtime in order for the requirements
             of the control scheme to be considered satisfied. If, for example, one entry requires a "&lt;Gamepad&gt;" and
             another entry requires a "&lt;Gamepad&gt;", then at runtime two gamepads will be required even though a single
             one will match both requirements individually. However, if, for example, one entry requires "&lt;Gamepad&gt;/leftStick"
             and another requires "&lt;Gamepad&gt;, the same device can match both requirements as each one resolves to
             a different control.
            
             It it allowed to define control schemes without device requirements, i.e. for which this
             property will be an empty array. Note, however, that features such as automatic control scheme
             switching in <see cref="T:UnityEngine.InputSystem.PlayerInput"/> will not work with such control schemes.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.#ctor(System.String,System.Collections.Generic.IEnumerable{UnityEngine.InputSystem.InputControlScheme.DeviceRequirement},System.String)">
            <summary>
            Initialize the control scheme with the given name, device requirements,
            and binding group.
            </summary>
            <param name="name">Name to use for the scheme. Required.</param>
            <param name="devices">List of device requirements.</param>
            <param name="bindingGroup">Name to use for the binding group (see <see cref="P:UnityEngine.InputSystem.InputBinding.groups"/>)
            associated with the control scheme. If this is <c>null</c> or empty, <paramref name="name"/> is
            used instead (with <see cref="F:UnityEngine.InputSystem.InputBinding.Separator"/> characters stripped from the name).</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <c>null</c> or empty.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.FindControlSchemeForDevices``2(``0,``1,UnityEngine.InputSystem.InputDevice,System.Boolean)">
             <summary>
             Given a list of devices and a list of control schemes, find the most suitable control
             scheme to use with the devices.
             </summary>
             <param name="devices">A list of devices. If the list is empty, only schemes with
             empty <see cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/> lists will get matched.</param>
             <param name="schemes">A list of control schemes.</param>
             <param name="mustIncludeDevice">If not <c>null</c>, a successful match has to include the given device.</param>
             <param name="allowUnsuccesfulMatch">If true, then allow returning a match that has unsatisfied requirements but still
             matched at least some requirement. If there are several unsuccessful matches, the returned scheme is still the highest
             scoring one among those.</param>
             <typeparam name="TDevices">Collection type to use for the list of devices.</typeparam>
             <typeparam name="TSchemes">Collection type to use for the list of schemes.</typeparam>
             <returns>The control scheme that best matched the given devices or <c>null</c> if no
             scheme was found suitable.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="devices"/> is <c>null</c> -or-
             <paramref name="schemes"/> is <c>null</c>.</exception>
             <remarks>
             Any successful match (see <see cref="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.isSuccessfulMatch"/>) will be considered.
             The one that matches the most amount of devices (see <see cref="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.devices"/>)
             will be returned. If more than one schemes matches equally well, the first one encountered
             in the list is returned.
            
             Note that schemes are not required to match all devices available in the list. The result
             will simply be the scheme that matched the most devices of what was devices. Use <see
             cref="M:UnityEngine.InputSystem.InputControlScheme.PickDevicesFrom``1(``0,UnityEngine.InputSystem.InputDevice)"/> to find the devices that a control scheme selects.
            
             This method is parameterized over <typeparamref name="TDevices"/> and <typeparamref name="TSchemes"/>
             to allow avoiding GC heap allocations from boxing of structs such as <see cref="T:UnityEngine.InputSystem.Utilities.ReadOnlyArray`1"/>.
            
             <example>
             <code>
             // Create an .inputactions asset.
             var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();
            
             // Add some control schemes to the asset.
             asset.AddControlScheme("KeyboardMouse")
                 .WithRequiredDevice&lt;Keyboard&gt;()
                 .WithRequiredDevice&lt;Mouse&gt;());
             asset.AddControlScheme("Gamepad")
                 .WithRequiredDevice&lt;Gamepad&gt;());
             asset.AddControlScheme("DualGamepad")
                 .WithRequiredDevice&lt;Gamepad&gt;())
                 .WithOptionalGamepad&lt;Gamepad&gt;());
            
             // Add some devices that we can test with.
             var keyboard = InputSystem.AddDevice&lt;Keyboard&gt;();
             var mouse = InputSystem.AddDevice&lt;Mouse&gt;();
             var gamepad1 = InputSystem.AddDevice&lt;Gamepad&gt;();
             var gamepad2 = InputSystem.AddDevice&lt;Gamepad&gt;();
            
             // Matching with just a keyboard won't match any scheme.
             InputControlScheme.FindControlSchemeForDevices(
                 new InputDevice[] { keyboard }, asset.controlSchemes);
            
             // Matching with a keyboard and mouse with match the "KeyboardMouse" scheme.
             InputControlScheme.FindControlSchemeForDevices(
                 new InputDevice[] { keyboard, mouse }, asset.controlSchemes);
            
             // Matching with a single gamepad will match the "Gamepad" scheme.
             // Note that since the second gamepad is optional in "DualGamepad" could
             // match the same set of devices but it doesn't match any better than
             // "Gamepad" and that one comes first in the list.
             InputControlScheme.FindControlSchemeForDevices(
                 new InputDevice[] { gamepad1 }, asset.controlSchemes);
            
             // Matching with two gamepads will match the "DualGamepad" scheme.
             // Note that "Gamepad" will match this device list as well. If "DualGamepad"
             // didn't exist, "Gamepad" would be the result here. However, "DualGamepad"
             // matches the list better than "Gamepad" so that's what gets returned here.
             InputControlScheme.FindControlSchemeForDevices(
                 new InputDevice[] { gamepad1, gamepad2 }, asset.controlSchemes);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.FindControlSchemeForDevice``1(UnityEngine.InputSystem.InputDevice,``0)">
            <summary>
            Return the first control schemes from the given list that supports the given
            device (see <see cref="M:UnityEngine.InputSystem.InputControlScheme.SupportsDevice(UnityEngine.InputSystem.InputDevice)"/>).
            </summary>
            <param name="device">An input device.</param>
            <param name="schemes">A list of control schemes. Can be empty.</param>
            <typeparam name="TSchemes">Collection type to use for the list of schemes.</typeparam>
            <returns>The first schemes from <paramref name="schemes"/> that supports <paramref name="device"/>
            or <c>null</c> if none of the schemes is usable with the device.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c> -or-
            <paramref name="schemes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.SupportsDevice(UnityEngine.InputSystem.InputDevice)">
             <summary>
             Whether the control scheme has a requirement in <see cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/> that
             targets the given device.
             </summary>
             <param name="device">An input device.</param>
             <returns>True if the control scheme has a device requirement matching the device.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
             <remarks>
             Note that both optional (see <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>) and non-optional
             device requirements are taken into account.
            
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.PickDevicesFrom``1(``0,UnityEngine.InputSystem.InputDevice)">
            <summary>
            Based on a list of devices, make a selection that matches the <see cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements">requirements</see>
            imposed by the control scheme.
            </summary>
            <param name="devices">A list of devices to choose from.</param>
            <param name="favorDevice">If not null, the device will be favored over other devices in <paramref name="devices"/>.
            Note that the device must be present in the list also.</param>
            <returns>A <see cref="T:UnityEngine.InputSystem.InputControlScheme.MatchResult"/> structure containing the result of the pick. Note that this structure
            must be manually <see cref="M:UnityEngine.InputSystem.InputControlScheme.MatchResult.Dispose">disposed</see> or unmanaged memory will be leaked.</returns>
            <remarks>
            Does not allocate managed memory.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlScheme.MatchResult">
            <summary>
            The result of matching a list of <see cref="T:UnityEngine.InputSystem.InputDevice">devices</see> against a list of
            <see cref="T:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement">requirements</see> in an <see cref="T:UnityEngine.InputSystem.InputControlScheme"/>.
            </summary>
            <remarks>
            This struct uses <see cref="T:UnityEngine.InputSystem.InputControlList`1"/> which allocates unmanaged memory
            and thus must be disposed in order to not leak unmanaged heap memory.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControlScheme.PickDevicesFrom``1(``0,UnityEngine.InputSystem.InputDevice)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.score">
             <summary>
             Overall, relative measure for how well the control scheme matches.
             </summary>
             <value>Scoring value for the control scheme match.</value>
             <remarks>
             Two control schemes may, for example, both support gamepads but one may be tailored to a specific
             gamepad whereas the other one is a generic gamepad control scheme. To differentiate the two, we need
             to know not only that a control schemes but how well it matches relative to other schemes. This is
             what the score value is used for.
            
             Scores are computed primarily based on layouts referenced from device requirements. To start with, each
             matching device requirement (whether optional or mandatory) will add 1 to the score. This the base
             score of a match. Then, for each requirement a delta is computed from the device layout referenced by
             the requirement to the device layout used by the matching control. For example, if the requirement is
             <c>"&lt;Gamepad&gt;</c> and the matching control uses the <see cref="T:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID"/>
             layout, the delta is 2 as the latter layout is derived from <see cref="T:UnityEngine.InputSystem.Gamepad"/> via the intermediate
             <see cref="T:UnityEngine.InputSystem.DualShock.DualShockGamepad"/> layout, i.e. two steps in the inheritance hierarchy. The
             <em>inverse</em> of the delta plus one, i.e. <c>1/(delta+1)</c> is then added to the score. This means
             that an exact match will add an additional 1 to the score and less exact matches will add progressively
             smaller values to the score (proportional to the distance of the actual layout to the one used in the
             requirement).
            
             What this leads to is that, for example, a control scheme with a <c>"&lt;Gamepad&gt;"</c> requirement
             will match a <see cref="T:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID"/> with a <em>lower</em> score than a control
             scheme with a <c>"&lt;DualShockGamepad&gt;"</c> requirement as the <see cref="T:UnityEngine.InputSystem.Gamepad"/> layout is
             further removed (i.e. smaller inverse delta) from <see cref="T:UnityEngine.InputSystem.DualShock.DualShock4GamepadHID"/> than
             <see cref="T:UnityEngine.InputSystem.DualShock.DualShockGamepad"/>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.isSuccessfulMatch">
            <summary>
            Whether the device requirements got successfully matched.
            </summary>
            <value>True if the scheme's device requirements were satisfied.</value>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.hasMissingRequiredDevices">
            <summary>
            Whether there are missing required devices.
            </summary>
            <value>True if there are missing, non-optional devices.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.hasMissingOptionalDevices">
            <summary>
            Whether there are missing optional devices. This does not prevent
            a successful match.
            </summary>
            <value>True if there are missing optional devices.</value>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.devices">
            <summary>
            The devices that got picked from the available devices.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.MatchResult.GetEnumerator">
            <summary>
            Enumerate the match for each individual <see cref="T:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement"/> in the control scheme.
            </summary>
            <returns>An enumerate going over each individual match.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.MatchResult.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate the match for each individual <see cref="T:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement"/> in the control scheme.
            </summary>
            <returns>An enumerate going over each individual match.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlScheme.MatchResult.Dispose">
            <summary>
            Discard the list of devices.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match">
            <summary>
            A single matched <see cref="T:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement"/>.
            </summary>
            <remarks>
            Links the control that was matched with the respective device requirement.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.control">
             <summary>
             The control that was match from the requirement's <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.controlPath"/>
             </summary>
             <remarks>
             This is the same as <see cref="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.device"/> if the <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.controlPath">control
             path</see> matches the device directly rather than matching a control on the device.
            
             Note that while a control path can match arbitrary many controls, only the first matched control
             will be returned here. To get all controls that were matched by a specific requirement, a
             manual query must be performed using <see cref="T:UnityEngine.InputSystem.InputControlPath"/>.
            
             If the match failed, this will be null.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.device">
            <summary>
            The device that got matched.
            </summary>
            <remarks>
            If a specific control on the device was matched, this will be <see cref="P:UnityEngine.InputSystem.InputControl.device"/> or
            <see cref="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.control"/>. If a device was matched directly, this will be the same as <see cref="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.control"/>.
            </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.requirementIndex">
            <summary>
            Index of the requirement in <see cref="P:UnityEngine.InputSystem.InputControlScheme.deviceRequirements"/>.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.MatchResult.Match.requirement">
            <summary>
            The device requirement that got matched.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement">
             <summary>
            
             </summary>
             <remarks>
             Note that device requirements may require specific controls to be present rather than only requiring
             the presence of a certain type of device. For example, a requirement with a <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.controlPath"/>
             of "*/{PrimaryAction}" will be satisfied by any device that has a control marked as <see cref="F:UnityEngine.InputSystem.CommonUsages.PrimaryAction"/>.
            
             Requirements are ordered in a list and can combine with their previous requirement in either <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isAND">
             AND</see> or in <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOR">OR</see> fashion. The default is for requirements to combine with AND.
            
             Note that it is not possible to express nested constraints like <c>(a AND b) OR (c AND d)</c>. Also note that
             operator precedence is the opposite of C#, meaning that OR has *higher* precedence than AND. This means
             that <c>a OR b AND c OR d</c> reads as <c>(a OR b) AND (c OR d)</c> (in C# it would read as <c>a OR
             (b AND c) OR d</c>.
            
             More complex expressions can often be expressed differently. For example, <c>(a AND b) OR (c AND d)</c>
             can be expressed as <c>a OR c AND b OR d</c>.
             </remarks>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.controlPath">
             <summary>
             <see cref="T:UnityEngine.InputSystem.InputControlPath">Control path</see> that is matched against a device to determine
             whether it qualifies for the control scheme.
             </summary>
             <remarks>
             </remarks>
             <example>
             <code>
             // A left-hand XR controller.
             "&lt;XRController&gt;{LeftHand}"
            
             // A gamepad.
             "&lt;Gamepad&gt;"
             </code>
             </example>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional">
            <summary>
            If true, a device with the given <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.controlPath">device path</see> is employed by the
            control scheme if one is available. If none is available, the control scheme is still
            functional.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isAND">
            <summary>
            Whether the requirement combines with the previous requirement (if any) as a boolean AND.
            </summary>
            <remarks>
            This is the default. For example, to require both a left hand and a right XR controller,
            the first requirement would be for "&lt;XRController&gt;{LeftHand}" and the second
            requirement would be for "&gt;XRController&gt;{RightHand}" and would return true for this
            property.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOR"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOR">
             <summary>
             Whether the requirement combines with the previous requirement (if any) as a boolean OR.
             </summary>
             <remarks>
             This allows designing control schemes that flexibly work with combinations of devices such that
             if one specific device isn't present, another device can substitute for it.
            
             For example, to design a mouse+keyboard control scheme that can alternatively work with a pen
             instead of a mouse, the first requirement could be for "&lt;Keyboard&gt;", the second one
             could be for "&lt;Mouse&gt;" and the third one could be for "&lt;Pen&gt;" and return true
             for this property. Both the mouse and the pen would be marked as required (i.e. not <see cref="P:UnityEngine.InputSystem.InputControlScheme.DeviceRequirement.isOptional"/>)
             but the device requirements are satisfied even if either device is present.
            
             Note that if both a pen and a mouse are present at the same time, still only one device is
             picked. In this case, the mouse "wins" as it comes first in the list of requirements.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlScheme.SchemeJson">
            <summary>
            JSON-serialized form of a control scheme.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputActionType">
             <summary>
             Determines the behavior with which an <see cref="T:UnityEngine.InputSystem.InputAction"/> triggers.
             </summary>
             <remarks>
             While all actions essentially function the same way, there are differences in how an action
             will react to changes in values on the controls it is bound to.
            
             The most straightforward type of behavior is <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> which does not expect
             any kind of value change pattern but simply triggers the action on every single value change.
             A pass-through action will not use <see cref="E:UnityEngine.InputSystem.InputAction.started"/> or
             <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> except on bindings that have an interaction added to them.
             Pass-through actions are most useful for sourcing input from arbitrary many controls and
             simply piping all input through without much processing on the side of the action.
            
             <example>
             <code>
             // An action that triggers every time any button on the gamepad is
             // pressed or released.
             var action = new InputAction(
                 type: InputActionType.PassThrough,
                 binding: "&lt;Gamepad&gt;/&lt;Button&gt;");
            
             action.performed +=
                 ctx =>
                 {
                     var button = (ButtonControl)ctx.control;
                     if (button.wasPressedThisFrame)
                         Debug.Log($"Button {ctx.control} was pressed");
                     else if (button.wasReleasedThisFrame)
                         Debug.Log($"Button {ctx.control} was released");
                     // NOTE: We may get calls here in which neither the if nor the else
                     //       clause are true here. A button like the gamepad left and right
                     //       triggers, for example, do not just have a binary on/off state
                     //       but rather a [0..1] value range.
                 };
            
             action.Enable();
             </code>
             </example>
            
             Note that pass-through actions do not perform any kind of disambiguation of input
             which makes them great for just forwarding input from any connected controls but
             makes them a poor choice when only one input should be generated from however
             many connected controls there are. For more details, see <a
             href="../manual/ActionBindings.html#conflicting-inputs">here</a>.
            
             The other two behavior types are <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>.
            
             A <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> action starts (<see cref="E:UnityEngine.InputSystem.InputAction.started"/>) as soon as its
             input moves away from its default value. After that it immediately performs (<see cref="E:UnityEngine.InputSystem.InputAction.performed"/>)
             and every time the input changes value it performs again except if the input moves back
             to the default value -- in which case the action cancels (<see cref="E:UnityEngine.InputSystem.InputAction.canceled"/>).
            
             Also, unlike both <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> actions, <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
             actions perform what's called "initial state check" on the first input update after the action
             was enabled. What this does is check controls bound to the action and if they are already actuated
             (that is, at non-default value), the action will immediately be started and performed. What
             this means in practice is that when a value action is bound to, say, the left stick on a
             gamepad and the stick is already moved out of its resting position, then the action will
             immediately trigger instead of first requiring the stick to be moved slightly.
            
             <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> actions, on the other hand, perform
             no such initial state check. For buttons, for example, this means that if a button is
             already pressed when an action is enabled, it first has to be released and then
             pressed again for the action to be triggered.
            
             <example>
             <code>
             // An action that starts when the left stick on the gamepad is actuated
             // and stops when the stick is released.
             var action = new InputAction(
                 type: InputActionType.Value,
                 binding: "&lt;Gamepad&gt;/leftStick");
            
             action.started +=
                 ctx =>
                 {
                     Debug.Log("--- Stick Starts ---");
                 };
             action.performed +=
                 ctx =>
                 {
                     Debug.Log("Stick Value: " + ctx.ReadValue&lt;Vector2D&gt;();
                 };
             action.canceled +=
                 ctx =>
                 {
                     Debug.Log("# Stick Released");
                 };
            
             action.Enable();
             </code>
             </example>
            
             A <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> action essentially operates like a <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> action except
             that it does not perform an initial state check.
            
             One final noteworthy difference of both <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> compared
             to <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> is that both of them perform what is referred to as "disambiguation"
             when multiple actions are bound to the control. <see cref="F:UnityEngine.InputSystem.InputActionType.PassThrough"/> does not care how
             many controls are bound to the action -- it simply passes every input through as is, no matter
             where it comes from.
            
             <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> and <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>, on the other hand, will treat input differently
             if it is coming from several sources at the same time. Note that this can only happen when there
             are multiple controls bound to a single actions -- either by a single binding resolving to
             more than one control (e.g. <c>"*/{PrimaryAction}"</c>) or by multiple bindings all targeting
             the same action and being active at the same time. If only a single control is bound to an
             action, then the disambiguation code is automatically bypassed.
            
             Disambiguation works the following way: when an action has not yet been started, it will react
             to the first input that has a non-default value. Once it receives such an input, it will start
             tracking the source of that input. While the action is in-progress, if it receives input from
             a source other than the control it is currently tracking, it will check whether the input has
             a greater magnitude (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) than the control the
             action is already tracking. If so, the action will switch from its current control to the control
             with the stronger input.
            
             Note that this process does also works in reverse. When the control currently driving the action
             lowers its value below that of another control that is also actuated and bound to the action,
             the action will switch to that control.
            
             Put simply, a <see cref="F:UnityEngine.InputSystem.InputActionType.Button"/> or <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> action bound to multiple controls will
             always track the control with the strongest input.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputAction.type"/>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionType.Value">
             <summary>
             An action that reads a single value from its connected sources. If multiple bindings
             actuate at the same time, performs disambiguation (see <see
             href="../manual/ActionBindings.html#conflicting-inputs"/>) to detect the highest value contributor
             at any one time.
            
             A value action starts (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/>) and then performs (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>)
             as soon as a bound control changes to a non-default value. For example, if an action is bound to <see cref="P:UnityEngine.InputSystem.Gamepad.leftStick"/>
             and the stick moves from (0,0) to (0.5,0.5), the action starts and performs.
            
             After being started, the action will perform on every value change that is not the default value. In the example here, if
             the stick goes to (0.75,0.75) and then to (1,1), the action will perform twice.
            
             Finally, if the control value changes back to the default value, the action is canceled (<see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/>).
             Meaning that if the stick moves back to (0,0), <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> will be triggered.
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionType.Button">
             <summary>
             An action that acts as a trigger.
            
             A button action has a defined trigger point that corresponds to <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/>.
             After being performed, the action goes back to waiting state to await the next triggering.
            
             Note that a button action may still use <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> and does not necessarily
             trigger immediately on input. For example, if <see cref="T:UnityEngine.InputSystem.Interactions.HoldInteraction"/> is used, the
             action will start as soon as a bound button crosses its press threshold but will not trigger until the
             button is held for the set hold duration (<see cref="F:UnityEngine.InputSystem.Interactions.HoldInteraction.duration"/>).
            
             Irrespective of which type an action is set to, it is possible to find out whether it was or is considered
             pressed and/or released using <see cref="M:UnityEngine.InputSystem.InputAction.IsPressed"/>, <see cref="M:UnityEngine.InputSystem.InputAction.WasPressedThisFrame"/>,
             and <see cref="M:UnityEngine.InputSystem.InputAction.WasReleasedThisFrame"/>.
            
             <example>
             <code>
             action.IsPressed();
             action.WasPressedThisFrame();
             action.WasReleasedThisFrame();
             </code>
             </example>
             </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputActionType.PassThrough">
             <summary>
             An action that has no specific type of behavior and instead acts as a simple pass-through for
             any value change on any bound control. In effect, this turns an action from a single value producer into a mere
             input "sink".
            
             This is in some ways similar to <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>. However, there are two key differences.
            
             For one,  the action will not perform any disambiguation when bound to multiple controls concurrently.
             This means that if, for example, the action is bound to both the left and the right stick on a <see cref="T:UnityEngine.InputSystem.Gamepad"/>,
             and the left stick goes to (0.5,0.5) and the right stick then goes to (0.25,0.25), the action will perform
             twice yielding a value of (0.5,0.5) first and a value of (0.25, 0.25) next. This is different from <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/>
             where upon actuation to (0.5,0.5), the left stick would get to drive the action and the actuation of the right
             stick would be ignored as it does not exceed the magnitude of the actuation on the left stick.
            
             The second key difference is that only <see cref="F:UnityEngine.InputSystem.InputActionPhase.Performed"/> is used and will get triggered
             on every value change regardless of what the value is. This is different from <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> where the
             action will trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Started"/> when moving away from its default value and will
             trigger <see cref="F:UnityEngine.InputSystem.InputActionPhase.Canceled"/> when going back to the default value.
            
             Note that a pass-through action my still get cancelled and thus see <see cref="E:UnityEngine.InputSystem.InputAction.canceled"/> getting called.
             This happens when a factor other than input on a device causes an action in progress to be cancelled. An example
             of this is when an action is disabled (see <see cref="M:UnityEngine.InputSystem.InputAction.Disable"/>) or when focus is lost (see <see cref="P:UnityEngine.InputSystem.InputSettings.backgroundBehavior"/>)
             and a device connection to an action is reset (see <see cref="M:UnityEngine.InputSystem.InputSystem.ResetDevice(UnityEngine.InputSystem.InputDevice,System.Boolean)"/>).
            
             Also note that for a pass-through action, calling <see cref="M:UnityEngine.InputSystem.InputAction.ReadValue``1"/> is often not
             very useful as it will only return the value of the very last control that fed into the action. For pass-through
             actions, it is usually best to listen to <see cref="E:UnityEngine.InputSystem.InputAction.performed"/> in order to be notified about every
             single value change. Where this is not necessary, it is generally better to employ a <see cref="F:UnityEngine.InputSystem.InputActionType.Value"/> action
             instead.
             </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.IInputDiagnostics">
             <summary>
             Internal interface that allows monitoring the system for problems.
             </summary>
             <remarks>
             This is primarily meant to make it easier to diagnose problems in the event stream.
            
             Note that while the diagnostics hook is only enabled in the editor, when using
             the input debugger connected to a player it will also diagnose problems in the
             event stream of the player.
             </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlPath">
             <summary>
             Functions for working with control path specs (like "/gamepad/*stick").
             </summary>
             <remarks>
             Control paths are a mini-language similar to regular expressions. They are used throughout
             the input system as string "addresses" of input controls. At runtime, they can be matched
             against the devices and controls present in the system to retrieve the actual endpoints to
             receive input from.
            
             Like on a file system, a path is made up of components that are each separated by a
             forward slash (<c>/</c>). Each such component in turn is made up of a set of fields that are
             individually optional. However, one of the fields must be present (e.g. at least a name or
             a wildcard).
            
             <example>
             Field structure of each path component
             <code>
             &lt;Layout&gt;{Usage}#(DisplayName)Name
             </code>
             </example>
            
             * <c>Layout</c>: The name of the layout that the control must be based on (either directly or indirectly).
             * <c>Usage</c>: The usage that the control or device has to have, i.e. must be found in <see
                             cref="P:UnityEngine.InputSystem.InputControl.usages"/> This field can be repeated several times to require
                             multiple usages (e.g. <c>"{LeftHand}{Vertical}"</c>).
             * <c>DisplayName</c>: The name that <see cref="P:UnityEngine.InputSystem.InputControl.displayName"/> of the control or device
                                   must match.
             * <c>Name</c>: The name that <see cref="P:UnityEngine.InputSystem.InputControl.name"/> or one of the entries in
                            <see cref="P:UnityEngine.InputSystem.InputControl.aliases"/> must match. Alternatively, this can be a
                            wildcard (<c>*</c>) to match any name.
            
             Note that all matching is case-insensitive.
            
             <example>
             Various examples of control paths
             <code>
             // Matches all gamepads (also gamepads *based* on the Gamepad layout):
             "&lt;Gamepad&gt;"
            
             // Matches the "Submit" control on all devices:
             "*/{Submit}"
            
             // Matches the key that prints the "a" character on the current keyboard layout:
             "&lt;Keyboard&gt;/#(a)"
            
             // Matches the X axis of the left stick on a gamepad.
             "&lt;Gamepad&gt;/leftStick/x"
            
             // Matches the orientation control of the right-hand XR controller:
             "&lt;XRController&gt;{RightHand}/orientation"
            
             // Matches all buttons on a gamepad.
             "&lt;Gamepad&gt;/&lt;Button&gt;"
             </code>
             </example>
            
             The structure of the API of this class is similar in spirit to <c>System.IO.Path</c>, i.e. it offers
             a range of static methods that perform various operations on path strings.
            
             To query controls on devices present in the system using control paths, use
             <see cref="M:UnityEngine.InputSystem.InputSystem.FindControls(System.String)"/>. Also, control paths can be used with
             <see cref="P:UnityEngine.InputSystem.InputControl.Item(System.String)"/> on every control. This makes it possible
             to do things like:
            
             <example>
             Find key that prints "t" on current keyboard:
             <code>
             Keyboard.current["#(t)"]
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControls(System.String)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions">
            <summary>
            Options for customizing the behavior of <see cref="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions.None">
            <summary>
            The default behavior.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions.OmitDevice">
            <summary>
            Do not mention the device of the control. For example, instead of "A [Gamepad]",
            return just "A".
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions.UseShortNames">
            <summary>
            When available, use short display names instead of long ones. For example, instead of "Left Button",
            return "LMB".
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)">
             <summary>
             Create a human readable string from the given control path.
             </summary>
             <param name="path">A control path such as "&lt;XRController>{LeftHand}/position".</param>
             <param name="options">Customize the resulting string.</param>
             <param name="control">An optional control. If supplied and the control or one of its children
             matches the given <paramref name="path"/>, display names will be based on the matching control
             rather than on static information available from <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>s.</param>
             <returns>A string such as "Left Stick/X [Gamepad]".</returns>
             <remarks>
             This function is most useful for turning binding paths (see <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>)
             into strings that can be displayed in UIs (such as rebinding screens). It is used by
             the Unity editor itself to display binding paths in the UI.
            
             The method uses display names (see <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.displayName"/>,
             <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.displayName"/>, and <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.displayName"/>)
             where possible. For example, "&lt;XInputController&gt;/buttonSouth" will be returned as
             "A [Xbox Controller]" as the display name of <see cref="T:UnityEngine.InputSystem.XInput.XInputController"/> is "XBox Controller"
             and the display name of its "buttonSouth" control is "A".
            
             Note that these lookups depend on the currently registered control layouts (see <see
             cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>) and different strings may thus be returned for the same control
             path depending on the layouts registered with the system.
            
             <example>
             <code>
             InputControlPath.ToHumanReadableString("*/{PrimaryAction"); // -> "PrimaryAction [Any]"
             InputControlPath.ToHumanReadableString("&lt;Gamepad&gt;/buttonSouth"); // -> "Button South [Gamepad]"
             InputControlPath.ToHumanReadableString("&lt;XInputController&gt;/buttonSouth"); // -> "A [Xbox Controller]"
             InputControlPath.ToHumanReadableString("&lt;Gamepad&gt;/leftStick/x"); // -> "Left Stick/X [Gamepad]"
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.ToHumanReadableString(System.String,System.String@,System.String@,UnityEngine.InputSystem.InputControlPath.HumanReadableStringOptions,UnityEngine.InputSystem.InputControl)">
             <summary>
             Create a human readable string from the given control path.
             </summary>
             <param name="path">A control path such as "&lt;XRController>{LeftHand}/position".</param>
             <param name="deviceLayoutName">Receives the name of the device layout that the control path was resolved to.
             This is useful </param>
             <param name="controlPath">Receives the path to the referenced control on the device or <c>null</c> if not applicable.
             For example, with a <paramref name="path"/> of <c>"&lt;Gamepad&gt;/dpad/up"</c>, the resulting control path
             will be <c>"dpad/up"</c>. This is useful when trying to look up additional resources (such as images) based on the
             control that is being referenced.</param>
             <param name="options">Customize the resulting string.</param>
             <param name="control">An optional control. If supplied and the control or one of its children
             matches the given <paramref name="path"/>, display names will be based on the matching control
             rather than on static information available from <see cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>s.</param>
             <returns>A string such as "Left Stick/X [Gamepad]".</returns>
             <remarks>
             This function is most useful for turning binding paths (see <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>)
             into strings that can be displayed in UIs (such as rebinding screens). It is used by
             the Unity editor itself to display binding paths in the UI.
            
             The method uses display names (see <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.displayName"/>,
             <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayoutAttribute.displayName"/>, and <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.displayName"/>)
             where possible. For example, "&lt;XInputController&gt;/buttonSouth" will be returned as
             "A [Xbox Controller]" as the display name of <see cref="T:UnityEngine.InputSystem.XInput.XInputController"/> is "XBox Controller"
             and the display name of its "buttonSouth" control is "A".
            
             Note that these lookups depend on the currently registered control layouts (see <see
             cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>) and different strings may thus be returned for the same control
             path depending on the layouts registered with the system.
            
             <example>
             <code>
             InputControlPath.ToHumanReadableString("*/{PrimaryAction"); // -> "PrimaryAction [Any]"
             InputControlPath.ToHumanReadableString("&lt;Gamepad&gt;/buttonSouth"); // -> "Button South [Gamepad]"
             InputControlPath.ToHumanReadableString("&lt;XInputController&gt;/buttonSouth"); // -> "A [Xbox Controller]"
             InputControlPath.ToHumanReadableString("&lt;Gamepad&gt;/leftStick/x"); // -> "Left Stick/X [Gamepad]"
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputBinding.ToDisplayString(UnityEngine.InputSystem.InputBinding.DisplayStringOptions,UnityEngine.InputSystem.InputControl)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetBindingDisplayString(UnityEngine.InputSystem.InputAction,System.Int32,UnityEngine.InputSystem.InputBinding.DisplayStringOptions)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.TryGetDeviceLayout(System.String)">
            <summary>
            From the given control path, try to determine the device layout being used.
            </summary>
            <remarks>
            This function will only use information available in the path itself or
            in layouts referenced by the path. It will not look at actual devices
            in the system. This is to make the behavior predictable and not dependent
            on whether you currently have the right device connected or not.
            </remarks>
            <param name="path">A control path (like "/&lt;gamepad&gt;/leftStick")</param>
            <returns>The name of the device layout used by the given control path or null
            if the path does not specify a device layout or does so in a way that is not
            supported by the function.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null</exception>
            <example>
            <code>
            InputControlPath.TryGetDeviceLayout("/&lt;gamepad&gt;/leftStick"); // Returns "gamepad".
            InputControlPath.TryGetDeviceLayout("/*/leftStick"); // Returns "*".
            InputControlPath.TryGetDeviceLayout("/gamepad/leftStick"); // Returns null. "gamepad" is a device name here.
            </code>
            </example>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.TryFindControl``1(UnityEngine.InputSystem.InputControl,System.String,System.Int32)">
             <summary>
             Return the first child control that matches the given path.
             </summary>
             <param name="control">Control root at which to start the search.</param>
             <param name="path">Path of the control to find. Can be <c>null</c> or empty, in which case <c>null</c>
             is returned.</param>
             <param name="indexInPath">Index in <paramref name="path"/> at which to start parsing. Defaults to
             0, i.e. parsing starts at the first character in the path.</param>
             <returns>The first (direct or indirect) child control of <paramref name="control"/> that matches
             <paramref name="path"/>.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
             <remarks>
             Does not allocate.
            
             Note that if multiple child controls match the given path, which one is returned depends on the
             ordering of controls. The result should be considered indeterministic in this case.
            
             <example>
             <code>
             // Find X control of left stick on current gamepad.
             InputControlPath.TryFindControl(Gamepad.current, "leftStick/x");
            
             // Find control with PrimaryAction usage on current mouse.
             InputControlPath.TryFindControl(Mouse.current, "{PrimaryAction}");
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.Item(System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.TryFindControls``1(UnityEngine.InputSystem.InputControl,System.String,System.Int32,UnityEngine.InputSystem.InputControlList{``0}@)">
             <summary>
             Perform a search for controls starting with the given control as root and matching
             the given path from the given position. Puts all matching controls on the list and
             returns the number of controls that have been matched.
             </summary>
             <param name="control">Control at which the given path is rooted.</param>
             <param name="path"></param>
             <param name="indexInPath"></param>
             <param name="matches"></param>
             <typeparam name="TControl"></typeparam>
             <returns></returns>
             <exception cref="T:System.ArgumentNullException"></exception>
             <remarks>
             Matching is case-insensitive.
            
             Does not allocate managed memory.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.MatchesPrefix(System.String,UnityEngine.InputSystem.InputControl)">
             <summary>
             Check whether the given path matches <paramref name="control"/> or any of its parents.
             </summary>
             <param name="expected">A control path.</param>
             <param name="control">An input control.</param>
             <returns>True if the given path matches at least a partial path to <paramref name="control"/>.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="expected"/> is <c>null</c> or empty -or-
             <paramref name="control"/> is <c>null</c>.</exception>
             <remarks>
             <example>
             <code>
             // True as the path matches the Keyboard device itself, i.e. the parent of
             // Keyboard.aKey.
             InputControlPath.MatchesPrefix("&lt;Keyboard&gt;", Keyboard.current.aKey);
            
             // False as the path matches none of the controls leading to Keyboard.aKey.
             InputControlPath.MatchesPrefix("&lt;Gamepad&gt;", Keyboard.current.aKey);
            
             // True as the path matches Keyboard.aKey itself.
             InputControlPath.MatchesPrefix("&lt;Keyboard&gt;/a", Keyboard.current.aKey);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.MatchControlsRecursive``1(UnityEngine.InputSystem.InputControl,System.String,System.Int32,UnityEngine.InputSystem.InputControlList{``0}@,System.Boolean)">
            <summary>
            Recursively match path elements in <paramref name="path"/>.
            </summary>
            <param name="control">Current control we're at.</param>
            <param name="path">Control path we are matching against.</param>
            <param name="indexInPath">Index of current component in <paramref name="path"/>.</param>
            <param name="matches"></param>
            <param name="matchMultiple"></param>
            <typeparam name="TControl"></typeparam>
            <returns></returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent">
            <summary>
            A single component of a parsed control path as returned by <see cref="M:UnityEngine.InputSystem.InputControlPath.Parse(System.String)"/>. For example, in the
            control path <c>"&lt;Gamepad&gt;/buttonSouth"</c>, there are two parts: <c>"&lt;Gamepad&gt;"</c>
            and <c>"buttonSouth"</c>.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputControlPath.Parse(System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent.layout">
            <summary>
            Name of the layout (the part between '&lt;' and '&gt;') referenced in the component or <c>null</c> if no layout
            is specified. In <c>"&lt;Gamepad&gt;/buttonSouth"</c> the first component will return
            <c>"Gamepad"</c> from this property and the second component will return <c>null</c>.
            </summary>
            <seealso cref="T:UnityEngine.InputSystem.Layouts.InputControlLayout"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.LoadLayout(System.String)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.layout"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent.usages">
            <summary>
            List of device or control usages (the part between '{' and '}') referenced in the component or an empty
            enumeration. In <c>"&lt;XRController&gt;{RightHand}/trigger"</c>, for example, the
            first component will have a single element <c>"RightHand"</c> in the enumeration
            and the second component will have an empty enumeration.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.usages"/>
            <seealso cref="M:UnityEngine.InputSystem.InputSystem.AddDeviceUsage(UnityEngine.InputSystem.InputDevice,System.String)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent.name">
            <summary>
            Name of the device or control referenced in the component or <c>null</c> In
            <c>"&lt;Gamepad&gt;/buttonSouth"</c>, for example, the first component will
            have a <c>null</c> name and the second component will have <c>"buttonSouth"</c>
            in the name.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.name"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent.displayName">
            <summary>
            Display name of the device or control (the part inside of '#(...)') referenced in the component
            or <c>null</c>. In <c>"&lt;Keyboard&gt;/#(*)"</c>, for example, the first component will
            have a null displayName and the second component will have a displayName of <c>"*"</c>.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.displayName"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.ParsedPathComponent.Matches(UnityEngine.InputSystem.InputControl)">
            <summary>
            Whether the given control matches the constraints of this path component.
            </summary>
            <param name="control">Control to match against the path spec.</param>
            <returns>True if <paramref name="control"/> matches the constraints.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlPath.Parse(System.String)">
             <summary>
             Splits a control path into its separate components.
             </summary>
             <param name="path">A control path such as <c>"&lt;Gamepad&gt;/buttonSouth"</c>.</param>
             <returns>An enumeration of the parsed components. The enumeration is empty if the given
             <paramref name="path"/> is empty.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <c>null</c> or empty.</exception>
             <remarks>
             You can use this method, for example, to separate out the components in a binding's <see cref="P:UnityEngine.InputSystem.InputBinding.path"/>.
            
             <example>
             <code>
             var parsed = InputControlPath.Parse("&lt;XRController&gt;{LeftHand}/trigger").ToArray();
            
             Debug.Log(parsed.Length); // Prints 2.
             Debug.Log(parsed[0].layout); // Prints "XRController".
             Debug.Log(parsed[0].name); // Prints an empty string.
             Debug.Log(parsed[0].usages.First()); // Prints "LeftHand".
             Debug.Log(parsed[1].layout); // Prints null.
             Debug.Log(parsed[1].name); // Prints "trigger".
            
             // Find out if the given device layout is based on "TrackedDevice".
             Debug.Log(InputSystem.IsFirstLayoutBasedOnSecond(parsed[0].layout, "TrackedDevice")); // Prints true.
            
             // Load the device layout referenced by the path.
             var layout = InputSystem.LoadLayout(parsed[0].layout);
             Debug.Log(layout.baseLayouts.First()); // Prints "TrackedDevice".
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.path"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.FindControl(System.String)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlExtensions">
            <summary>
            Various extension methods for <see cref="T:UnityEngine.InputSystem.InputControl"/>. Mostly low-level routines.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.FindInParentChain``1(UnityEngine.InputSystem.InputControl)">
            <summary>
            Find a control of the given type in control hierarchy of <paramref name="control"/>.
            </summary>
            <param name="control">Control whose parents to inspect.</param>
            <typeparam name="TControl">Type of control to look for. Actual control type can be
            subtype of this.</typeparam>
            <remarks>The found control of type <typeparamref name="TControl"/> which may be either
            <paramref name="control"/> itself or one of its parents. If no such control was found,
            returns <c>null</c>.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.IsPressed(UnityEngine.InputSystem.InputControl,System.Single)">
            <summary>
            Check whether the given control is considered pressed according to the button press threshold.
            </summary>
            <param name="control">Control to check.</param>
            <param name="buttonPressPoint">Optional custom button press point. If not supplied, <see cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
            is used.</param>
            <returns>True if the actuation of the given control is high enough for it to be considered pressed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
            <remarks>
            This method checks the actuation level of the control as <see cref="M:UnityEngine.InputSystem.InputControlExtensions.IsActuated(UnityEngine.InputSystem.InputControl,System.Single)"/> does. For <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>s
            and other <c>float</c> value controls, this will effectively check whether the float value of the control exceeds the button
            point threshold. Note that if the control is an axis that can be both positive and negative, the press threshold works in
            both directions, i.e. it can be crossed both in the positive direction and in the negative direction.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.IsActuated(UnityEngine.InputSystem.InputControl,System.Single)"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>
            <seealso cref="P:UnityEngine.InputSystem.InputSystem.settings"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.IsActuated(UnityEngine.InputSystem.InputControl,System.Single)">
             <summary>
             Return true if the given control is actuated.
             </summary>
             <param name="control"></param>
             <param name="threshold">Magnitude threshold that the control must match or exceed to be considered actuated.
             An exception to this is the default value of zero. If threshold is zero, the control must have a magnitude
             greater than zero.</param>
             <returns></returns>
             <remarks>
             Actuation is defined as a control having a magnitude (<see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>
             greater than zero or, if the control does not support magnitudes, has been moved from its default
             state.
            
             In practice, this means that when actuated, a control will produce a value other than its default
             value.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueAsObject(UnityEngine.InputSystem.InputControl)">
             <summary>
             Read the current value of the control and return it as an object.
             </summary>
             <returns></returns>
             <remarks>
             This method allocates GC memory and thus may cause garbage collection when used during gameplay.
            
             Use <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueIntoBuffer(UnityEngine.InputSystem.InputControl,System.Void*,System.Int32)"/> to read values generically without having to know the
             specific value type of a control.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueIntoBuffer(UnityEngine.InputSystem.InputControl,System.Void*,System.Int32)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueIntoBuffer(UnityEngine.InputSystem.InputControl,System.Void*,System.Int32)">
            <summary>
            Read the current, processed value of the control and store it into the given memory buffer.
            </summary>
            <param name="buffer">Buffer to store value in. Note that the value is not stored with the offset
            found in <see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.byteOffset"/> of the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>. It will
            be stored directly at the given address.</param>
            <param name="bufferSize">Size of the memory available at <paramref name="buffer"/> in bytes. Has to be
            at least <see cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>. If the size is smaller, nothing will be written to the buffer.</param>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueSizeInBytes"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.valueType"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateIntoBuffer(System.Void*,System.Void*,System.Int32)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadDefaultValueAsObject(UnityEngine.InputSystem.InputControl)">
            <summary>
            Read the control's default value and return it as an object.
            </summary>
            <param name="control">Control to read default value from.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is null.</exception>
            <remarks>
            This method allocates GC memory and should thus not be used during normal gameplay.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.hasDefaultState"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.defaultStatePtr"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueFromEvent``1(UnityEngine.InputSystem.InputControl{``0},UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Read the value for the given control from the given event.
            </summary>
            <param name="control">Control to read value for.</param>
            <param name="inputEvent">Event to read value from. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <typeparam name="TValue">Type of value to read.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="inputEvent"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</exception>
            <returns>The value for the given control as read out from the given event or <c>default(TValue)</c> if the given
            event does not contain a value for the control (e.g. if it is a <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> not containing the relevant
            portion of the device's state memory).</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueFromEvent``1(UnityEngine.InputSystem.InputControl{``0},UnityEngine.InputSystem.LowLevel.InputEventPtr,``0@)">
            <summary>
            Check if the given event contains a value for the given control and if so, read the value.
            </summary>
            <param name="control">Control to read value for.</param>
            <param name="inputEvent">Input event. This must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.
            Note that in the case of a <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>, the control may not actually be part of the event. In this
            case, the method returns false and stores <c>default(TValue)</c> in <paramref name="value"/>.</param>
            <param name="value">Variable that receives the control value.</param>
            <typeparam name="TValue">Type of value to read.</typeparam>
            <returns>True if the value has been successfully read from the event, false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="inputEvent"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.ReadUnprocessedValueFromEvent``1(UnityEngine.InputSystem.InputControl{``0},UnityEngine.InputSystem.LowLevel.InputEventPtr)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ReadValueFromEventAsObject(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Read the value of <paramref name="control"/> from the given <paramref name="inputEvent"/> without having to
            know the specific value type of the control.
            </summary>
            <param name="control">Control to read the value for.</param>
            <param name="inputEvent">An <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> to read the value from.</param>
            <returns>The current value for the control or <c>null</c> if the control's value is not included
            in the event.</returns>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.ReadValueFromStateAsObject(System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.WriteValueIntoState(UnityEngine.InputSystem.InputControl,System.Void*)">
            <summary>
            Write the control's current value into <paramref name="statePtr"/>.
            </summary>
            <param name="control">Control to read the current value from and to store state for in <paramref name="statePtr"/>.</param>
            <param name="statePtr">State to receive the control's value in its respective <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is null or <paramref name="statePtr"/> is null.</exception>
            <remarks>
            This method is equivalent to <see cref="M:UnityEngine.InputSystem.InputControl`1.WriteValueIntoState(`0,System.Void*)"/> except that one does
            not have to know the value type of the given control.
            </remarks>
            <exception cref="T:System.NotSupportedException">The control does not support writing. This is the case, for
            example, that compute values (such as the magnitude of a vector).</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControl`1.WriteValueIntoState(`0,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.WriteValueIntoState``2(UnityEngine.InputSystem.InputControl{``0},``0,``1@)">
             <summary>
            
             </summary>
             <param name="state"></param>
             <param name="value">Value for <paramref name="control"/> to write into <paramref name="state"/>.</param>
             <typeparam name="TState"></typeparam>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is null.</exception>
             <exception cref="T:System.ArgumentException">Control's value does not fit within the memory of <paramref name="state"/>.</exception>
             <exception cref="T:System.NotSupportedException"><paramref name="control"/> does not support writing.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CopyState(UnityEngine.InputSystem.InputDevice,System.Void*,System.Int32)">
            <summary>
            Copy the state of the device to the given memory buffer.
            </summary>
            <param name="device">An input device.</param>
            <param name="buffer">Buffer to copy the state of the device to.</param>
            <param name="bufferSizeInBytes">Size of <paramref name="buffer"/> in bytes.</param>
            <exception cref="T:System.ArgumentException"><paramref name="bufferSizeInBytes"/> is less than or equal to 0.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
            <remarks>
            The method will copy however much fits into the given buffer. This means that if the state of the device
            is larger than what fits into the buffer, not all of the device's state is copied.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CopyState``1(UnityEngine.InputSystem.InputDevice,``0@)">
            <summary>
            Copy the state of the device to the given struct.
            </summary>
            <param name="device">An input device.</param>
            <param name="state">Struct to copy the state of the device into.</param>
            <typeparam name="TState">A state struct type such as <see cref="T:UnityEngine.InputSystem.LowLevel.MouseState"/>.</typeparam>
            <exception cref="T:System.ArgumentException">The state format of <typeparamref name="TState"/> does not match
            the state form of <paramref name="device"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="device"/> is <c>null</c>.</exception>
            <remarks>
            This method will copy memory verbatim into the memory of the given struct. It will copy whatever
            memory of the device fits into the given struct.
            </remarks>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CheckStateIsAtDefault(UnityEngine.InputSystem.InputControl)">
             <summary>
             Check whether the memory of the given control is in its default state.
             </summary>
             <param name="control">An input control on a device that's been added to the system (see <see cref="P:UnityEngine.InputSystem.InputDevice.added"/>).</param>
             <returns>True if the state memory of the given control corresponds to the control's default.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
             <remarks>
             This method is a cheaper check than actually reading out the value from the control and checking whether it
             is the same value as the default value. The method bypasses all value reading and simply performs a trivial
             memory comparison of the control's current state memory to the default state memory stored for the control.
            
             Note that the default state for the memory of a control does not necessary need to be all zeroes. For example,
             a stick axis may be stored as an unsigned 8-bit value with the memory state corresponding to a 0 value being 127.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CheckStateIsAtDefault(UnityEngine.InputSystem.InputControl,System.Void*,System.Void*)">
            <summary>
            Check if the given state corresponds to the default state of the control.
            </summary>
            <param name="control">Control to check the state for in <paramref name="statePtr"/>.</param>
            <param name="statePtr">Pointer to a state buffer containing the <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/> for <paramref name="control"/>.</param>
            <param name="maskPtr">If not null, only bits set to <c>false</c> (!) in the buffer will be taken into account. This can be used
            to mask out noise, i.e. every bit that is set in the mask is considered to represent noise.</param>
            <returns>True if the control/device is in its default state.</returns>
            <remarks>
            Note that default does not equate all zeroes. Stick axes, for example, that are stored as unsigned byte
            values will have their resting position at 127 and not at 0. This is why we explicitly store default
            state in a memory buffer instead of assuming zeroes.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl`1.ReadDefaultValue"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CheckStateIsAtDefaultIgnoringNoise(UnityEngine.InputSystem.InputControl,System.Void*)">
            <summary>
            Check if the given state corresponds to the default state of the control or has different state only
            for parts marked as noise.
            </summary>
            <param name="control">Control to check the state for in <paramref name="statePtr"/>.</param>
            <param name="statePtr">Pointer to a state buffer containing the <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/> for <paramref name="control"/>.</param>
            <returns>True if the control/device is in its default state (ignoring any bits marked as noise).</returns>
            <remarks>
            Note that default does not equate all zeroes. Stick axes, for example, that are stored as unsigned byte
            values will have their resting position at 127 and not at 0. This is why we explicitly store default
            state in a memory buffer instead of assuming zeroes.
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl`1.ReadDefaultValue"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.noisy"/>
            <seealso cref="P:UnityEngine.InputSystem.InputControl.noiseMaskPtr"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CompareStateIgnoringNoise(UnityEngine.InputSystem.InputControl,System.Void*)">
             <summary>
             Compare the control's current state to the state stored in <paramref name="statePtr"/>.
             </summary>
             <param name="statePtr">State memory containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.</param>
             <returns>True if </returns>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.currentStatePtr"/>
             <remarks>
             This method ignores noise
            
             This method will not actually read values but will instead compare state directly as it is stored
             in memory. <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/> is not invoked and thus processors will
             not be run.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.CompareState(UnityEngine.InputSystem.InputControl,System.Void*,System.Void*,System.Void*)">
            <summary>
            Compare the control's stored state in <paramref name="firstStatePtr"/> to <paramref name="secondStatePtr"/>.
            </summary>
            <param name="firstStatePtr">Memory containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>.</param>
            <param name="secondStatePtr">Memory containing the control's <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/></param>
            <param name="maskPtr">Optional mask. If supplied, it will be used to mask the comparison between
            <paramref name="firstStatePtr"/> and <paramref name="secondStatePtr"/> such that any bit not set in the
            mask will be ignored even if different between the two states. This can be used, for example, to ignore
            noise in the state (<see cref="P:UnityEngine.InputSystem.InputControl.noiseMaskPtr"/>).</param>
            <returns>True if the state is equivalent in both memory buffers.</returns>
            <remarks>
            Unlike <see cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>, this method only compares raw memory state. If used on a stick, for example,
            it may mean that this method returns false for two stick values that would compare equal using <see cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>
            (e.g. if both stick values fall below the deadzone).
            </remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControl.CompareValue(System.Void*,System.Void*)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.HasValueChangeInState(UnityEngine.InputSystem.InputControl,System.Void*)">
            <summary>
            Return true if the current value of <paramref name="control"/> is different to the one found
            in <paramref name="statePtr"/>.
            </summary>
            <param name="control">Control whose state to compare to what is stored in <paramref name="statePtr"/>.</param>
            <param name="statePtr">A block of input state memory containing the <see cref="P:UnityEngine.InputSystem.InputControl.stateBlock"/>
            of <paramref name="control.."/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c> or <paramref name="statePtr"/>
            is <c>null</c>.</exception>
            <returns>True if the value of <paramref name="control"/> stored in <paramref name="statePtr"/> is different
            compared to what <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/> of the control returns.</returns>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.HasValueChangeInEvent(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
            <summary>
            Return true if <paramref name="control"/> has a different value (from its current one) in
            <paramref name="eventPtr"/>.
            </summary>
            <param name="control">An input control.</param>
            <param name="eventPtr">An input event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <returns>True if <paramref name="eventPtr"/> contains a value for <paramref name="control"/> that is different
            from the control's current value (see <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c> -or- <paramref name="eventPtr"/> is a <c>null</c> pointer (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid"/>).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.GetStatePtrFromStateEvent(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Given a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>, return the raw memory pointer that can
             be used, for example, with <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromState(System.Void*)"/> to read out the value of <paramref name="control"/>
             contained in the event.
             </summary>
             <param name="control">Control to access state for in the given state event.</param>
             <param name="eventPtr">A <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> containing input state.</param>
             <returns>A pointer that can be used with methods such as <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValueFromState(System.Void*)"/> or <c>null</c>
             if <paramref name="eventPtr"/> does not contain state for the given <paramref name="control"/>.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c> -or- <paramref name="eventPtr"/> is invalid.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</exception>
             <remarks>
             Note that the given state event must have the same state format (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputStateBlock.format"/>) as the device
             to which <paramref name="control"/> belongs. If this is not the case, the method will invariably return <c>null</c>.
            
             In practice, this means that the method cannot be used with touch events or, in general, with events sent to devices
             that implement <see cref="T:UnityEngine.InputSystem.LowLevel.IInputStateCallbackReceiver"/> (which <see cref="T:UnityEngine.InputSystem.Touchscreen"/> does) except if the event
             is in the same state format as the device. Touch events will generally be sent as state events containing only the
             state of a single <see cref="T:UnityEngine.InputSystem.Controls.TouchControl"/>, not the state of the entire <see cref="T:UnityEngine.InputSystem.Touchscreen"/>.
             </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.ResetToDefaultStateInEvent(UnityEngine.InputSystem.InputControl,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Writes the default state of <paramref name="control"/> into <paramref name="eventPtr"/>.
             </summary>
             <param name="control">A control whose default state to write.</param>
             <param name="eventPtr">A valid pointer to either a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c> -or- <paramref name="eventPtr"/> contains
             a null pointer.</exception>
             <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</exception>
             <returns>True if the default state for <paramref name="control"/> was written to <paramref name="eventPtr"/>, false if the
             given state or delta state event did not include memory for the given control.</returns>
             <remarks>
             Note that the default state of a control does not necessarily need to correspond to zero-initialized memory. For example, if
             an axis control yields a range of [-1..1] and is stored as a signed 8-bit value, the default state will be 127, not 0.
            
             <example>
             <code>
             // Reset the left gamepad stick to its default state (which results in a
             // value of (0,0).
             using (StateEvent.From(Gamepad.all[0], out var eventPtr))
             {
                 Gamepad.all[0].leftStick.ResetToDefaultStateInEvent(eventPtr);
                 InputSystem.QueueEvent(eventPtr);
             }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputControl.defaultStatePtr"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.QueueValueChange``1(UnityEngine.InputSystem.InputControl{``0},``0,System.Double)">
            <summary>
            Queue a value change on the given <paramref name="control"/> which will be processed and take effect
            in the next input update.
            </summary>
            <param name="control">Control to change the value of.</param>
            <param name="value">New value for the control.</param>
            <param name="time">Optional time at which the value change should take effect. If set, this will become
            the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.time"/> of the queued event. If the time is in the future and the update mode is
            set to <see cref="F:UnityEngine.InputSystem.InputSettings.UpdateMode.ProcessEventsInFixedUpdate"/>, the event will not be processed until
            it falls within the time of an input update slice. Otherwise, the event will invariably be consumed in the
            next input update (see <see cref="M:UnityEngine.InputSystem.InputSystem.Update"/>).</param>
            <typeparam name="TValue">Type of value.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is null.</exception>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.AccumulateValueInEvent(UnityEngine.InputSystem.InputControl{System.Single},System.Void*,UnityEngine.InputSystem.LowLevel.InputEventPtr)">
             <summary>
             Modify <paramref name="newState"/> to write an accumulated value of the control
             rather than the value currently found in the event.
             </summary>
             <param name="control">Control to perform the accumulation on.</param>
             <param name="currentStatePtr">Memory containing the control's current state. See <see
             cref="P:UnityEngine.InputSystem.InputControl.currentStatePtr"/>.</param>
             <param name="newState">Event containing the new state about to be written to the device.</param>
             <exception cref="T:System.ArgumentNullException"><paramref name="control"/> is <c>null</c>.</exception>
             <remarks>
             This method reads the current, unprocessed value of the control from <see cref="P:UnityEngine.InputSystem.InputControl.currentStatePtr"/>
             and then adds it to the value of the control found in <paramref name="newState"/>.
            
             Note that the method does nothing if a value for the control is not contained in <paramref name="newState"/>.
             This can be the case, for example, for <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>s.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.Pointer.delta"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlExtensions.Enumerate">
            <summary>
            Flags that control which controls are returned by <see cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)"/>.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IgnoreControlsInDefaultState">
            <summary>
            Ignore controls whose value is at default (see <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadDefaultValue"/>).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IgnoreControlsInCurrentState">
            <summary>
            Ignore controls whose value is the same as their current value (see <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/>).
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IncludeSyntheticControls">
            <summary>
            Include controls that are <see cref="P:UnityEngine.InputSystem.InputControl.synthetic"/> and/or use state from other other controls (see
            <see cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.useStateFrom"/>). These are excluded by default.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IncludeNoisyControls">
            <summary>
            Include noisy controls (see <see cref="P:UnityEngine.InputSystem.InputControl.noisy"/>). These are excluded by default.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IncludeNonLeafControls">
            <summary>
            For any leaf control returned by the enumeration, also return all the parent controls (see <see cref="P:UnityEngine.InputSystem.InputControl.parent"/>)
            in turn (but not the root <see cref="T:UnityEngine.InputSystem.InputDevice"/> itself).
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)">
             <summary>
             Go through the controls that have values in <paramref name="eventPtr"/>, apply the given filters, and return each
             control one by one.
             </summary>
             <param name="eventPtr">An input event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
             <param name="flags">Filter settings that determine which controls to return.</param>
             <param name="device">Input device from which to enumerate controls. If this is <c>null</c>, then the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
             from the given <paramref name="eventPtr"/> will be used to locate the device via  <see cref="M:UnityEngine.InputSystem.InputSystem.GetDeviceById(System.Int32)"/>. If the device
             cannot be found, an exception will be thrown. Note that type of device must match the state stored in the given event.</param>
             <param name="magnitudeThreshold">If not zero, minimum actuation threshold (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) that
             a control must reach (as per value in the given <paramref name="eventPtr"/>) in order for it to be included in the enumeration.</param>
             <returns>An enumerator for the controls with values in <paramref name="eventPtr"/>.</returns>
             <exception cref="T:System.ArgumentNullException"><paramref name="eventPtr"/> is a <c>null</c> pointer (see <see cref="P:UnityEngine.InputSystem.LowLevel.InputEventPtr.valid"/>).</exception>
             <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> and not a <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> -or-
             <paramref name="device"/> is <c>null</c> and no device was found with a <see cref="P:UnityEngine.InputSystem.InputDevice.deviceId"/> matching that of <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
             found in <paramref name="eventPtr"/>.</exception>
             <remarks>
             This method is much more efficient than manually iterating over the controls of <paramref name="device"/> and locating
             the ones that have changed in <paramref name="eventPtr"/>. See <see cref="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlEnumerator"/> for details.
            
             This method will not allocate GC memory and can safely be used with <c>foreach</c> loops.
             </remarks>
             <seealso cref="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlEnumerator"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/>
             <seealso cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)">
             <summary>
             Go through all controls in the given <paramref name="eventPtr"/> that have changed value.
             </summary>
             <param name="eventPtr">An input event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
             <param name="device">Input device from which to enumerate controls. If this is <c>null</c>, then the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/>
             from the given <paramref name="eventPtr"/> will be used to locate the device via  <see cref="M:UnityEngine.InputSystem.InputSystem.GetDeviceById(System.Int32)"/>. If the device
             cannot be found, an exception will be thrown. Note that type of device must match the state stored in the given event.</param>
             <param name="magnitudeThreshold">If not zero, minimum actuation threshold (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) that
             a control must reach (as per value in the given <paramref name="eventPtr"/>) in order for it to be included in the enumeration.</param>
             <returns>An enumerator for the controls that have changed values in <paramref name="eventPtr"/>.</returns>
             <remarks>
             This method is a shorthand for calling <see cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)"/> with <see cref="F:UnityEngine.InputSystem.InputControlExtensions.Enumerate.IgnoreControlsInCurrentState"/>.
            
             <example>
             <code>
             // Detect button presses.
             InputSystem.onEvent +=
               (eventPtr, device) =>
               {
                   // Ignore anything that is not a state event.
                   var eventType = eventPtr.type;
                   if (eventType != StateEvent.Type &amp;&amp; eventType != DeltaStateEvent.Type)
                       return;
            
                   // Find all changed controls actuated above the button press threshold.
                   foreach (var control in eventPtr.EnumerateChangedControls
                       (device: device, magnitudeThreshold: InputSystem.settings.defaultButtonPressThreshold))
                       if (control is ButtonControl button)
                           Debug.Log($"Button {button} was pressed");
               }
             </code>
             </example>
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.onEvent"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)"/>
             <seealso cref="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlEnumerator"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.HasButtonPress(UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single,System.Boolean)">
            <summary>
            Return true if the given <paramref name="eventPtr"/> has any <see cref="T:UnityEngine.Input"/>
            </summary>
            <param name="eventPtr">An event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <param name="magnitude">The threshold value that a button must be actuated by to be considered pressed.</param>
            <param name="buttonControlsOnly">Whether the method should only consider button controls.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventPtr"/> is a <c>null</c> pointer.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/> -or-
            the <see cref="T:UnityEngine.InputSystem.InputDevice"/> referenced by the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> in the event cannot be found.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
            <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.GetFirstButtonPressOrNull(UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single,System.Boolean)">
            <summary>
            Get the first pressed button from the given event or null if the event doesn't contain a new button press.
            </summary>
            <param name="eventPtr">An event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <param name="magnitude">The threshold value that a control must be actuated by (see
            <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) to be considered pressed. If not given, defaults to <see
            cref="P:UnityEngine.InputSystem.InputSettings.defaultButtonPressPoint"/>.</param>
            <param name="buttonControlsOnly">Whether the method should only consider <see cref="T:UnityEngine.InputSystem.Controls.ButtonControl"/>s. Otherwise,
            any <see cref="T:UnityEngine.InputSystem.InputControl"/> that has an actuation (see <see cref="M:UnityEngine.InputSystem.InputControl.EvaluateMagnitude"/>) equal to
            or greater than the given <paramref name="magnitude"/> will be considered a pressed button. This is 'true' by
            default.</param>
            <returns>The control that was pressed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventPtr"/> is a <c>null</c> pointer.</exception>
            <exception cref="T:System.ArgumentException">The <see cref="T:UnityEngine.InputSystem.InputDevice"/> referenced by the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> in the event cannot
            be found.</exception>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
            <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
            <remarks>Buttons will be evaluated in the order that they appear in the devices layout i.e. the bit position of each control
            in the devices state memory. For example, in the gamepad state, button north (bit position 4) will be evaluated before button
            east (bit position 5), so if both buttons were pressed in the given event, button north would be returned.
            Note that the function returns null if the <paramref name="eventPtr"/> is not a StateEvent or DeltaStateEvent.</remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.GetAllButtonPresses(UnityEngine.InputSystem.LowLevel.InputEventPtr,System.Single,System.Boolean)">
            <summary>
            Enumerate all pressed buttons in the given event.
            </summary>
            <param name="eventPtr">An event. Must be a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</param>
            <param name="magnitude">The threshold value that a button must be actuated by to be considered pressed.</param>
            <param name="buttonControlsOnly">Whether the method should only consider button controls.</param>
            <returns>An enumerable collection containing all buttons that were pressed in the given event.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventPtr"/> is a <c>null</c> pointer.</exception>
            <exception cref="T:System.ArgumentException">The <see cref="T:UnityEngine.InputSystem.InputDevice"/> referenced by the <see cref="P:UnityEngine.InputSystem.LowLevel.InputEvent.deviceId"/> in the event cannot be found.</exception>
            <remarks>Returns an empty enumerable if the <paramref name="eventPtr"/> is not a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.</remarks>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
            <seealso cref="P:UnityEngine.InputSystem.Controls.ButtonControl.isPressed"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlCollection">
            <summary>
            Allows iterating over the controls referenced by an <see cref="T:UnityEngine.InputSystem.LowLevel.InputEvent"/> via <see cref="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlEnumerator"/>.
            </summary>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)"/>
            <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
        </member>
        <member name="P:UnityEngine.InputSystem.InputControlExtensions.InputEventControlCollection.eventPtr">
            <summary>
            The event being iterated over. A <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputControlExtensions.InputEventControlCollection.GetEnumerator">
            <summary>
            Enumerate the controls in the event.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputControlExtensions.InputEventControlEnumerator">
             <summary>
             Iterates over the controls in a <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> or <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>
             while optionally applying certain filtering criteria.
             </summary>
             <remarks>
             One problem with state events (that is, <see cref="T:UnityEngine.InputSystem.LowLevel.StateEvent"/> and <see cref="T:UnityEngine.InputSystem.LowLevel.DeltaStateEvent"/>)
             is that they contain raw blocks of memory which may contain state changes for arbitrary many
             controls on a device at the same time. Locating individual controls and determining which have
             changed state and how can thus be quite inefficient.
            
             This helper aims to provide an easy and efficient way to iterate over controls relevant to a
             given state event. Instead of iterating over the controls of a device looking for the ones
             relevant to a given event, enumeration is done the opposite by efficiently searching through
             the memory contained in an event and then mapping data found in the event back to controls
             on a given device.
            
             <example>
             <code>
             // Inefficient:
             foreach (var control in device.allControls)
             {
                 // Skip control if it is noisy, synthetic, or not a leaf control.
                 if (control.synthetic || control.noisy || control.children.Count > 0)
                     continue;
            
                 // Locate the control in the event.
                 var statePtr = eventPtr.GetStatePtrFromStateEvent(eventPtr);
                 if (statePtr == null)
                     continue; // Control not included in event.
            
                 // See if the control is actuated beyond a minimum threshold.
                 if (control.EvaluateMagnitude(statePtr) &lt; 0.001f)
                     continue;
            
                 Debug.Log($"Found actuated control {control}");
             }
            
             // Much more efficient:
             foreach (var control in eventPtr.EnumerateControls(
                 InputControlExtensions.Enumerate.IgnoreControlsInDefaultState,
                 device: device,
                 magnitudeThreshold: 0.001f))
             {
                 Debug.Log($"Found actuated control {control}");
             }
             </code>
             </example>
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputControlExtensions.Enumerate,UnityEngine.InputSystem.InputDevice,System.Single)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputControlExtensions.EnumerateChangedControls(UnityEngine.InputSystem.LowLevel.InputEventPtr,UnityEngine.InputSystem.InputDevice,System.Single)"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputProcessor">
             <summary>
             A processor that conditions/transforms input values.
             </summary>
             <remarks>
             To define a custom processor, it is usable best to derive from <see cref="T:UnityEngine.InputSystem.InputProcessor`1"/>
             instead of from this class. Doing so will avoid having to deal with things such as the raw memory
             buffers of <see cref="M:UnityEngine.InputSystem.InputProcessor.Process(System.Void*,System.Int32,UnityEngine.InputSystem.InputControl)"/>.
            
             Note, however, that if you do want to define a processor that can process more than one type of
             value, you can derive directly from this class.
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputBinding.processors"/>
             <seealso cref="P:UnityEngine.InputSystem.Layouts.InputControlLayout.ControlItem.processors"/>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor``1(System.String)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.GetParameterValue(UnityEngine.InputSystem.InputAction,System.String,UnityEngine.InputSystem.InputBinding)"/>
             <seealso cref="M:UnityEngine.InputSystem.InputActionRebindingExtensions.ApplyParameterOverride(UnityEngine.InputSystem.InputActionMap,System.String,UnityEngine.InputSystem.Utilities.PrimitiveValue,UnityEngine.InputSystem.InputBinding)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputProcessor.ProcessAsObject(System.Object,UnityEngine.InputSystem.InputControl)">
            <summary>
            Process an input value, given as an object, and return the processed value as an object.
            </summary>
            <param name="value">A value matching the processor's value type.</param>
            <param name="control">Optional control that the value originated from. Must have the same value type
            that the processor has.</param>
            <returns>A processed value based on <paramref name="value"/>.</returns>
            <remarks>
            This method allocates GC heap memory. To process values without allocating GC memory, it is necessary to either know
            the value type of a processor at compile time and call <see cref="M:UnityEngine.InputSystem.InputProcessor`1.Process(`0,UnityEngine.InputSystem.InputControl)"/>
            directly or to use <see cref="M:UnityEngine.InputSystem.InputProcessor.Process(System.Void*,System.Int32,UnityEngine.InputSystem.InputControl)"/> instead and process values in raw memory buffers.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputProcessor.Process(System.Void*,System.Int32,UnityEngine.InputSystem.InputControl)">
            <summary>
            Process an input value stored in the given memory buffer.
            </summary>
            <param name="buffer">Memory buffer containing the input value. Must be at least large enough
            to hold one full value as indicated by <paramref name="bufferSize"/>.</param>
            <param name="bufferSize">Size (in bytes) of the value inside <paramref name="buffer"/>.</param>
            <param name="control">Optional control that the value originated from. Must have the same value type
            that the processor has.</param>
            <remarks>
            This method allows processing values of arbitrary size without allocating memory on the GC heap.
            </remarks>
        </member>
        <member name="M:UnityEngine.InputSystem.InputProcessor.GetValueTypeFromType(System.Type)">
            <summary>
            Get the value type of a processor without having to instantiate it and use <see cref="!:valueType"/>.
            </summary>
            <param name="processorType"></param>
            <returns>Value type of the given processor or null if it could not be determined statically.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="processorType"/> is null.</exception>
            <remarks>
            This method is reliant on the processor being based on <see cref="T:UnityEngine.InputSystem.InputProcessor`1"/>. It will return
            the <c>TValue</c> argument used with the class. If the processor is not based on <see cref="T:UnityEngine.InputSystem.InputProcessor`1"/>,
            this method returns null.
            </remarks>
        </member>
        <member name="T:UnityEngine.InputSystem.InputProcessor.CachingPolicy">
            <summary>
            Caching policy regarding usage of return value from processors.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputProcessor.CachingPolicy.CacheResult">
            <summary>
            Cache result value if unprocessed value has not been changed.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputProcessor.CachingPolicy.EvaluateOnEveryRead">
            <summary>
            Process value every call to <see cref="M:UnityEngine.InputSystem.InputControl`1.ReadValue"/> even if unprocessed value has not been changed.
            </summary>
        </member>
        <member name="P:UnityEngine.InputSystem.InputProcessor.cachingPolicy">
            <summary>
            Caching policy of the processor. Override this property to provide a different value.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputProcessor`1">
             <summary>
             A processor that conditions/transforms input values.
             </summary>
             <typeparam name="TValue">Type of value to be processed. Only InputControls that use the
             same value type will be compatible with the processor.</typeparam>
             <remarks>
             Each <see cref="T:UnityEngine.InputSystem.InputControl"/> can have a stack of processors assigned to it.
            
             Note that processors CANNOT be stateful. If you need processing that requires keeping
             mutating state over time, use InputActions. All mutable state needs to be
             kept in the central state buffers.
            
             However, processors can have configurable parameters. Every public field on a processor
             object can be set using "parameters" in JSON or by supplying parameters through the
             <see cref="P:UnityEngine.InputSystem.Layouts.InputControlAttribute.processors"/> field.
            
             <example>
             <code>
             // To register the processor, call
             //
             //    InputSystem.RegisterProcessor&lt;ScalingProcessor&gt;("scale");
             //
             public class ScalingProcessor : InputProcessor&lt;float&gt;
             {
                 // This field can be set as a parameter. See examples below.
                 // If not explicitly configured, will have its default value.
                 public float factor = 2.0f;
            
                 public float Process(float value, InputControl control)
                 {
                     return value * factor;
                 }
             }
            
             // Use processor in JSON:
             const string json = @"
                 {
                     ""name"" : ""MyDevice"",
                     ""controls"" : [
                         { ""name"" : ""axis"", ""layout"" : ""Axis"", ""processors"" : ""scale(factor=4)"" }
                     ]
                 }
             ";
            
             // Use processor on C# state struct:
             public struct MyDeviceState : IInputStateTypeInfo
             {
                 [InputControl(layout = "Axis", processors = "scale(factor=4)"]
                 public float axis;
             }
             </code>
             </example>
            
             See <see cref="T:UnityEngine.InputSystem.Editor.InputParameterEditor`1"/> for how to define custom parameter
             editing UIs for processors.
             </remarks>
             <seealso cref="M:UnityEngine.InputSystem.InputSystem.RegisterProcessor(System.Type,System.String)"/>
        </member>
        <member name="M:UnityEngine.InputSystem.InputProcessor`1.Process(`0,UnityEngine.InputSystem.InputControl)">
            <summary>
            Process the given value and return the result.
            </summary>
            <remarks>
            The implementation of this method must not be stateful.
            </remarks>
            <param name="value">Input value to process.</param>
            <param name="control">Control that the value originally came from. This can be null if the value did
                not originate from a control. This can be the case, for example, if the processor sits on a composite
                binding (<see cref="T:UnityEngine.InputSystem.InputBindingComposite"/>) as composites are not directly associated with controls
                but rather source their values through their child bindings.</param>
            <returns>Processed input value.</returns>
        </member>
        <member name="T:UnityEngine.InputSystem.InputRemoting">
             <summary>
             Makes the activity and data of an InputManager observable in message form.
             </summary>
             <remarks>
             Can act as both the sender and receiver of these message so the flow is fully bidirectional,
             i.e. the InputManager on either end can mirror its layouts, devices, and events over
             to the other end. This permits streaming input not just from the player to the editor but
             also feeding input from the editor back into the player.
            
             Remoting sits entirely on top of the input system as an optional piece of functionality.
             In development players and the editor, we enable it automatically but in non-development
             players it has to be explicitly requested by the user.
            
             To see devices and input from players in the editor, open the Input Debugger through
             "Windows >> Input Debugger".
             </remarks>
             <seealso cref="P:UnityEngine.InputSystem.InputSystem.remoting"/>
        </member>
        <member name="T:UnityEngine.InputSystem.InputRemoting.MessageType">
            <summary>
            Enumeration of possible types of messages exchanged between two InputRemoting instances.
            </summary>
        </member>
        <member name="T:UnityEngine.InputSystem.InputRemoting.Message">
            <summary>
            A message exchanged between two InputRemoting instances.
            </summary>
        </member>
        <member name="F:UnityEngine.InputSystem.InputRemoting.Message.participantId">
            <summary>
            For messages coming in, numeric ID of the sender of the message. For messages
            going out, numeric ID of the targeted receiver of the message.
            </summary>
        </member>
        <member name="M:UnityEngine.InputSystem.InputRemoting.StartSending">
            <summary>
            Start sending messages for data and activity in the local input system
            to observers.
            </summary>
            <seealso cref="P:UnityEngine.InputSystem.InputRemoting.sending"/>
            <seealso cref="M:UnityEngine.InputSystem.InputRemoting.StopSending"/>
        </member>
        <member name="T:UnityEngine.XR.WindowsMR.Input.WMRHMD">
            <summary>
            A Windows Mixed Reality XR headset.
            </summary>
        </member>
        <member name="T:UnityEngine.XR.WindowsMR.Input.HololensHand">
            <summary>
            A Windows Mixed Reality XR controller.
            </summary>
        </member>
        <member name="T:Unity.XR.Oculus.Input.OculusHMD">
            <summary>
            An Oculus VR headset (such as the Oculus Rift series of devices).
            </summary>
        </member>
        <member name="T:Unity.XR.Oculus.Input.OculusTouchController">
            <summary>
            An Oculus Touch controller.
            </summary>
        </member>
        <member name="T:Unity.XR.Oculus.Input.OculusRemote">
            <summary>
            An Oculus Remote controller.
            </summary>
        </member>
        <member name="T:Unity.XR.Oculus.Input.OculusHMDExtended">
            <summary>
            A Standalone VR headset that includes on-headset controls.
            </summary>
        </member>
        <member name="T:Unity.XR.Oculus.Input.GearVRTrackedController">
            <summary>
            A Gear VR controller.
            </summary>
        </member>
        <member name="T:Unity.XR.OpenVR.ViveWand">
            <summary>
            An HTC Vive Wand controller.
            </summary>
        </member>
        <member name="T:Unity.XR.OpenVR.ViveLighthouse">
            <summary>
            An HTC Vive lighthouse.
            </summary>
        </member>
        <member name="T:Unity.XR.OpenVR.ViveTracker">
            <summary>
            An HTC Vive tracker.
            </summary>
        </member>
        <member name="T:Unity.XR.OpenVR.OpenVROculusTouchController">
            <summary>
            An Oculus Touch controller.
            </summary>
        </member>
        <member name="T:Unity.XR.GoogleVr.DaydreamHMD">
            <summary>
            A head-mounted display powered by Google Daydream.
            </summary>
        </member>
        <member name="T:Unity.XR.GoogleVr.DaydreamController">
            <summary>
            An XR controller powered by Google Daydream.
            </summary>
        </member>
    </members>
</doc>
